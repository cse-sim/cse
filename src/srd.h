// Copyright (c) 1997-2019 The CSE Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file.

/* srd.h: definitions for "small record (& field, etc) descriptors":
	  data and record definition info generated as C source code by rcdef.exe,
	  for compilation and linking into programs, rcdef-generated source files:

	      dttab.c: data types table
		  untab.c: units table
	      srfd.c:  field types table, fields-of-records tables, small record descriptor table.

	  comments written early in development 1-30-91; may be obsolete */

#ifndef SRD_H
#define SRD_H

//=============== DATA TYPES: dttab.cpp

//--- Data type word: DTxxx define in dtypes.h, generated by rcdef from cndtypes.def.
//    Hi bits are attributes, lo bits index (subscript) into Dttab.
#define DTBCHOICN 0x4000	// float number-or-choice data type: choice values (hi word)(nans) are 7f81, 7f82, ...
#define DTBCHOICB 0x2000	// "improved" simplified choice data type: Internal values are 1, 2, 3...
#define DTBMASK   0x1fff	// mask for lo bits that index into Dttab[] to get size & choice info.  See rcdef.c.


//--- Data type table

// data type table globals - but access using GetDttab(), below
extern LI Dttab[];   		// dttab.cpp, generated by rcdef.exe
extern size_t Dttmax;		//   size (in LI's) of Dttab

// structure for accessing data type table entry
//			(Dttab may be constructed by rcdef.exe as array of LI, with subscript dt & DTBMASK,
//                      size in loword, # choices in hiword, char * choice text ptrs following.)
struct DTTAB
{   // next two correspond to LOWORD and HIWORD, respectively, of LI Dttab[masked dt]
     SI size;        	// storage size of choice data type (2)
     SI nchoices;    	// # choices (incl hidden choices) <-- 0 (HIWORD) in non-choice type, cd use as choice type indicator.
    // next member corresponds to Dttab[dt+1...]
     char* choicbs[1];	// array of text pointers (compiled/linked Dttab) for texts of choices 1,2,3 ... .
						// Texts of hidden choices start with '*'.
};

//- function for accessing data type table entry: .size, .nchoices, .choicbs[0..].
inline DTTAB& GetDttab(USI dt) { return *(DTTAB *)(Dttab+((dt)&DTBMASK)); }

//- function for accessing text for a choice. for choicn 'chan' is CHN(value). CHN, NCNAN: cnglob.h.
//   but, to access with checks, use ::getChoiTx( dt, chan).
inline const char* GetChoiceText( USI dt, USI chan) { return GetDttab(dt).choicbs[(chan & ~NCNAN) - 1]; }

//-- expr() data types --   each type is different bit so can represent groups of types and test with 'and'.  Data type USI.
#define TYSI    0x01		// 16-bit integer (or BOOlean)
#define TYFL    0x02		// float
#define TYNUM   (TYSI|TYFL)	// "any numeric data type" (test by and'ing)
#define TYSTR   0x04		// string
#define TYFLSTR (TYFL|TYSTR)	// number (as float) or string, known at compile time. for CSE reportCol.colVal.
#define TYID	0x08		// id: string; quotes implied around non-reserved identifier (for record names) at outer level
#define TYCH   0x10		// choice (DTxxx must also be given): string or id, conv to 16/32 bit choicb/choicn value
#define TYNC   (TYFL|TYCH)	// number (float) or specified 32 bit choicn choice, not necess known til runtime.
//	TYDOY	day of year: def in cul.h; given to cuparse.cpp as TYSI, 2-91.
//              0x20-0x80	reserved for expansion of above
#define TYANY	0x1f		// any value ok: 'or' of all of above
//      TYLLI   0x100		not used in cuparse: exman.cpp changes to TYSI.
#define TYNONE  0x200		// no value (start of (sub)expression)
#define TYDONE  0x400		// complete statement: no value on run stack
// CAUTION 0xf000 bits used in cul.h

//-- exman.cpp:exPile data types --
#define TYLLI  0x100		// limited long integer: 16 bit value in 32 bit storage to support nan-flagging
//TYSI   CAUTION  cannot hold nan-flags, use TYLLI (with LI storage!)
//		  everywhere exman's runtime expressions are to be supported
//TYSTR TYID TYFL TYCH TYNC as above
// not used in exman.cpp: TYNUM, TYANY, TYNONE, ? TYDONE.



///////////////////////////////////////////////////////////////////////////////
// UNITS
///////////////////////////////////////////////////////////////////////////////
// units table, subscripted by unit type (units.h, also created by rcdef.exe):
extern int Nunsys;		// number of unit systems (2)
extern int Unsysext;	// current external unit system (internal units are unaffected by units selection)
extern struct UNIT Untab[];
struct UNIT			// one unit type's info in Untab[]
{   struct
    {  const char* un_symbol;	// print symbol "F" "BTU/ft2"
       double un_fact;			// conversion factor
    } unsys[ 2];         		// index is current unit system Unsysext (untab.c)
	static const char* GetSymbol( int iUn, int iUx=Unsysext) { return Untab[ iUn].unsys[ iUx].un_symbol; }
	static double GetFact( int iUn, int iUx=Unsysext) { return Untab[ iUn].unsys[ iUx].un_fact; }
};



/*========== LIMITS: no tables -- implemented in code, e.g. in lib\cvpak.c */



/*========== FIELDS and RECORDs

	Note: fields and records info is in same file, srfd.cpp, to be sure
	matching field type indeces are used: field type indeces, used only
	to access field types table from fields-in-record table, are not
	necessarily invariant amoung products: #if-ing-out field types
	anywhere in fields.def is expected.  (But a record/field description,
	if present in srfd.c, should be valid for that RT in any product). */


//--- Field types table: srfd.c:sFdtab[]

struct SFDTAB	// struct of one field's info in sFdtab[]
{   USI dtype;		// data type, DTXXXX define, Dttab[] index + bits.
    UCH lmtype;		// limit type or LMNONE, LMXXXX define
    UCH untype;		// units type or UNNONE, UNXXXX define, Untab[] index.
};
extern SFDTAB sFdtab[];			// array of SFDTAB, indexed by field type # in fields-in-record tables

//#define FDNONE 0	define if desired.	// 0 is not a valid field type #.


/*--- Small Fields-in-Records Tables (srfd.c):
	Each gives info on fields in one record type.
	Indexed by field number (RECNAME_FIELDNAME define in rcxxxx.h file).
	Accessed pointer in basAnc or (obsolescent) via RT's entry in small record descriptor, below. */
struct SFIR
{
    UCH ff;		// field flags (attributes): define(s) below: FFHIDE, FFBASE. 2 bits used 6-95.
    UCH fdTy;		// field type: sFdtab index. 7 bits used, almost 8, 6-95, expand using ff bits when need found.
    USI evf;		// field variation (by program, see cncult.c for input variability) (EVF___ defines, cuevf.h). 9 bits 6-95.
    USI off;		// member offset in rec. 14 bits needed 6-95.
    char* mName;	// record struct MEMBER name.  for arrays & nested structs, contains composite with .'s and/or [n]'s.

	int sfi_GetDT() const { return sFdtab[fdTy].dtype; }
};
  //--- Historical macro to point to member name in SFIRstr s
 #define MNAME(s) ((s)->mName)


/*--- Field Flag bits, for SFIR.ff */
#define FFHIDE   1	// hide field: omit field from probe info report (CSE -p)
#define FFBASE   2	// field of C++ base class specified via *BASECLASS in records definition file, 7-1-92.


/*----- re Record Types
        Hi bits are attributes; lo are type #
	Individual record types are defined in rctypes.h and are used in .rt, the 1st member of all record structures. */
#define RTBRAT   0x2000   /* "Record Array Table" type: has array of record structure in a DM block.  See ancrec.h, .cpp.
			     also defined in ancrec.h, MUST MATCH!. */
#define RTBHIDE  0x4000	  // hide record: omit entire record from probe info report (CSE -p)
#ifdef wanted	// define here if desired to test outside of rcdef.exe (rcdef defines internally ifndef, 12-91.)
w #define RTBSUB   0x8000   /* Substructure type definition, only for nesting in other record types
 			       or direct use in C code: Lacks record front info and stat bytes. 3-90.
			       rcdef.exe sets this bit for internal reasons, and leaves it set. */
#endif
#define RCTMASK  0x03FF 	// bit-remove mask for SRDstr.rt: yields record type
#ifndef GLOB			// defined in cnglob.h due to frequent use
  typedef USI RCT;		// record type type
#endif


/*--- Small Record Descriptor Table (srfd.c:sRd)
	This table gives information about each record type; it is accessed by searching for the record type. */
struct SRD  	// one RT's info in Srd[]
{   RCT rt;  		// record type plus bits (defined just above)
    SI nFlds;		// number of fields (excluding start-record overhead)
    SFIR * fir; 	// local ptr to array of info about fields in record: offset, name, type (sFdtab index), etc.
};
extern SRD sRd[];	/* null-terminated array of SRD, generated by rcdef.exe.
			   Includes pointers to arrays of SFIR for fields of each record. */
// note 12-12-91: sRd not referenced -- could be deleted.

struct VALNDT
{
	void* vt_val;
	USI vt_ty;

	VALNDT() : vt_ty(0), vt_val(nullptr) {}
	~VALNDT()
	{
		vt_ReleaseIfString();
	}

	bool vt_IsString() const
	{	// return true iff vt_ty is CULSTR
		bool isString = vt_ty == TYSTR || vt_ty == TYID || vt_ty == DTCULSTR;
#if defined( DEBUG)
		if (!isString && vt_ty != 0 && vt_ty != TYFL)
			printf("\nvt_IsString: unexpected vt_ty=%d  vt_val=%x", vt_ty, (unsigned int)(vt_val));
#endif
		return isString;
	}
	bool vt_IsNANDLE() const { return ISNANDLE(vt_val); }
	void vt_ReleaseIfString();
	void vt_FixAfterCopyIfString();
};

#endif 	// ifndef SRD_H at start file
// end of srd.h
