// Copyright (c) 1997-2019 The CSE Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file.

/* srd.h: definitions for "small record (& field, etc) descriptors":
	  data and record definition info generated as C source code by rcdef.exe,
	  for compilation and linking into programs, rcdef-generated source files:

	      dttab.c: data types table
		  untab.c: units table
	      srfd.c:  field types table, fields-of-records tables, small record descriptor table.

	  comments written early in development 1-30-91; may be obsolete */


//=============== DATA TYPES: dttab.cpp


//--- Data type word: DTxxx define in dtypes.h, generated by rcdef from cndtypes.def.
//    Hi bits are attributes, lo bits index (subscript) into Dttab.
#define DTBCHOICN 0x4000	// float number-or-choice data type: choice values (hi word)(nans) are 7f81, 7f82, ...
#define DTBCHOICB 0x2000	// "improved" simplified hsu/cnr choice data type: Internal values are 1, 2, 3...
//      DTBCHOICA 		former TK/CR choices not supported in CSE, 9-91.
#define DTBMASK   0x1fff	// mask for lo bits that index into Dttab[] to get size & choice info.  See rcdef.c.


//--- Data type table

// data type table globals - but access using GetDttab(), below
extern LI Dttab[];   	// dttab.cpp, generated by rcdef.exe
extern USI Dttmax;		//   size (in LI's) of Dttab

// structure for accessing data type table entry
//			(Dttab may be constructed by rcdef.exe as array of LI, with subscript dt & DTBMASK,
//                      size in loword, # choices in hiword, char * choice text ptrs following.)
struct DTTAB
{   // next two correspond to LOWORD and HIWORD, respectively, of LI Dttab[masked dt]
     SI size;        	// storage size of choice data type (2)
     SI nchoices;    	// # choices (incl hidden choices) <-- 0 (HIWORD) in non-choice type, cd use as choice type indicator.
    // next member corresponds to Dttab[dt+1...]
     char* choicbs[1];	// array of text pointers (compiled/linked Dttab) for texts of choices 1,2,3 ... .
						// Texts of hidden choices start with '*'.
};

//- function for accessing data type table entry: .size, .nchoices, .choicbs[0..].
inline DTTAB& GetDttab(USI dt) { return *(DTTAB *)(Dttab+((dt)&DTBMASK)); }

//- function for accessing text for a choice. for choicn 'chan' is CHN(value). CHN, NCNAN: cnglob.h.
//   but, to access with checks, use ::getChoiTx( dt, chan).
inline const char* GetChoiceText( USI dt, USI chan) { return GetDttab(dt).choicbs[(chan & ~NCNAN) - 1]; }


///////////////////////////////////////////////////////////////////////////////
// UNITS
///////////////////////////////////////////////////////////////////////////////
// units table, subscripted by unit type (units.h, also created by rcdef.exe):
extern int Nunsys;		// number of unit systems (2)
extern int Unsysext;	// current external unit system (internal units are unaffected by units selection)
extern struct UNIT Untab[];
struct UNIT			// one unit type's info in Untab[]
{   struct
    {  const char* un_symbol;	// print symbol "F" "BTU/ft2"
       double un_fact;			// conversion factor
    } unsys[ 2];         		// index is current unit system Unsysext (untab.c)
	static const char* GetSymbol( int iUn, int iUx=Unsysext) { return Untab[ iUn].unsys[ iUx].un_symbol; }
	static double GetFact( int iUn, int iUx=Unsysext) { return Untab[ iUn].unsys[ iUx].un_fact; }
};



/*========== LIMITS: no tables -- implemented in code, e.g. in lib\cvpak.c */



/*========== FIELDS and RECORDs

	Note: fields and records info is in same file, srfd.cpp, to be sure
	matching field type indeces are used: field type indeces, used only
	to access field types table from fields-in-record table, are not
	necessarily invariant amoung products: #if-ing-out field types
	anywhere in fields.def is expected.  (But a record/field description,
	if present in srfd.c, should be valid for that RT in any product). */


//--- Field types table: srfd.c:sFdtab[]

struct SFDTAB	// struct of one field's info in sFdtab[]
{   USI dtype;		// data type, DTXXXX define, Dttab[] index + bits.
    UCH lmtype;		// limit type or LMNONE, LMXXXX define
    UCH untype;		// units type or UNNONE, UNXXXX define, Untab[] index.
};
extern SFDTAB sFdtab[];			// array of SFDTAB, indexed by field type # in fields-in-record tables

//#define FDNONE 0	define if desired.	// 0 is not a valid field type #.


/*--- Small Fields-in-Records Tables (srfd.c):
	Each gives info on fields in one record type.
	Indexed by field number (RECNAME_FIELDNAME define in rcxxxx.h file).
	Accessed pointer in basAnc or (obsolescent) via RT's entry in small record descriptor, below. */
struct SFIR
{
    UCH ff;		// field flags (attributes): define(s) below: FFHIDE, FFBASE. 2 bits used 6-95.
    UCH fdTy;		// field type: sFdtab index. 7 bits used, almost 8, 6-95, expand using ff bits when need found.
    USI evf;		// field variation (by program, see cncult.c for input variability) (EVF___ defines, cuevf.h). 9 bits 6-95.
    USI off;		// member offset in rec. 14 bits needed 6-95.
    char* mName;	// record struct MEMBER name.  for arrays & nested structs, contains composite with .'s and/or [n]'s.
};
  //--- Historical macro to point to member name in SFIRstr s
 #define MNAME(s) ((s)->mName)


/*--- Field Flag bits, for SFIR.ff */
#define FFHIDE   1	// hide field: omit field from probe info report (CSE -p)
#define FFBASE   2	// field of C++ base class specified via *BASECLASS in records definition file, 7-1-92.


/*----- re Record Types
        Hi bits are attributes; lo are type #
	Individual record types are defined in rctypes.h and are used in .rt, the 1st member of all record structures. */
#define RTBRAT   0x2000   /* "Record Array Table" type: has array of record structure in a DM block.  See ancrec.h, .cpp.
			     ALSO DEFINED IN ANCREC.H, MUST MATCH. */
#define RTBHIDE  0x4000	  // hide record: omit entire record from probe info report (CSE -p)
#ifdef wanted	// define here if desired to test outside of rcdef.exe (rcdef defines internally ifndef, 12-91.)
w #define RTBSUB   0x8000   /* Substructure type definition, only for nesting in other record types
 			       or direct use in C code: Lacks record front info and stat bytes. 3-90.
			       rcdef.exe sets this bit for internal reasons, and leaves it set. */
#endif
#define RCTMASK  0x03FF 	// bit-remove mask for SRDstr.rt: yields record type
#ifndef GLOB			// defined in cnglob.h due to frequent use
  typedef USI RCT;		// record type type
#endif


/*--- Small Record Descriptor Table (srfd.c:sRd)
	This table gives information about each record type; it is accessed by searching for the record type. */
struct SRD  	// one RT's info in Srd[]
{   RCT rt;  		// record type plus bits (defined just above)
    SI nFlds;		// number of fields (excluding start-record overhead)
    SFIR * fir; 	// local ptr to array of info about fields in record: offset, name, type (sFdtab index), etc.
};
extern SRD sRd[];	/* null-terminated array of SRD, generated by rcdef.exe.
			   Includes pointers to arrays of SFIR for fields of each record. */
// note 12-12-91: sRd not referenced -- could be deleted.

// end of srd.h