// Copyright (c) 1997-2019 The CSE Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file.

/* cpgbuild.c -- table-driven function to build and output pgpak pages
		 CSE version derived from ..\lib\pgbuildr.c 8-28-91 */

/* Notes --
    1.  Notation: the term "column" is ambiguous in this context (due to character column vs. table column).
        An attempt is made to refer to character position accross the page as a "colpos" and to table columns as "table columns".

    2.  Limits on tables: 30 table columns (MXTC define below).  Overall colpos width limited by pgpak, 255 I think.
	Max number of heading rows limited by MXHDROWS.

    3.  PAGINATION 10-89, 2-90
	a.  Except for index-driven methods, output is expected to be less than a printer page and print function (pnPrPg)
	    starts a new page when given a pgpak page that would exceed printer page.  Where caller uses multiple calls
	    to build a table of indefinite length, caller must handle pagination with calls to cpnat.c.

	b.  Index-driven methods PBTABLE and PBFILLREC can produce output of indefinite length.  Pgbuildr paginates
	    this output as generated, using pnPgIf(), which may print part of the output and/or start new print pages,
	    EVEN IF printout not specified via PBSPECOUT (or PBDONE).  (We may need to add a way to suppress pagination 2-90).
	    i)  PBTABLE: when continued on new page, column heads are repeated and " continued" is
	        appended to the caller's title if one was given in the pgbuildr call.
	    ii) PBFILLREC: when continued on a new page, ??? anything that was already in the pgpak page
	        (per PGCUR row) is repeated on the new page.
	        No continued indicator is generated !??? -- probably ok if used only for numbered notes.
	    PBHEAD .val3 may be used specify pagination allowing for extra lines at bottom of page, to allow for following
	    non-index (thus pagination-dumb) method in same pgbuildr call, such as the rule below the cr remarks.

    4.  OUTPUT 2-90
        Output done in pgbuildr is thru the set of functions in cpnat.c.
        Caller is assumed to have opened printer (cprint.c).
        Caller may preset page header for printer continuation pages with cpnat:pnSetHeader.  Page length is determined
        in cpnat.  Pgbuildr outputs when specified with PBSPECOUT/PBDONE, and also (for pagination purposes) as rows
        are generated by multi-record methods PBTABLE/PBFILLREC (do we need an option to suppress?).
	For other methods, caller may do all output.

  Incomplete areas:
    1.  pbTabHdCol() probably does not handle PGCNTR well enough.
        Work on if need found.  10-16-88. */


/*------------------------------- INCLUDES --------------------------------*/
#include <CNGLOB.H>	// global defines, typedefs, options

#include <PGPAK.H>	// pgw pnPrIf pnPrPg
#include <CVPAK.H>	// cvfddisp()

#include <CPGBUILD.H>	// typedefs and declarations for this file


/*---------------------- LOCAL DEFINES and TYPEDEFS -----------------------*/

/* macro to add offset to absolute rows only (PGCUR is already offset) */
#define ROWOFF(row)  ((row) > PGCURMIN ? (row) : (row) + pbROff)	// PGCURMIN: pgpak.h

/*---------------------------- LOCAL VARIABLES ----------------------------*/

/* used-by lists not checked when 2-90 changes done.*/

/*--- arguments to pgbuildr, for access by internal fcns w/o arg passing ---*/
LOCAL char ** NEAR pbPpp= NULL;	/* ptr to caller's or internal pgpak page ptr,
				   used by pgbuildr, pbIdxMth, pbTabHd, pbTabDat, pbFillDat, pbFillEst pbPgIf */
LOCAL char * NEAR pbPp = NULL;	// internal pgpak ptr for use (via pbPpp) when caller supplies NULL ppp. 2-90.
LOCAL SI NEAR pbROff = 0;	// row offset: moves table down.  pgbuildr, pbIdxMth, pbIdxL, pbPgIf

/*----- other variables shared amoung pgbuildr internal fcns -----*/
LOCAL PBHEAD * NEAR pbHd = NULL;	/* curr pgbuildr var arg: spec fcn, or ptr to PBHEAD.
					   PBHEAD has method, methtab ptr, addl info eg data source, col, hd row, etc.
					   Set in pgbuildr, used in pbIdxMth, pbTabHd, pbIdxL, pbTabDat, pbFillDat, pbFillEst */

/*----------------------- LOCAL FUNCTION DECLARATIONS ---------------------*/
LOCAL void NEAR pbLabel( SI pgfmt, SI row, SI col, SI wid, char *label);

//=========================================================================
void CDEC pgbuildr(
	/* declared new way for passing FLOATs 2-90. DOES *NOT* WORK: MSC 5.1 passes floats in variable arg list double. */

	// Add text to a pgpak page per tables; optionally allocs, outputs (via cpnat.c), frees.

	char **ppp,	/* NULL to use internal page ptr (2-90), or ptr to page ptr (may be updated on return).
		   CAUTION: if ptr ptr given but page is alloc here (row nz), ptr must contain NULL or valid, freeable DM ptr. */
	RC *prc,	/* If *prc is not RCOK, pgbuildr() does *NOTHING*;
		   otherwise outcome of this operation is returned in *prc (non-RCOK if console interrupt, printer error, etc). */
	SI rows, 	/* Size of page to alloc, or row 0 if *ppp already alloc'd. */
	SI cols,	/* .. */
	SI rOff,	/* Row offset for *ALL* rows specified in all actions in this call: shifts display down w/o changing
		   many table entries.  Typical use: make blank space above title (idx'd methods).
		   [ CAUTION: avoid both nz rOff and > 1 PGCUR in table rows.  fixing this bug 2-90.] */
	char *title,	/* NULL or Title to appear PGLJ at position (1+rOff,1).
		   " continued" is appended if table head repeated on continuation print page.
		   Allow for row used by title in PBHEAD.val2 with PBTABLE, PBFILLREC. */

	... )		/* Variable argument list follows;  Arg groups executed in sequence;
		   Each group begins with a 4 byte object which is either

		     NULL: argument is skipped;

		     OR  A special function flag:
			  PBSPECOUT	Print (calls cpnat:pnPrPg).  (Also PBTABLE and PBFILLREC may output
			  		automatically if page break encountered.)
			  		Caller should preset page header with cpnat.c:pnSetHeader().
			  PBSPECFBOX	Display page into current feedback box.  (Csc.cwxxx must be set up (sch.c) )
			  PBSPECFR	Free page
			  PBSPECEND	Terminator; this is the last arg.
		      These functions can be combined bit-wise: OUT + FR + END outputs, frees, and stops.
		      (Note PBDONE is defined as those 3.)

		    OR  A pointer to a PBHEAD structure which specifies a formatting method and points to a method table
		      which controls data addition.  In some cases, additional args follow (?? add new methods here):
			  Method		  Additional args
			PBTEXT       		(none)
			PBRECORD, PBTEXTREC	DBP rp	data source record CSE: not functional 9-19-91
			PBTABLE, PBFILLREC	1 or 2 index names or 1 RATBASE ptr, per PBHEAD.val1
		      Furthermore, some methods support "magic values" which cause additional pointers (PBARGP)
		      or field #'s (PBARGSI) or data (PBARGDAT, PBDATA[L] method only, floats are doubled)
		      to be fetched from arg list for use in place of values coded into method table. */

// *prc remains RCOK if allocation, addition, and output completed ok; else nz.  Errors have been reported (using WRN).
{
	va_list argp;   // Working pointer for variable args
	USI meth;
	SI keepgoing;
	RC rc;
	char *rp = nullptr;
	char *tp;
	/* Size table -- !! MUST match PBxxxx method type defns in cpgbuild.c.  Used to increment pointer through method driver tables.
	   Currently not used by methods involving PBM_IDX (such as PB_TABCOL and PB_FILLREC), but they are in table anyway */
	static char sizetab[] = {
		sizeof(PB_TEXT),    0,
		0,			sizeof(PB_RULE),
		0,			0,
		sizeof(PB_TEXT),    sizeof(PB_DATA),
		sizeof(PB_DATAL),   0,
		sizeof(PB_TEXTL),	sizeof(PB_DATOFF),
		sizeof(PB_DATOFFL),
	};

	/* Don't do anything if there is already an error posted */
	if (*prc != RCOK)
		return;

	/* Initialize */
	va_start( argp, title);

	/* some arguments to file-globals for use by internal subfunctions */
	/* used-by lists need review, 2-90. */
	pbPpp = ppp ? ppp : (char **)&pbPp;		/* ptr to caller's else internal page ptr, used here & in pbIdxMth,
						   pbTabHd,pbTabDat,pbFillDat,?pbPgIf*/
	pbROff = rOff;				/* row offset (moves entire table down) (ROWOFF macro).
						   pgbuildr, pbIdxMth, pbTabHd, pbIdxL, ?pbPgIf */

	/* Allocate page if required */
	if (rows > 0)
		if ( (*prc = pnAlloc( pbPpp, rows, cols, WRN ) ) != RCOK )	// pgalloc and init cpnat stuff re title, # head rows, &c.
			return;							// .. cpnat.c.

	/* Row offset: advance pgpak current row ONCE, NOW.
	   Hereafter add offset only to absolute rows (via ROWOFF macro) -- else non-0 rOff increases spacing of PGCUR-relative rows */
	pgw( pbPpp, 0, PGCUR+pbROff, PGCUR, "");				/* display "" to move crsr */

	/* Output title */
	if (title != NULL)				// if title given
		pnTitle( pbPpp, 1 + pbROff, 1, title);	// pgw & save info for adding "continued" if go onto another print page. cpnat.c.

	/* Loop over arguments */

	keepgoing = TRUE;     		/* Loop termination flag, tested at end of loop */
	do
	{
		rc = RCOK;				/* no error yet this arg */
		pbHd = va_arg( argp, PBHEAD *);		/* Ptr to PBHEAD, or spec fcn. file-global used by callees. */
		if (pbHd==NULL)
			continue;				/* skip NULL args */

		/* Special function arguments */

		if ((LI)pbHd >= 0L && (LI)pbHd < PBSPECMAX)	/* special functions are small (defns in pgbuildr.h) */
		{
			/* Special functions are bits, done in order so OUT + FR + END can be combined (PBDONE define). */

			/* print page (unprinted portion, for PGTABLE and PBFILLREC) */

			if ((LI)pbHd & PBSPECOUT)
				if (*prc == RCOK)					/* if no error yet (redundant) */
				{
					/* printf( "pgbuildr calling pnPrPg .. ");	* temp 7-4-90 */
					pnPrPg( pbPpp, 0); 				/* print (remainder of) PAGE. cpnat.c*/
					/* printf( " .. returned\r\n");			* temp 7-4-90 */
				}

			/* Free page special function bit */
			if ((LI)pbHd & PBSPECFR)
				pnFree(pbPpp);		/* free page, null ptr, clear cpnat info re title & header, NULL *pbPpp. cpnat.c. */

			/* End of argument list special function bit */
			keepgoing = ! ((LI)pbHd & PBSPECEND); 		/* Clear flag tested at bottom of loop */
		}
		else			/* not spec fcn ---> it is a pointer to PBHEAD */

			/* Other arguments: output per method */

		{
			meth = (pbHd->methopt) & PBMTHMASK;		/* Formatting method */
			tp = (char *)pbHd->methtab;			/* method table pointer, actual type depends on meth. */
			if (meth & PBM_RP)				/* method bit says rp arg follows */
				rp = va_arg(argp, char *);			/* Pick up record pointer */
			/* pbIdxMth() and its callees also picks up additional arguments */

			/* Non-index methods: loop over method table entries */

			{
				/* .val2 is user's # table header rows ... */

				if (pbHd->val2 != 0)			/* 0 means no change */
					pnSetTh( ROWOFF(pbHd->val2));	/* ROWOFF: add pbROff if row not PGCUR-rel */
				/* pnSetTh (cpnat.c): say repeat # rows of (user's) text at top of PAGE
				   if a new print page is begun (by cpnat.c per caller pnPgIf call;
				   pgbuildr itself does not paginate non-multi-record methods). */
				/* METHOD TABLE ENTRIES LOOP HEAD */

				while ( ((PB_TEXT *)tp)->pgfmt != PBMETHEND )
				{
					SI wid = 0;
					SI units, cvfmt;
					SI off;
					USI dt;
					char *p;

					/* prefetch .pgfmt,.row,.col for cases where struct matches PBTEXT (all cases except those without .col, 2-90) */
					SI pgfmt = ((PB_TEXT *)tp)->pgfmt | PGGROW;	/* pgpak format. PGGROW: say enlarge page if necess */
					SI row = ROWOFF( ((PB_TEXT *)tp)->row);		/* ROWOFF: adds pbROff if not PGCUR-relative */
					SI col = ((PB_TEXT *)tp)->col;

					/* more common init */
					char* label = 0;		// default no label: for shared case code
					char* s = "";			/* no converted data, for PBOMITx cases */

					/* METHOD SWITCH */

					switch (meth)
					{
						/* TEXT -- row/col and text are all taken from method table */
					case PBTEXTL:				/* .. with labels */
						label = ((PB_TEXTL *)tp)->label;
						/*lint -e616  intentionall fallin */
					case PBTEXT:
						if (pgfmt & PBFILL)			/* on format option do a "fill" */
							goto filltext;			/* instead. NB 1st 4 str mbrs match.*/
						s = ((PB_TEXT *)tp)->text;	/* pointer to text */
						if (s==PBARGP)				/* special value says */
							s= va_arg( argp, char *);		/* ... get text ptr from pgbuildr arg list */
						if (s==PBOMITP)			/* for display-nothing value */
						{
							s = "";				/* move cursor anyway */
							label = 0;			/* suppress label if any */
						}
						goto labNdat;			/* join PBDATA to do label & data */

						/* DATOFF -- data by offset in record/structure */
					case PBDATOFFL:
						label = ((PB_DATOFFL *)tp)->label;
						/*lint -e616  intentionall fallin */
					case PBDATOFF:
						off = ((PB_DATOFF *)tp)->off;	/* fetch mbr offset */
						if (off==PBARGSI)				/* val says get PTR */
							p = va_arg( argp, char *);	/* .. from arg list */
						else if (off==PBOMITSI)			/* value says omit this one */
							p = (char *)PBOMITP;
						else							/* else data is at ... */
							p = (char *)rp + off;		/* record location + offset */
						if (pgfmt & PBFILL)				/* on format option do a "fill" */
						{
							s = p;						/* instead. data must be text. */
							goto filltext1;				/* NB 1st 3 str mbrs match.*/
						}
						dt = ((PB_DATOFF *)tp)->dt;		/* get data type */
						units = ((PB_DATOFF *)tp)->units;	/* get units */
						wid = ((PB_DATOFF *)tp)->wid;  	/* get convert wid */
						cvfmt = ((PB_DATOFF *)tp)->cvfmt;	/* get cvpak fmt */
						goto offJoin;			/* join DATA/DATL */

						/* DATA -- row/col and data pointer from table */
					case PBDATAL:		/* .. with label texts left of data */
						label = ((PB_DATAL *)tp)->label;
						/*lint -e616  intentionall fallin */
					case PBDATA:
						if (pgfmt & PBFILL)			/* on format option do a "fill" */
							goto filltext;			/* instead. NB 1st 4 str mbrs match.*/
						p = (char *)((PB_DATA *)tp)->pdata;	/* pointer to data */
						if (p==PBARGP)			/* special value says */
							p= va_arg( argp, char *);		/* get data pointer from  pgbuildr arg list */
						dt = ((PB_DATA *)tp)->dt;		/* get data type */
						units = ((PB_DATA *)tp)->units;	/* get units */
						wid = ((PB_DATA *)tp)->wid;		/* get convert wid */
						cvfmt = ((PB_DATA *)tp)->cvfmt;	/* get cvpak fmt */
offJoin:			/* PBDATOFF/L join here */
						if (dt==(USI)PBARGSI)		/* on special value get dt */
							dt = va_arg( argp, USI);		/* ...from pgbuildr arg list*/
						if (p==NULL)				/* for NULL data ptr */
							dt = DTUNDEF;			/* show '?' (historical) */
						/* NB if both in arg list, dt precedes data */

						if (units==PBARGSI)			/* spec value says */
							units = va_arg( argp, SI);	/* get from arg list*/
						if (wid==PBARGSI)			/* spec value says */
							wid = va_arg( argp, SI);		/* get from arg list*/
						if (cvfmt==PBARGSI)			/* spec value says */
							cvfmt = va_arg( argp, SI);	/* get from arg list*/
						if (p==PBOMITP)			/* ptr value omits output & label */
						{
							/* s is "" from above (write anyway for PGCUR) */
							label = 0;			/* suppress label */
						}
						else
							s = cvin2s(   			/* convert to Tmpstr, cvpak.c*/
								p,    			/* pointer to data */
								dt,   			/* data type or DTUNDEF */
								units,			/* Units */
								wid,	   	   	/* width */
								cvfmt );			/* cvpak format */
labNdat:			/* PBTEXT and PBRECORD join here */
						pbLabel( pgfmt, row, col, wid, label);	/* write label, if any, left of data. local. */
						pgw( pbPpp,				/* write to PAGE, pgpak.c */
							pgfmt, 				/*   pgpak format from table | PGGROW */
							row, col,			/*   row and col from table */
							s );				/*   text or data, or "" if PBOMITSI to move "cursor" for PGCUR. */
						break;

						/* FILLTEXT -- row/col and text are all taken from method table */
					case PBFILLTEXT:
filltext:			/* others join here if PBFILL on */
						s = ((PB_TEXT *)tp)->text;		/* pointer to text */
filltext1:			/* PBDATOFF/L join here for PBFILL */
						if (s==PBARGP)			/* special value says */
							s= va_arg( argp, char *);		/* ... get text pointer from pgbuildr arg list */
						if (s==PBOMITP)			/* special value says "omit": */
							s = "";				/* write "" to update PGCUR (from PBDATA, can't pass "" easily) */
						else 				/* PBOMITP also suppresses label */
							pbLabel( 0, row, col, 0, label);	/* write label, if any, left of data*/
						/* pgfmt==PGRJ not supported here (bit has other use with pgfille) */
						rc = pgfille( 			/* write to "page" with wrap, pgpak.c*/
							pbPpp,
							pgfmt, row, col,
							s,
							WRN );
						break;

						/* Rule -- draw lines etc. at specified row/col */
					case PBRULE:
						pgwrep( pbPpp,   			/* pgpak.c */
						pgfmt, row, col,
						((PB_RULE *)tp)->text,
						((PB_RULE *)tp)->length );
						break;

					default:
						err( PWRN,				// display internal error msg, await keypress, rmkerr.c
							"pgbuildr: bad method" );	//   no need for MH_xxxx -- this fcn soon obsolete 10-29-91
							return;           			// leave loop after programming error to prevent inf. loop.
						/*lint -e616 */
					};        /* method switch */

					tp += sizetab[meth&PBNOACTMASK];	/* Advance table pointer by "sizeof" bytes */

				}  /* while (tp ... ) */
			}  /* if (indexed method) ... else ... */
		}  /* If (special) ... else ... */

		/* Done with current arg.  NB all cases incl end arg list get here. */
		if (*prc == RCOK)			/* in *prc return 1st error encountered */
			*prc = rc;				/* return RCOK or error from current arg */
	}
	while (keepgoing);      		/* Argument loop */
}                         /* pgbuildr */

//=========================================================================
LOCAL void NEAR pbLabel( SI pgfmt, SI row, SI col, SI wid, char *label)

/* position and write label */

/* for labelled pgbuildr() methods.  preserves PAGE "cursor". */
{
	if (pgfmt & PGRJ)   		/* if given col is data right col, */
		col -= wid-1;			/* adjust to data left col */
	/* PGCNTR not handled.
	   FMTUNITS and FMTPUNIT not adjusted for nor known here (they add columns in excess of 'wid' to formatted data) */
	pgwe( pbPpp,  			/* write text to PAGE w/options, pgpak.c */
	PGRJ | PGGROW,  		/* col is rightmost; ok to realloc if nec */
	row, col-1,    		/* label right col is data left col -1 */
	label,  			/* the text.  NOP if NULL. */
	ABT | PGOPSTAY );		/* PGOPSTAY: restore page's internal "cursor" after writing so caller can reuse row, col
            				   to write data, even if PGCUR-relative, w/o moving down / over from label posn. */
}		/* pbLabel */

// end of cpgbuild.cpp
