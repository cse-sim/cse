// Copyright (c) 1997-2019 The CSE Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file.

/* cnrecs.def -- record definitions for CSE
                 derived from records.def and rchs.def, 8-30-91

	// search MOVE every time all rccn.h-includers are to be recompiled.
	// search #if for cleanup


  !! COMMENTS MAY BE OBSOLETE !! due to CSE split-off 9-1-91,
                                 RATS-->basAnc transition 2-92, etc.

	This file is an input file for the record definer RCDEF.EXE,
	named on the rcdef command line, argument 5.

    The information is used to produce (output file names are rcdef.exe args):
	rctypes.h (#defines of record types and update classes);
        srfd.cpp Record and Field Descriptor Tables source file
        rccn.h (as named in *file statement herein)
*/

/* General notes

    This file defines RECORDS: C++ class definitions, and associated
    tabulated attributes.

    RECORDs must have unique names and a text description.

        The type name is a C indentifier used in forming type and field
	symbols.

	The description is put in basAnc.what and is used in user probes and
	in error messages.  It can optionally be overridden in each instance
	of the basAnc.


    All FIELDs must be defined in fields.def.

    COMMENT delimiters MUST have whitespace around them.

    A few records here are *SUBSTRUCTS, for embedding in other records.

    Most record types here are *RAT records, for use with a record base/anchor
    (C++ class "basAnc").  RAT stands for Record Array Table.

    A basAnc is a small, usually static object containing some fixed info
    and a pointer .p to an ARRAY of records in a single heap block.
    All records in a given basAnc's block are of the same type, and there is
    a specific basAnc class for each record type.

    For record type T in this file, record derived class definition T and
    basAnc derived class definition anc<T> are output in an .h file.
    These work with the base class definitions in h\ancrec.h and the member
    function bodies mostly in lib\ancrec.cpp.
    Each record starts with certain fields (defined in the base class),
    including the record type, the name, and a "good" flag.

    Records in a basAnc's block are accessed by number (subscript), or can
    be found by name (slower).  When one record refers to another, the
    reference is input by name but resolved to a subscript (TI) before the
    run begins.  Except for single-static-record basAncs (eg Top), record 0
    of each basAnc's block is unused and all 0; it thus can "ground"
    references from unset subscript variables.

    Also output are #defines for field numbers, number of fields, etc
    (in the same .h file(s), as named in *file statements here);
    a .h file of record type defines; and a .C source file (srfd.cpp, named
    on rcdef.exe command line) for tables of information about the record
    types and the fields in each record (FIR tables).  The latter are used
    by the application in conjunction with field and data type info tables,
    also put out by rcdef.exe.

DEPENDENCY CHECKLIST ... what to do when you change things
    Change of field name ?? update this comment for CSE
    Change record text description ?? update for CSE
    Adding / deleting fields in records ?? update for CSE

RECORD * directives are
   *RAT 	define record type for a record array table (now all but *SUBSTRUCTs)
   *SUBSTRUCT   define sub-structure type for *NESTing or for struct use in C code
   *baseclass <name>	base class (substructs only, 7-92)
   *hideall	omit entire record from probe names help report (CSE -p)
   *excon	external explicit constructor (declare only in generated class defn)
   *exdes	ditto destructor
   *ovrcopy Copy() member is overriden (else calls record::Copy())

FIELD * directives are
   *hide	omit this field from probe names help report (CSE -p)
   *array <n>	array of whatever field spec follows
   *noname	before *nest: omit structure name from SFIR table names (for probe).  C code still uses .struct.mbr.
   *nest <rec>	nest another record type in this one, as a C structure within record structure
   *struct	embed a structure, unused for years
   *declare "text"	put text into record definition; use eg for C++ member function declarations.
   *s *h *mh *d *m	field variability (when changed by program): subhour, hour, monthly-hourly, daily, monthly
   *r 			runly (start of run) variability, incl things set by input check/setup (topCkf)
   *y 			same as *r; by convention, *y *e used for run-end results
   *e			with above, field varies at end of interval, not start (results)
   *p			with above, field varies at post-calc stage, not start (intermediate results)
   *f			value available after input, b4 setup; may also change just b4 re-setup for main run after autosize. 6-95.
   *i			value available after input, before checking/setup: rat ref subscrs, resolved just b4 topCkf, 1-92
                and anywhere eoi probe ok: any SI/FL/STR with VEOI in CULT, as doct'n aid to say value
                MAY change between input and setup (believe *z works same, at least in cuprobe.cpp, 6-95).
   *z			doct'n aid: indicates no variation, rather than not encoded yet.
   // input TI's (dref's = deferred references, set after all input scanned): use *i.
   // input choice values: can't be set to probe (probing a choice returns TYSI). Does this mean use *z not *i? not doing, 6-95.
   // other user input members of input rats: use *z for 0 evf in cult,  *i for VEOI, *f for VFFAZ (most SI, FL, STR's), etc.
   // derived members of input rats, set during input checking (topCkf): use at least *r.
   // run rat members: *r implicit if nothing given.
*/

/*----------------------------- SUB INCLUDES -------------------------------*/
#include <CNDEFNS.H>	// #defines shared with cse code


/*-------------------------------- OPTIONS ---------------------------------*/
// none

/* ======================================================================== */
*file rccn.h		// all CSE RAT records (multiple-file suport capability not now used)
/* ======================================================================== */


//===========================================================================================================
RECORD TOPRAT "top" *RAT	/* top level RAT: contains control info and all once-only user input stuff,
				   as user language tools (cul.cpp/cncultx.cpp) stuff RATs only.  1 static entry. */
	*prefix tp_
    *exdes	// *declare "~TOPRAT();"		// frees strings.
	*ovrcopy
	*declare "void freeDM();"
	*declare "const char* When( IVLCH ivl) const;"
	*declare "int tp_IsLastStep() const { return isLastDay && isEndDay && isEndHour; }"	// TRUE iff last step of run
	*declare "int tp_IsLastHour() const { return isLastDay && isEndDay; }"
    *declare "RC FC brFileCk();"   			// checks inputs re binary results files.
    *declare "RC tp_CheckOutputFilePath( const char* filePath, const char** pMsg=NULL);"
    *declare "void tp_SetOptions();"
	*declare "RC tp_SetDerived();"
    *declare "RC tp_SetCheckTimeSteps();"
	*declare "RC tp_FazInit();"
    *declare "void tp_ClearAuszFlags();"
    *declare "RC tp_Wfile( int* pHotMo);"
	*declare "RC tp_WthrInit();"
    *declare "RC tp_LocInit();"
    *declare "RC tp_LocDone();"
    *declare "int tp_AuszWthrSource() const;"
    *declare "RC tp_MainSim();"
    *declare "RC tp_MainSimI();"
    *declare "RC tp_SimDay();"
    *declare "RC tp_SimHour();"
    *declare "RC tp_Ausz( int hotMo);"
    *declare "void tp_DoDateDowStuff();"
    *declare "void tp_DTInit();"
    *declare "void tp_DoDTStuff();"
    *declare "void tp_tmrSnapshot();"
    *declare "const char* tp_AuszDoing() const;"
    *declare "RC tp_BegDesDay();"
    *declare "RC tp_EndDesDay();"


//TOP: user inputs (& some derived): overall control
    *i BOO bAutoSizeCmd  	// non-0 if any AUTOSIZE commands seen in input, set via arg to cul() from cse.cpp. 6-95.
    // both FALSE for input check only:
    *r NOYESCH chAutoSize  	// whether to do autosizing, default per bAutoSizeCmd
    *i NOYESCH chSimulate 	// whether to do main simulation, default TRUE, can input FALSE for autosizing only. 6-95.
    //runtime phase: see .autoSizing below.
    *i DOY tp_begDay  		// 1st 1-based Julian day of year of run
    *i DOY tp_endDay   		// last ditto, inclusive
    *r SI nDays				// derived: # days in run
    *i DOWCH jan1DoW		// January 1 day of week, sun=1  SUBTRACT 1 FOR MOST INTERNAL USES
    *r SI year    			// derived: tdpak generic non-leap year, -1 = jan 1 is Monday ... -7 = jan 1 is Sunday.
    *i SI_GEZ wuDays		// number of warmUp days
    *i SI_GZ tp_nSubSteps	    // # subhours per hour, determines subhour duration.
							//    typically 4 for (old) ZNMODELCH_CNE (combined coefficent) models
							//    5 - 30 for convective/radiant models
							//    some models require substep duration to be integral minutes (e.g. HPWH)
							//       see tp_SetCheckTimesteps()

//TOP: inputs: location/air properties/ground properties
    *f CHP tp_wfName    	// weather file path string
	*f CHP tp_TDVfName		// TDV (time dependent value) file path string
    *r LEN elevation		// site elevation (for determining air density) (ft). defaults from weather file 1-95.
    *f TEMP refTemp			// temp for computing the hum ratio (w) used in air-density calculations, default 70 F
    *f FRAC_GZ refRH		// relative humidity (as fraction) ditto, default .6 (60%).

    // ground properties
    *mh FRAC grndRefl		// ground surface reflectivity, re solar gain.
							//    dflt .2. Used: cgsolar.cpp and Kiva. wnGrndRefl Overrides.
    *i FRAC tp_grndEmit		// ground surface emittance, re long wave exchange in Kiva. dflt .8.
    *i FRAC tp_grndRf		// ground surface roughnes, ft, re exterior convection in Kiva. dflt 0.1.
    *i FLOAT_GZ tp_soilDiff	// local soil diffusivity, ft2/hr, re annual deep ground temp cycle estimation
							//    see CalcGroundTemp().  dflt=0.025.
    *i FLOAT_GZ tp_soilCond	// local soil conductivity, Btuh-ft/ft2-F, re Kiva calcs.  dflt=1.0.
    *i FLOAT_GZ tp_soilSpHt	// local soil specific heat, Btu/lb-F, re Kiva calcs.  dflt=0.1.
    *i FLOAT_GZ tp_soilDens	// local soil density, lb/ft3, re Kiva calcs.  dflt=115.
    *i FLOAT_GZ tp_farFieldWidth	// far-field boundary distance, ft, re Kiva calcs.  dflt=130.
    *i DGCH tp_deepGrndCnd	// deep ground boundary type
							//   C_DGCH_WATERTABLE: Water Table
							//   C_DGCH_ZEROFLUX: Zero-Flux (default)
    *i FLOAT_GZ tp_deepGrndDepth	// deep-ground boundary distance, ft, re Kiva calcs.  dflt=130.
    *i FLOAT tp_deepGrndT	// deep-ground boundary temperature, F, re Kiva calcs.  dflt=annual average db.


//TOP: inputs: check tolerances and precisions
    *i FLOAT_GZ tp_tol		// (relative) tolerance used in many hvac calculations, default .001f or as changed
    *i FRAC_GZ  humTolF		// w change to consider as important as 1F temp re convergedness
    *i FLOAT_GZ ebTolMon 	// monthly tolerance
    *i FLOAT_GZ ebTolDay 	// daily ..
    *i FLOAT_GZ ebTolHour	// hourly ..
    *i FLOAT_GZ ebTolSubhr	// subhourly ..
    *r *hide INT tp_ebErrCount	// count of short-interval (day/hour/subhour) overall energy balance errors;
								// s/b 0; re suppression of excessive warnings
    *i FLOAT_GEZ tp_unMetTzTol  // unmet zone air temp tolerance, F (default = 1 F)
    *i FLOAT_GEZ tp_unMetTzTolWarnHrs
                                // unmet warning threshold, hr (default 150)
                                //   Warning(s) issued when zone heating or cooling unmet tzTol hrs exceed threshold

//TOP: inputs: Kiva calculation settings
    *i FLOAT_GZ tp_grndMinDim		// minimum cell dimension in Kiva, ft, default .066f
    *i FLOAT_GZ tp_grndMaxGrthCoeff	// maximum cell growth in Kiva, default 1.5f
    *i TSCH tp_grndTimeStep			// Kiva time step
									//   C_TSCH_H: Hourly (default)
									//   C_TSCH_SH: Sub-hourly


//TOP: inputs: ASHWAT calculation trigger thresholds
							//	 full ASHWAT calcs are performed when *any* of the following changes
							//   by the the trigger amount
							//   else prior results used
	*i FLOAT_GZ tp_AWTrigT;		// inside or outside environmental temperature, F (default = 1)
	*i FLOAT_GZ tp_AWTrigSlr;	// incident solar, fraction (default = .05)
	*i FLOAT_GZ tp_AWTrigH;		// total surface coefficient (conv+rad), fraction (default=.1)

//TOP: inputs: AirNet convergence criteria
								// a zone is deem converged iff
								//  AMFnet <= max( tolAbs, tolRel*AMFTot)
	*i FLOAT_GZ tp_ANTolAbs;	//   absolute tolerance, lbm/sec, dflt=.00125 (about 1 cfm)
	*i FLOAT_GZ tp_ANTolRel;	//   relative tolerance, dflt = .0001

//TOP: inputs: other
    *i ANGLE tp_bldgAzm		// angle to add to all zone/surface azms
    *i SKYMODCH skyModel 	// sky model: C_.._ISO or _ANISO
    *i SKYMODLWCH skyModelLW	// long-wave sky model
	*i EXSHMODELCH tp_exShadeModel;	// exterior shading model (other than overhang/fins)
									//   C_EXSHMODELCH_NONE: none (SHADEX etc ignored)
									//   C_EXSHMODELCH_PENUMBRA: use Penumbra GPU calcs
    *i SLRINTERPMETH tp_slrInterpMeth    // solar interpolation method

    *i HUMTHCH humMeth		// humidity calculation method: Rob (w = wa/wb) or Phil (central difference), 6-92
    *i UH_GZ dflExH			// default ext (air film) cond for os & gz. 2-91
    *i USI workDayMask		// mask with bits set for "work" days, clear for "non-work" days, default Mon..Fri, 5-95.
							// For $isWorkDay, and passed thru binres file to OPK eg for ET.
							//   bits: Sun=1,Mon=2,Tu=4,W=8,Th=16,F=32,Sat=64,holidays=128,
							//      heatDsnDay=256, coolDsnDays=512 (but no autosizing data in bin res file yet 6-95).
							//   CAUTION: hard-coded encoding MATCHES cncult.cpp default, ResfH.workDayMask,
				            //      brfr.h:getWorkDayMask() default, opk\progr.h/cpp:ProGrSub::workDayMask.
    *i NOYESCH DT			// YES (default) to enable daylight saving time
    *r DOY DTBegDay			// Daylight saving start day, 1-365, default 1st Sun (Sun after 1st Sat?) in April
    *r DOY DTEndDay			// Daylight saving end day, 1-365, defaulted by cncult2.cpp code to last Sun in October

							// wind speed adjustment, see cgwthr.cpp
							//    appl sees Top.windF * max( wthrfile.wndSpd, Top.windSpeedMin);
    *i FLOAT_GEZ windSpeedMin	//  minimum, mph (default=.5)
    *i FLOAT_GEZ windF  		//  factor (default=1)
    *i SI tp_terrainClass		// terrain class (1-5) re wind speed adjustment
    *i FLOAT_GEZ radBeamF	// Beam radiation fctr. appl sees ANISO( <fileVal>) * radBeamF. cgwthr.cpp.
    *i FLOAT_GEZ radDiffF	// Diffuse radiation fctr. appl sees ANISO( <fileVal>) * radDiffF.
    *h VENTAVAILVC tp_ventAvail	// all-zone ventilation availability (default=C_VENTAVAILCH_WHOLEHOUSE)
							//   C_VENTAVAILCH_NONE: none
							//   C_VENTAVAILCH_WHOLEHOUSE: airnet windows / fans
							//   C_VENTAVAILCH_ZONAL: airnet windows / fans (controlled by zone)
							//   C_VENTAVAILCH_RSYSOAV: RSYS outside air vent (central mechanical)
	*declare "ULI tp_GetVentAvail() const { return CHN( tp_ventAvail); }"

	*s *e FLOAT tp_fVent	// consensus whole building vent fraction (if not RSYSOAV)
							//     = fraction of full vent flow to use
							//       determined by zone that wants the least vent
							//  or -1 for zonal vent control

    *r NOYESCH tp_hConvMod	// enable/disable convection convective coefficient pressure modification factor (tp_hConvF below)
							//   mostly for debugging.
    *f SI verbose 			// screen messages: autosizing: 0 none, 1 some (dflt?), 2-5 more
							//   -1: suppress progress messages ("Input", "Warmup", etc.) via setScreenQuiet()
    *h LI tp_dbgPrintMask	// debug print mask, controls DbPrintf() etc., schedulable via std capabilities
    *i LI tp_dbgPrintMaskC	// debug print mask constant portion (value known during setup)
    *declare "LI tp_SetDbMask();"	// combine tp_dbgPrintMask and tp_dbgPrintMaskC, call DbSetMask
    *s LI tp_dbgFlag     // debug flag value for passing testing info to code; normally no effect

//TOP: inputs: autoSizing
    *i FRAC_GZ auszTol   	// autosizing result tolerance, dfl .005
    *h TEMP heatDsTDbO		// heat design outdoor temp, dfl per ET1 wthr file hdr.
							//  Impl may be incomplete for non-constant.
    *h TEMP heatDsTWbO		// heating design outdoor wetbulb temp, dfl for 70% RH @ heatDsTDbO.
    *i *ARRAY 13 SI tp_coolDsMo		// SI[13] cooling design month(s) 1-12 + 0 terminator. Default per ET1 wthr file hdr.
    *i *ARRAY 13 DOY tp_coolDsDay	// DOY[13] design day(s) read from weather file + 0 terminator
	*i *ARRAY 13 TI tp_coolDsCond	// TI[ 13] DESCOND idx(s) + 0 terminator

//TOP: inputs: reporting and exporting
	*r CHP tp_exePath		// full path to current .exe
	*r CHP tp_exeInfo		// info about current .exe (from header)
							//   build timestame, linker version, code size
	*r INT tp_exeCodeSize	// code size, bytes (from exe header)
	*r CHP tp_progVersion	// program version identifier as string (for probing); set from ::ProgVersion
	*r CHP tp_HPWHVersion	// Ecotope HPWH (heat pump water heater) model version
	*r CHP tp_cmdLineArgs	// command line args for current input file
							//   updated during session if multiple input files specified on command line
    *i SI runSerial   	// run #, 000-999, per (future 11-91) status file (meanwhile, see cnguts:cnRunSerial 7-92).
    *i CHP runTitle   	// user text for report titles, footers, export title 11-22-91.
    *r CHP runDateTime	// run date & time string, set by cncult2.cpp:topStarPrf2(), used in reports & bin res file, 9-94.
    //inputs for binary results files, for NREL, rob 11-93.  *r cuz settable from cmd line switches.
    *r NOYESCH tp_brs		// YES to generate basic binary results file, default NO. From input file or cmd line switch.
    *r NOYESCH tp_brHrly	// YES to generate hourly binary results file, default NO. From input file or cmd line.
			// brf and brfHrly are intended to be independent, except monthly-hourly averages
    		//  in basic file may only be computed if brfHrly is also on, 11-20-93.
    *i CHP tp_brFileName	// file name for binary results, extension .brs and/or .bhr added. default: input file name.
     // settable in DLL version only, only by command line switches. Default is file output (if brs/brHrly) only.
     *r BOO tp_brMem			// Put binary results in Windows global memory and return handles; do not write file.
     *r BOO tp_brDiscardable	// Put binary results in discardable memory as well as file, return handles. overrides brfMem.

//TOP: inputs: report page formatting 11-91
    *i CHP repHdrL   	// user-spec'd text for left end of report header line
    *i CHP repHdrR   	// .. right
    *i SI repCpl    	// report characters per line
    *i SI repLpp    	// total number of lines per page (paper size)
    *i SI repTopM    	// top margin in lines; # newlines written above header
    *i SI repBotM    	// bottom margin in lines; not actually output
	*i CHP tp_repTestPfx	// prefix pre-pended to e.g. footer lines re hiding lines re automated testing
							//   "" for normal runs, "!" re 3-2010 test framework.  new 3-28-10
	*declare "const char* tp_RepTestPfx() const;"

    // note: for derived # lines per page remaining after margins, hdr, footer, call cncult:getBodyLpp.

//TOP: setup time
	*r *hide BOO tp_bAllCR	// nz iff all zones use convective/radiant model
							// (else all CNE, mix not supported (detected/err'd during setup)

//TOP: setup: exterior (non-overhang/fin) shading
	*r INT tp_exshNShade;		// # of shading surfaces in model
	*r INT tp_exshNRec;			// # of receiving surfaces in model (may also be shading)
	*declare "int tp_ExshCount();"
	*declare "RC tp_ExshRunInit();"
	*declare "RC tp_ExshBegHour();"

//TOP: setup time (derived from inputs b4 run): tolerances
    *r *hide FLOAT relTol	// hvac computation precision relative value tolerance -- input as Tol above
    *r *hide FLOAT relTol1	// slightly larger rel tolerance needed to assure exit from some loops 8-92. set in cncult2.cpp
    *r *hide FLOAT absTol	// hvac computation precision absolute value tolerance -- e.g. 100*relTol. set in cncult2.cpp.
    *r *hide FLOAT absHumTol	// Top.AbsTol * Top.humTolF: smaller absolute tolerance for humidity ratios. set in cncult2.cpp.
    *r *hide FLOAT hiTol	// 1. + relTol, ie 1.001 if Tol is .001; saves arithmetic during run.
    *r *hide FLOAT loTol	// 1. - relTol

 //TOP: setup: location info from weather file. Uses include solar calculations. 1-95.
    *r float latitude	// degrees north
    *r float longitude	// degress west
    *r float timeZone	// hours west (fraction ok)
    // also elevation is above (user-inputtable).

 //TOP: setup: air properties approximated @elevation, refTemp, refRH, set in cucult2:topPsychro().
    // UNITS/FIELDS needed for floats for proper probe behavior ***
    *declare "RC tp_Psychro();"
    *r float tp_presAtm		// nominal atmospheric pressure at Top.elevation (in Hg)
							//   (constant for simulation)
    *r HUMRAT_GZ tp_refW	// humidity ratio for refTemp, refRH (ratio)
							//   psyHumRat2( Top.refTemp, Top.refRH) dfl ~.0066
	*r DBL tp_refWX			// 1/(1.+rp_refW)
    *r SPECHEAT tp_airSH	// air specific heat (Btu/lbDryAir-F) @ tp_refW
							//   .240 + .444*tp_refW   dfl ~.24293
    *r float airVK			// specific volume per temp(ft3/lb-F): multiply by abs temp.
							//   PsyRAir*(1.f+tp_refW/PsyMwRatio)/PsyPBar;  dfl ~.02547
    *r float airRhoK		// density*temp (lb-F/ft3): divide by abs temp to get density.
							//   1/airVK.  dfl ~39.25
    *r float airVshK		// volumetric specific heat/temp (Btu/ft3-F): div by abs temp for heat capacity per ft3
							//   airRhoK*tp_airSH  dfl ~9.535  NEEDS UNITS
    *r float airXK			// divide by abs temp for specific heat of flow (Btuh/cfm-F)
							//   airVshK, times 60 to match time units. dfl ~572.1
	*r float tp_hConvF		// convective coefficient pressure modification factor
							//   =(.24 + .76*PresAtm/PresAtmSeaLevel)
							//   used in some surface transfer models, reduces convection as function of elevation
							//   source = ASHRAE 1199-RP Barnaby et al. 2004
    // and: enthalpy/lb is airSh * absTemp + 1061 * w.  (Btu/lb)

    // air property uses:
    *declare "float airDens( float t) { return airRhoK / ( t + 459.67f); }	// air density for temp  lb/ft3"
    *declare "float airSpv( float t)  { return airVK * (t + 459.67f); }		// air specific volume (1/density) ft3/lb"
    //*declare "float airVsh( float t)  { return airVshK / (t + 459.67f); }	// vol spc ht (Btu/ft3-F) for temp, typ .018 @70F"
    *declare "float airX( float t)    { return airXK / (t + 459.67f); }		// air flow heat transfer (Btuh/cfm-F): vsh * 60"
    //*declare "float enthalpy( float t, float w) { return tp_airSH * t + 1061.f * w; }	// enthalpy (Btu/lb) @ SH of refW"

//TOP: setup time: autosizing
    *r INT tp_nDesDays  	// number of design days: 1 for heating + number of non-0 coolDsMo's.
    *r FLOAT_GZ auszSmTol   // autosizing small tolerance, eg auszTol/10 (.001)
    *r FLOAT_GZ auszTol2	// half of given tolerance -- added to values; used in convergence tests.
    *r FLOAT_GZ auszHiTol2	// 1 + half of tolerance, eg 1 + auszTol/2.

//TOP: setup time: reports info for this run
    *r INT vrSum		// vrh for Summary report (not written to as of 11/22/91)
    // int VrErr		vrh for ERR report... is not in Top... must be open for messages during Top init.
    // int VrLog		vrh for LOG report... ditto. open in case want to write to it during input.
    // int VrInp		vrh for INPut listing report ... ditto, is being written during input and thus Top init.

//TOP: runtime: reports info for this run
    /* Date-dependent report/exports, including all zone-specific reports, etc:  ZEB, ZST, MTR, etc:
       cncult4.cpp makes DVRI record for each requested such report and generates unspool requests for it;
       cgresult.cpp generates text to active reports each interval using the following lists it generates daily: */
    // Reports/exports active today, ordered for subscripting by IVLCH-1, heads of .nextNow lists in DvrIB (next 6 items):
      *d TI dvriY   	  // 0 or DvriB subscript of 1st rpFreq=YEAR report or export
      *d TI dvriM   	  // .. MONTH report/export currently active
      *d TI dvriD   	  // .. DAY report/export to write to today
      *d TI dvriH   	  // .. Hourly ..   
      *d TI dvriS   	  // .. Subhourly ..
	  *d TI dvriHS   	  // .. Hourly and Subhourly.  A vr can only be in one list, so this list is
       					  //    checked at hourly and subhourly intervals in addition to -H or -S. */
    *d SI hrxFlg    	// nz if any hour reporting or exporting today:    dvriH | -HS
    *d SI shrxFlg   	// nz if any subhour reporting or exporting today: dvriS | -HS

// TOP: runtime: probe-able timing info
	*d *e DBL tp_tmrInput;		// input processing time, sec
	*d *e DBL tp_tmrAusz;		// autosizing time, sec
	*d *e DBL tp_tmrRun;		// main simulation time, sec
	*d *e DBL tp_tmrTotal;		// total execution time (not including reports), sec
	*d *e DBL tp_tmrAirNet;	// add'l timers active iff DETAILED_TIMING
	*d *e DBL tp_tmrAWTot;
	*d *e DBL tp_tmrAWCalc;
	*d *e DBL tp_tmrCond;
	*d *e DBL tp_tmrKiva;
	*d *e DBL tp_tmrBC;
	*d *e DBL tp_tmrZone;

    // many TOP working globals set/used comments are old, 12-91.

//TOP: runtime: re subHour and sub-subhour (aka ticks)
    *r float tp_subhrDur	// duration of subhour, hr (= 1/tp_nSubSteps)
	*r SI_GZ tp_nSubhrTicks	// # of subhour ticks for e.g. HPWH simulation
							//    1 per minute or as generalized
	*r DBL tp_tickDurMin	// duration of subhr tick, min
							//    = 1 min or as generalized
							//    used for e.g. HPWH simulation
	*r DBL tp_tickDurHr		// duration of subhr tick, hr
	*declare "int tp_NHrTicks() const { return tp_nSubSteps*tp_nSubhrTicks; }"

//TOP: runtime: simulation date/time variables
    *m ANAME monStr    	// Month being simulated as (non-heap) string
						// autoSizing: "heating design day", or month for cooling.
    *d CHP dateStr  	// Date being simulated as heap string
						// autoSizing: eg "heating design day" or "Jul cooling design day".
    *d IDATE tp_date  	// Date: .month is 1-12, .mday 1-31, .wday 0-6. set/used: cnguts. used:cuparse;cgsolar;cgresult;cgenbal.
						// autoSizing: cool: near-mid-month day as used for solar calcs; heat: Dec 21. jDay ditto.
    *d DOY jDay			// Day of year now simulating, 1..365. set: tp_MainSimI; used:cnguts;cuparse;cgwthr;cgsolar;cgresult.
    *d DOY xJDay		// extended jDay: same for main sim, 512 heat autosizing, 529-540 cooling autosizing.

    *h SI iHr		// Hour of day, 0-23.  set/used: tp_MainSim()
    *s SI iSubhr	// subhour of hour being simulated, 0.. .  set cnguts.cpp
    *s SHOY shoy	// extended subhour of year, for reporting peaks: subhr + 4 * (hr + 24*xJDay). set/used: cnguts.
    *h BOO isDT		// 1 if daylight saving time in effect, 0 if not.  Unspecified time/date variables are daylight.
   // Standard Time variables, for weather file interface and solar calcs.  Note std time date changes an hour later than daylight.
    *h SI iHrST     // Standard time Hour of day now simulating, 0-23.  set/used cnguts, used cgsolar.cpp.
    *h DOY jDayST  	// Standard time day of year, 1..365.  changes @ 1am -->*h.  set/used cnguts, used cgsolar.cpp.

   // TOP: autosizing phase/date variables
    *f BOO tp_autoSizing	// TRUE if setting up for or doing autosizing, 0 for main simulation setup/run
    *d BOO tp_pass1		// TRUE autoSizing pass 1 (A or B) thru dsn days: find big-enuf sizes with open-ended models
    *d BOO tp_pass1A	// TRUE for pass 1A of each dsn day: use idealized const-supply-temp models
    *d BOO tp_pass1B	// TRUE for pass 1B of each dsn day: use real models
    *d BOO tp_pass2		// TRUE autoSizing for pass 2 thru dsn days: determine loads, reduce oversize sizes.
    *d BOO tp_sizing	// TRUE when can increase sizes. eg FALSE during pass 2: warming up.
    *d INT tp_dsDayI	// index of design day being simulated: 0 heat, 1-12 coolDsMo[..-1]. set in cnausz.cpp. 6-95.
    *d SI tp_dsDay		// 0 main sim, 1 heating autoSize design day, 2 cooling ausz
    *d SI auszMon		// cool design day month 1-12 or generic month 0 for heat. 6-95.

//TOP: runtime time/day classification
    *s IVLCH ivl	// interval now starting or ending (C_IVLCH_Y, _M, etc),
					// cnguts:doEndIvl/doBegIvl to doIvlExprs, doIvlAccum, mtrAccum, cgaccum, doIvlPrior, etc
    *s IVLCH isBegOf 	// 0 or interval now starting (for exprssion eval) (C_IVLCH_Y, _M, etc; 0 except during expr eval) ...
    *s IVLCH isEndOf	// ditto ending. ... set in cnguts.cpp, tested in cueval.cpp.
						//  autoSizing gets no end-month nor end-year unless caller sets isLastDay & does extra final rep 6-95.
    *s BOO isBegRun		// 1st subhr of warmup, not set for run unless no warmup.
						// autoSizing: true if 1st subr of 1st repetition of dsn day.
	*s BOO tp_isBegMainSim	// 1st subhr of main sim (not warmup, not autosize)
    *m BOO isFirstMon	// TRUE if 1st month of main sim. set: doBeg/EndIvl. used: doIvlAccum.
						// ** autoSizing: moot; probably always on, depending how ivl comes out.
    *d BOO isLastDay  		// Last day of main sim
				/* ** autoSizing: only set if (poss future 7-95) caller sets & does extra last rep of dsn day,
				      else end-month and end-year exprs, reports, etc skipped (all moot?).
				      See comment in doEndIvl(). ******* Clarify this comment when get clear re final reps 6-95.*/
    *d BOO isLastWarmupDay	// TRUE iff last day of main sim warmup. set: cgMainsimI. used: cgwthr.cpp. 1-95.
				// autoSizing: not set; coding so moot.
    *s BOO isBegHour		// TRUE if subhour 0 of hour.  set cnztu.cpp/cnguts.cpp, used cnguts.cpp, .
    *s BOO isEndHour		// TRUE if last subhour of hour. set cnguts.cpp, used cnguts, cgresult.cpp.
    *h BOO isBegDay   		// TRUE if hour 0. set: doBegIvl.  used: doBegIvl,doIvlAccum; cgresult.cpp
    *h BOO isEndDay   		// TRUE if hour 23. set: doBegIvl. used: doEndIvl,doIvlAccum; cgresult.cpp
    *d BOO isBegMonth		// 1st day of month/run/warmup or 1st rep of dsn day.
    *d BOO isEndMonth  		// Mon/run, not warmup, last day.
				// ** autoSizing: moot; only set if caller sets isLastDay & does final extra rep of dsn day.
    *d BOO isSolarCalcDay	// TRUE if 1st day of month/run or 1st rep of dsn day: do 24 hours of solar calcs today. cnguts.
    *d BOO isWarmup      	// TRUE if main sim warmup. set/used: cgMainsimI. used: doBegIvl,doEndIvl,doIvlAccum,doIvlReports; exman,impf.
							// autoSizing: keep moot for now; may be on except for (future 6-95) extra last day eg for reports.
    *d SI dowh				// autoSizing: 8 heat 9 cool, else 7 if observed holiday, else day of week 0-6, for $dowh.
							//   weekend/holiday flags for probes / $variables (ul/cuparse.cpp).  Set in cnguts.cpp.
    *d BOO isHoliday		// TRUE on observed holiday: Monday after certain true holidays on weekend. Same as old isHoliObs, 7-92.
    *d BOO isHoliTrue		// TRUE (non-0) on true date of holiday
    *d BOO isWeHol		// weekend or holiday
    *d BOO isWeekend		// Saturday or Sunday
    *d BOO isBegWeek		// Non-WeHol after WeHol
    *d BOO isWeekday		// Mon-Fri
    *d BOO isWorkDay		// workday per Top.workDayMask (default Mon-Fri), 5-95
    *d BOO isNonWorkDay  	// non-workDay ditto 5-95
    *d BOO isBegWorkWeek	// workday after non-workday ditto 5-95

//TOP: runtime: autosizing
    //above: autoSizing, tp_dsDayI, tp_dsDay, auszMon.
    *d BOO notDone		// combined results of autoSize pass endtests
    *d INT dsDayNIt		// number of times this design day has been iterated

    //...

 /* TOP: runtime: hour and subhour weather data, set in cgwthr.cpp, used in cnloads.cpp, cnztu.cpp, cnguts.cpp, etc.
    Application uses interval average values for central-difference algorithms (masses),
    but end-interval instantaneous values for backwards-difference algorithms (zone heat & humidity balances). */
	*declare "void tp_SetPvHrWthr();"

    // irradiance. Weather file values are energy integrated over hour.
    // program needs [both] interval average [and end-interval (subhour only)] values. SOLAVNEND.
    // power (Btuh/ft2)===energy (Btu/ft2) for 1 hour.
    *h POWER radBeamHrAv  	// beam irradiance on tracking surface, hour energy = average power, from weather file
    *h POWER radDiffHrAv 	// diffuse irradiance on horizontal surface, hour energy = average power, from weather file
    *s POWER radBeamShAv	// .. current beam subhour average power, interpolated, Btuh/ft2
    *s POWER radDiffShAv	// .. current diffuse subhour power, interpolated by cgwthr.cpp, Btuh/ft2
#ifdef SOLAVNEND // cndefns.h (via cnglob.h) 1-18-94: only if computing & using end-ivl as well as ivl avg solar values
o  *s POWER radBeamSh		// .. end subhour instantaneous value, interpolated
o  *s POWER radDiffSh		// .. end subhour instantaneous value, interpolated
#endif

    // other weather: weather file contains instantaneous values for END OF HOUR; program needs only end-interval values.
	*declare "RC tp_WthrBegDay();"
	*declare "RC tp_WthrFillDsDay( WFILE* pWF);"
    *declare "RC tp_WthrBegHour();"
    *declare "RC tp_WthrBegSubhr();"
    *h TEMP tDbOHr			// outdoor dry bulb temp at end of hour, from wthr file, deg F.
    *h TEMP tDbOPvHr		// .. previous hour (used to compute -HrAv and -Sh)
    *h TEMP tDbOHrAv		// .. average over hour (used re hourly masses, bin res files, $variable)
    *s TEMP tDbOSh			// .. end subhour, interpolated (used re zone temp heat balance)
    *s TEMP tDbOPvSh		// .. end previous subhr (used to compute -ShAv)
    *s TEMP tDbOShAv		// .. average over subhour (used re subhourly masses)
    *h TEMP tWbOHr			// outdoor wet bulb temp at END OF hour, from wthr file wb depression, deg F.
    *h TEMP tWbOPvHr		// .. previous hour (used to compute -HrAv, -Sh)
    *h TEMP tWbOHrAv		// .. hour average (for $ variable)
    *s TEMP tWbOSh			// .. end subhour, interpolated (used re zone temp heat balance)
	*h TEMP tDpOHr			// outdoor dew point temp at END OF hour, from wthr file
    *h TEMP tDpOPvHr		// .. previous hour (used to compute -HrAv)
    *h TEMP tDpOHrAv		// .. hour average
    *s TEMP tDpOSh			// .. end subhour (derived from tDbOSh and wOSh)
    *h TEMP tSkyHr			// sky temperature, F
    *h TEMP tSkyPvHr		// .. previous hour (used to compute -Sh)
    *s TEMP tSkySh			// .. end subhr, interpolated)
    *h FLOAT windSpeedHr	// wind speed, mph, at end hour
							//     = Top.windF * max( wthrfile.wndspd, Top.windSpeedMin);
    *h FLOAT windSpeedPvHr	// .. previous hour (used to compute -HrAv, -Sh)
    *h FLOAT windSpeedHrAv	// .. hour average (for $ variable)
    *s FLOAT windSpeedSh	// .. end subhour, mph, interpolated: for $variable and ..
    *s FLOAT windSpeedSquaredSh	// .. end subhour squared (re zone infiltration), mph^2
    *s FLOAT windSpeedSqrtSh	// .. end subhour sqrt (re outside surface convection), mph^.5
    *s FLOAT windSpeedPt8Sh		// .. end subhour ^.8 (re outside surface convection), mph^.8
    *h FLOAT windDirDegHr	// wind direction at END HOUR from wthr file, degrees, 0=N, 90=E. (used for $variable)
    *declare "float tp_WindPresV( float windV) const;"
    *declare "float tp_WindFactor( float Z, int sheildClass, int terrainClass=0) const;"

    // additional derived weather info
    *h HUMRAT_GZ wOHr		// outdoor humidity ratio at end current hour, computed from tDbO and tWbO (used for $ variable)
    *h HUMRAT_GZ wOPvHr		// .. previous hour (used to compute -HrAv)
    *h HUMRAT_GZ wOHrAv		// .. hour average (for $ variable)
    *s HUMRAT_GZ wOSh		// .. at end current subhour: used throughout zones and systems models in program
    *s HUMRAT_GZ tp_wOShChangeBase  // outdoor humidity ratio saved for tp_wOShChange detection
    *s FLOAT hOSh			// outdoor enthalpy at end subhour. used at in AH::doEco, TOWERPLANT::towModel. 9-92.
    *s FLOAT tp_airxOSh		// air flow heat transfer @tDbOSh (vhc*60) (Btuh/cfm-F).
    *s FLOAT tp_rhoMoistOSh		// outdoor moist air density at end of subhour, lbm/ft3
    *s FLOAT tp_rhoDryOSh		// outdoor dry air density at end of subhour, lbm/ft3

// TOP: runtime: iteration control flags
    // each of the following is TRUE if the indicated class should be checKed for call-flagged or compute-flagged objects.
    // used in cnztu.cpp:hvacIterSubhr; set anywhere individual object call- and compute- flags are set.
    *s BOO tp_wOShChange    // TRUE iff non-negligible change in outdoor humidity ratio
    *s *hide BOO ztuKf  	// zone terminals
    *s *hide BOO ahKf		// AHs (air handlers)
    *s *hide BOO ahKf2		// AHs: secondary flag to recall only after zones done again, eg for non-convergence
    *s *hide BOO hpKf		// HEATPLANTs
    *s *hide BOO cpKf		// COOLPLANTs
    *s *hide BOO tpKf		// TOWERPLANTs
    *s SI iter     			// hvac terminal / air handler / plant iteration counter for cnztu.cpp:hvacIterSubhr.

// TOP: runtime: whole-building heating and cooling peaks
    *h FLOAT qcPeak		// maximum cooling load for an hour for entire building. Negative (if not 0).
    *h SI qcPeakH		// hour 1-24 of peak cooling load
    *h SI qcPeakD		// day of month 1-31 of peak load
    *h SI qcPeakM		// month 1-12 of peak load
    *h FLOAT qhPeak		// maximum heating load for entire building during an hour
    *h SI qhPeakH		// hour 1-24 of peak heating load
    *h SI qhPeakD		// day of month 1-31 of peak load
    *h SI qhPeakM		// month 1-12 of peak load

// TOP: runtime: AIRNET solution
	*declare "AIRNET* tp_pAirNet;"
    *f BOO tp_airNetActive  // TRUE iff AirNet is active (calcs s/b done)

// TOP: runtime: pointer to Penumbra (GPU shading) object
//      instantiated iff needed
	*declare "class Pumbra::Penumbra* tp_pPumbra;"
	*declare "RC tp_PumbraInit();"
	*declare "int tp_PumbraClearIf();"
	*declare "void tp_PumbraDestroy();"
	*declare "int tp_PumbraAvailability() const;"
	*declare "RC tp_PumbraSetModel();"

    *r SI ck5aa5		// stuffed with 0x5aa5 from topCult for verifying initialization & matching versions
*END		// TOPRAT

//==================================================================================================================
RECORD PYLINEAR "linear poly sub" *SUBSTRUCT	// linear polnomial (mononomial?)(one independent variable) for TOWERPLANT

    *declare "DBL val(DBL x)        { return k[0] + k[1]*x; }"
    *declare "RC normalize( record *r, SI fn, char *descrip, DBL x=1.0);"		// function in cncult5.cpp

    *f *ARRAY 3 FLOAT k 		// FLOAT k[3].  One extra member needed as terminator by cul.cpp array input logic.
*END		// PYLINEAR
//==================================================================================================================
RECORD PYCUBIC "cubic poly sub" *SUBSTRUCT	// cubic polnomial (one independent variable) for FAN, COIL,

    *declare "DBL val(DBL x)        { return k[0] + k[1]*x + k[2]*x*x + k[3]*x*x*x; }"
    *declare "RC normalize( record *r, SI fn, char *descrip, DBL x=1.0);"		// function in cncult5.cpp

    *f *ARRAY 5 FLOAT k 		// FLOAT k[5].  One extra member needed as terminator by cul.cpp array input logic, 5-92.
    /* possible future setup optimizations: 1) select ptr to fcn that does not compute terms whose k is 0;
       2) precalculate constants to compute in form  ((x*k[3] + k[2])*x + k[1])*x + k[0] */
*END		// PYCUBIC
//==================================================================================================================
RECORD PYCUBIC2 "cubic poly sub" *SUBSTRUCT	// cubic polnomial (one independent variable) with x0 for FAN, COIL,

    *declare "DBL val(DBL x)        { x -= k[4];  if (x < 0.)  x = 0.;  return k[0] + k[1]*x + k[2]*x*x + k[3]*x*x*x; }"
    *declare "RC normalize( record *r, SI fn, char *descrip, DBL x=1.0);"		// function in cncult5.cpp

    *f *ARRAY 6 FLOAT k 		// FLOAT k[6]. [0..3] are coeff, [4] is minimum x, [5] is terminator needed by cul.cpp.
*END		// PYCUBIC2
//==================================================================================================================
RECORD PYBIQUAD "biquadratic ply sub" *SUBSTRUCT	// biQuadratic polynomial (two independent variables)

    *declare "DBL val( DBL x, DBL y)        { return k[0] + k[1]*x + k[2]*x*x + k[3]*y + k[4]*y*y + k[5]*x*y; }"
    *declare "RC normalize( record *r, SI fn, char *descX, char*descY, DBL x, DBL y, BOO noWarn=FALSE);"	// cncult5.cpp
    *declare "RC normalizeCoil( AH *ah, SI fn);"    							// function in cncult5.cpp

    *f *ARRAY 7 FLOAT k  		// FLOAT k[7].  One extra member needed as terminator by cul.cpp array input logic, 5-92.
*END		// PYBIQUAD

//==================================================================================================================
RECORD PY4 "4th power poly sub" *SUBSTRUCT	// 4th power polynomial. for GT, which does not use k[0]. added 12-94.

    //*declare "DBL val( DBL x)  { DBL x2 = x*x;  return k[0] + k[1]*x + k[2]*x2 + k[3]*x2*x + k[4]*x2*x2; }"
    *declare  "DBL val1( DBL x)  { DBL x2 = x*x;  return        k[1]*x + k[2]*x2 + k[3]*x2*x + k[4]*x2*x2; }"

    *f *ARRAY 6 FLOAT k			// FLOAT k[6].  One extra member needed as terminator by cul.cpp array input logic.
*END		// PY4
//==================================================================================================================
RECORD INVERSE "Inverse" *RAT	// function inverter

  *prefix iv_
  *declare "RC iv_CkF();"
  *declare "RC iv_Init();"
  *declare "RC iv_Calc( IVLCH ivl);"

  *r IVLCH iv_freq
  *r FLOAT iv_X0
  *r FLOAT iv_Y0
  *r FLOAT iv_YTarg

  *s *p FLOAT iv_X
  *s *p FLOAT iv_Y

  *i FLOAT iv_XEst

*END // INVERSE
//==================================================================================================================
RECORD WFILE "weatherFile" *RAT	// weather file info, one static instance "Wfile", made a record 1-94 so probe-able

// CAUTION: record layout matches code in wfpak.cpp, do not change without updating header decode !!
    *prefix wf_
    *excon			// declare constructor WFILE( basAnc *b, TI i, SI noZ=0) in wfpak.cpp: calls init().
    *exdes			// d'tor
    *ovrcopy		// overridden Copy()
    *declare "WFILE();"		// default c'tor
    *declare "void wf_Init();"	// initialization member fcn
    *declare "RC wf_Open( const char* wfName, const char* TDVfName, int erOp=ERR, int wrA=FALSE, char* hdr=NULL,"
    *declare "    float* clrnss=NULL, float* turbid=NULL, float* atmois=NULL);"
	*declare "RC wf_Close( char *hdr=NULL);"
	*declare "const char* wf_FilePath() const;"
	*declare "RC wf_PackedOpen(const char* wfName, int erOp, int wrAccess, char* hdr, float* clrnss, float *turbid, float* atmois);"
	*declare "RC wf_BsgsDecodeHdr( char* hdr, int erOp);"
	*declare "RC wf_EtDecodeHdr( char* hdr, int erOp, float* clrnss, float* turbid, float* atmois);"
	*declare "RC wf_DecodeHdrFields( char* hdr, struct WFHTAB* wfht0, int erOp);"
	*declare "RC wf_FillWDYEAR( int erOp=WRN);"
	*declare "enum { gshrFILEDAY, gshrDSDAY, gshrDSDAY0 };"
	*declare "RC wf_GenSubhrRad( SLRINTERPMETH slrInterpMeth, int dayTy, int jDay);"
	*declare "RC wf_GetSubhrRad( int jDay, int iHrST, int iSh, float& radBeamAv, float& radDiffAv);"
	*declare "WDHR& wf_GetDsDayWDHR( int iHr);"
	*declare "RC wf_GetDsDayHr( WDHR* pWd, int iHr, int erOp = WRN);"
	*declare "RC wf_Read( WDHR* pWd, int jDay, int iHr, int erOp = WRN);"
	*declare "USI* wf_PackedHrRead( int jDay, int iHr, int erOp = WRN);"
	*declare "LI wf_PackedHrOffset( int jDay, int iHr, int erOp = WRN);"
	*declare "RC wf_CSWOpen( const char* wfName, int erOp );"
	*declare "RC wf_CSWRead( WDHR* pwd, int jDay, int iHr, int erOp );"
	*declare "RC wf_CSWHdrVal( const char* key, const char* val, float& v, RC& rcAll, int erOp=WRN);"
	*declare "RC wf_CSWHdrVal( const char* key, const char* val, int& v, RC& rcAll, int erOp=WRN);"
	*declare "RC wf_CSWPosHr1( int erOp=WRN);"
	*declare "RC wf_T24DLLOpen( const char* wfName, int erOp);"
	*declare "RC wf_T24DLLRead( WDHR* pwd, int jDay, int iHr, int erOp);"
	*declare "RC wf_EPWOpen( const char* wfName, int erOp );"
	*declare "RC wf_EPWPosHr1( int erOp=WRN);"
	*declare "RC wf_EPWRead( WDHR* pwd, int jDay, int iHr, int erOp );"
	*declare "RC wf_TDVOpen( const char* TDVfName, int erOp);"
	*declare "void wf_TDVInitHdrInfo();"
	*declare "RC wf_TDVReadHdr( int erOp=WRN);"
	*declare "RC wf_TDVPosHr1( int erOp=WRN);"
	*declare "RC wf_TDVReadIf( WDHR* pwd, int erOp, int jDay, int iHr);"
	*declare "RC wf_FixJday( DOY& jDay, int begDay );"

	 // in base class: .name, .ownTi, more.
     *r WFileFormat wFileFormat	// file format enum: UNK, BSGS, ET1, etc.

     *declare "int wf_IsPacked() const { return wFileFormat==BSGS || wFileFormat==BSGSdemo || wFileFormat==ET1 || wFileFormat==ET2; }"

 // Header info: from file hdr decode or computed from hourly
    *r WFLOC loc		// char loc[]  Location (for ET, is loc 1 only: city etc).
    *r WFLID lid		// char lid[]  Location ID
    *r SI yr			// Year of weather data (00 - 99, -1 if N/A)
    *r SI jd1			// Julian day of first weather record (-1 if not known)
    *r SI jdl			// Julian day of last weather record (ditto)
    *r float lat		// latitude, degrees N (-90.0 to 90.0)
    *r float lon		// longitude, degrees W (-180. to 180.0).  US locations are >0, note non-standard
    *r float tz			// time zone, hours W of Greenwich (EST = +5, note non-standard
    *r float elev		// elevation of locn in ft (-9999. to 99999.)
    *r float taDbAvgYr	// annual average dry-bulb temp, F
	*f float tMainsAvgYr    // annual average cold water temp, F
						    //    computed per CEC ACM method
    *f float tMainsMinYr    // annual minimum cold water temp, F
    *r SI solartime		// TRUE if file is in solar time
 //additional header items for ET1 file
    *r WFLOC2 loc2		// char[] location 2 (state or country, etc)
    *r SI isLeap		// non-0 if weather file is for a leap year (Feb 29 counted in dates) -- possible future use
    *r SI firstDdm		// month 1-12 of first design day in file
    *r SI lastDdm		// month 1-12 of last design day in file
    *r SI winMOE		// winter median of extremes (deg F)
    *r SI win99TDb		// winter 99% design temp (deg F)
    *r SI win97TDb		// winter 97.5% design temp (deg F)
    *r SI sum1TDb		// summer 1% design temp (deg F)
    *r SI sum1TWb		// summer 1% design coincident WB (deg F)
    *r SI sum2TDb		// summer 2.5% design temp (deg F)
    *r SI sum2TWb		// summer 2.5% design coincident WB (deg F)
    *r SI sum5TDb		// summer 5% design temp (deg F)
    *r SI sum5TWb		// summer 5% design coincident WB (deg F)
    *r SI range			// mean daily range (deg F)
    *r SI sumMonHi		// month of hottest design day, 1-12
    //following are in ET1 file and can be returned via optional wfOpen arguments
    // *array 12 *r float clearness	// monthly clearness numbers, multipliers, eg 1.05, for design day solar
    // *array 12 *r float turbidity	// monthly average atmospheric turbidity, for daylight calcs
    // *array 12 *r float atmois	// monthly aveage atmospheric moisture, for daylight calcs

// TDV file header info
    *f WFLOC wf_TDVFileTimeStamp	// timestamp string
	*f ANAME wf_TDVFileTitle		// title string (identifies file CZ, fuel, vintage, )

 //internal
    *r *hide SI hdrBytes 	// # header bytes before first record (used in wfread for file positioning)
    *r *hide SI hourBytes	// # bytes per hour
    *r *hide INT csvCols	// # of columns in comma separated formats (e.g. CSW)
    *r *hide YACAMP yac		// pointer to "Yet Another Char Access Method" subobject for buffering & decoding weather file
	*r *hide YACAMP yacTDV	// ditto TDV file
    *r INT wf_TDVFileJHr;	// last hour (row) in file that has read (1 based)
    *r *hide WDYEARP wf_pWDY	// pointer to entire year weather data pre-read from file
*END			// WFILE
//========================================================================================================
RECORD WDHR "wfdata sub" *SUBSTRUCT	// hourly data substructure for WFDATA
	*prefix wd_
    *declare "void wd_Init( int options=0);"
    *declare "WDHR& Copy( const WDHR& wd, int options=0);"
	*declare "RC wd_WfReader( BOO nextHour, WFILE* pWF);"
	*declare "void wd_Adjust( int iHrST);"
	*declare "void wd_SetSolarValues( int jDayST, int iHrST);"
    *declare "int wd_SunupBegEnd( int iHr, float& hrBeg, float& hrEnd) const;"
	*declare "RC wd_Unpack( int iH, USI* pHour, int wFileFormat=ET1);"
    *declare "RC wd_EstimateMissingET1( int iHr);"
    *declare "float wd_CalcSkyTemp( int skyModelLW, int iHr);"
    *declare "RC wd_CSWReadHr( WFILE* pWF, int jHr, int erOp=WRN);"
    *declare "RC wd_TDVReadHr( WFILE* pWF, int jHr, int erOp=WRN);"
    *declare "RC wd_EPWReadHr( WFILE* pWF, int jHr, int erOp=WRN);"
	*declare "RC wd_GenDesCondHeating( WFILE* pWF, int jDayST, int iHrST);"
	*declare "RC wd_UpdateDesCondHeating();"
	*declare "void wd_FillFromDESCOND( const DESCOND& dc, int iHr);"
	*declare "void wd_SetDayValues( const class WDDAY& wdd);"
	*declare "void wd_SetDayValuesIfMissing( const class WDDAY& wdd);"
	*declare "void wd_SetTdvElecHrRank( const class WDDAY& wdd);"
	*declare "void wd_ShiftTdvElecHrRankForDST();"
	*declare "bool wd_HasTdvData() const;"

						// wd_sunupf, wd_slAzm, wd_slAlt MUST BE BEFORE wd_db
						// wd_db assumed 1st non-solar geometry mbr
						// re preservation of solar geometry info, see Copy()
	*h float wd_sunupf;		// fraction of hour if sun is up
							// solar position at midpoint of hour (or portion of hour sun is up)
	*h float wd_slAzm;		//   azimuth, radians (0=N, +clockwise)
	*h float wd_slAlt;		//   altitude, radians (0=horizon, +upwards)

    *h float wd_db			// air dry bulb temp, deg F
    *h float wd_wb			// air wet bulb temp, deg F

	*h float wd_DNI			// direct normal irradiance from weather file (integrated value for hour, Btu/ft2)
	*h float wd_DHI			// diffuse horizontal irradiance from weather file (integrated value for hour, Btu/ft2)
    *h float wd_bmrad		// DNI as adjusted per anisotropic sky, Top.radBeamF, etc (integrated value for hour, Btu/ft2)
    *h float wd_dfrad		// DHI as adjusted per anisotropic sky, Top.radDiffF, etc (integrated value for hour, Btu/ft2)

    *h float wd_wndDir		// wind direction, deg, 0=N, 90=E
    *h float wd_wndSpd		// wind speed, mph

    *h float wd_glrad		// global irradiance on horizontal surface, for daylighting calculations
    *h float wd_cldCvr		// total cloud cover in tenths, 0-11, or 15 for missing data

	*h float wd_tSky		// sky temperature, F from weather file or CalcSkyTemp() (Berdahl-Martin)
							//   Note: Top.tSkyHr alternative value per Top.skyModelLW
	*h float wd_tGrnd		// ground temperature, F
	*h float wd_taDp		// air dew point temp, F
	*h float wd_tMains		// cold water mains temp, F
							//   computed using CEC ACM method

							// time-of-day fuel values, units = TDV/Btu
							//   values are read from optional TDV file
	*h float wd_tdvElec		//      electricity
	*h float wd_tdvFuel		//      fuel

							// derived (computed) drybulb temp values
							//   values updated at standard time day beg / same all day
							//   *except* wd_taDbPk is updated at hr=23 iff DST
	*h float wd_taDbPk			// current day peak DB (includes future hours), F
								//   updated at hr=23 iff DST
	*h float wd_taDbAvg			// current day average DB (includes future hours), F
	*h float wd_taDbPvPk		// previous-day peak DB, F
	*h float wd_taDbAvg01		// previous-day avg DB (not including current day), F
	*h float wd_taDbAvg07		// trailing 7-day avg DB (not including current day), F
	*h float wd_taDbAvg14		// trailing 14-day avg DB (not including current day), F
	*h float wd_taDbAvg31		// trailing 31-day avg DB (not including current day), F


							// derived (computed) electricity TDV values
							//   values updated at standard time day beg / same all day
							//   *except* at hr=23 iff DST
	*h float wd_tdvElecPk			// current day peak TDVelec (includes future hours)
									//   updated at hr=23 iff DST
    *h SI wd_tdvElecPkRank			//   current day wd_tdvElecPk rank within year (1-365/366)
									//       (largest wd_tdvElecPk=1, next=2, etc.)
	*h float wd_tdvElecAvg			// current day avg TDVelec (includes future hours)
	*h float wd_tdvElecPvPk			// previous-day peak TDVelec
	*h float wd_tdvElecAvg01		// previous-day avg TDVelec (not including current day)
									//     NOTE: code assumes wd_tdvElecAvg01 is last float
	*h *ARRAY 25 SI wd_tdvElecHrRank	// hour ranking of TDV values for current day
										//   hour values reflect DST status for current day
										//   [ 0]=unused
										//   [ 1]=hour of highest tdvElec, 1-24
										//   [ 2]=hour of 2nd highest
										//   etc

*END	// WDHR
//========================================================================================================
RECORD WFDATA "weather" *RAT	// hourly weather data, one static instance "Wthr", here so probe-able

	*prefix wd_
    *declare "void wd_Init();"		// initialize

    // in base class: .name, .ownTi, more.

    *h *noname *nest WDHR d	// all data in substructure
							// WHY: allows storage / manipulation w/o record overhead
							//   WFDATA must be record re probing
							//   WDHR used elsewhere (e.g. whole file pre-read)
*END		// WFDATA
//========================================================================================================
RECORD DESCOND "DESCOND" *RAT		// cooling design conditions
*prefix dc_
	*declare "RC dc_CkF();"
	*declare "DOY dc_GetDOY() const { return dc_doy; }"
	*declare "RC dc_RunInit();"
	*declare "RC dc_CheckFixSolar( int options);"
	*declare "void dc_GenerateTemps( int iHr, float astCor, float& db, float& wb, float& dbAvg) const;"

	*i DOY dc_doy;			// calc date for this DESCOND (1-365)

	*i FLOAT dc_DB;			// design dry-bulb temp, F
	*i FLOAT dc_MCDBR;		// coincident daily db range, F
	*i FLOAT dc_MCWB;		// coincident wet-bulb temp, F
	*i FLOAT dc_MCWBR;		// coincident daily wb range, F
							//    if omitted, constant dewpoint limited by saturation
	*i FLOAT_GEZ dc_wndSpd;	// wind speed, mph

							// parameters for ASHRAE clear sky model
							//      if taub/d provided, ebn/edh derived else reverse
							//      if all 0, solar is 0 all hours
	*i FLOAT_GEZ dc_tauB;		// beam tau
	*i FLOAT_GEZ dc_tauD;		// diffuse tau
	*i FLOAT_GEZ dc_ebnSlrNoon;	// solar noon beam normal, Btuh/ft2
	*i FLOAT_GEZ dc_edhSlrNoon;	// solar noon diffuse horiz, Btuh/ft2

*END	// DESDAY
//========================================================================================================
RECORD SURFGEOM "surfgeom sub" *SUBSTRUCT	// surface geometry substructure
// embedded in many surface types, initially SHADEX and PVARRAY, 2-17
	*prefix gx_
	*declare "SURFGEOM();"
	*declare "~SURFGEOM();"
    *declare "void gx_SetParent( record* pParent, int options=0);"
	*declare "RC gx_Init();"
	*declare "bool gx_IsEmpty() const;"
	*declare "RC gx_Validate( record* pParent, const char* what, int options=0);"
	*declare "void gx_CopySubObjects();"
	*declare "RC gx_CheckAndMakePolygon( int phase, int fn);"
	*declare "int gx_GetAzmTilt( float& azm, float& tilt) const;"
	*declare "RC gx_SetupShading ( int &nS, const class CT3D* MT, int options=0);"
	*declare "void gx_ClearShading();"
	*declare "int gx_CalcBeamShading( float& cosi, float& fBeam);"

	*declare "record* gx_pParent;"				// pointer to parent record
												//   (SHADEX, PVARRAY, ...)
	*declare "class SURFGEOMDET* gx_sgDet;"		// geometric details (polygon, normal, )
												//   hides geometry.h classes
	*i MOUNTCH gx_mounting						// mounting
												//    C_MOUNTCH_BLDG: attached to bldg (rotates per bldgAzm)
												//	  C_MOUNTCH_SITE: site base (does not rotate)
	*i INT gx_pnIdx;							// Penumbra surface index
												//   -1 if no Penumbra surface
	*i DBL gx_area;								// area derived from polygon, ft2

	*h *e FLOAT gx_fBeam;						// fraction of area receiving direct beam
												//   1 if no Penumbra shading
	*h *e INT gx_fBeamErrCount;					// counter for fBeam > 1 errors
												//   limits # of runtime messages

	*i *ARRAY DIM_POLYGONXYZ FLOAT gx_vrtInp	// input vertices (x, y, z), ft
*END	// SURFGEOM
//========================================================================================================
RECORD SHADEX "SHADEX" *RAT		// shade object (polygon that can shade surfaces)

	*prefix sx_
	*excon
	*ovrcopy
	*declare "RC sx_Init();"
	*declare "void FixUp();"	// virtual fixup after basAnc reAl
								// .ownTi (base class) is zone subscript
	*declare "RC sx_CkF();"
	*declare "RC Validate( int options=0);"
	*declare "RC sx_SetupShading( int& nS, const class CT3D* MT, int options=0) { return sx_g.gx_SetupShading( nS, MT, options);}"

	*i *noname *nest SURFGEOM sx_g;	// geometry of shade

*END	// SHADE
//========================================================================================================
RECORD SGDIST "sgdist sub" *SUBSTRUCT	// solar gain distribution substructure for XSURF and SGI
	*prefix sd_
    *r SI sd_targTy   	// target type: define (cnguts.h)   basAnc & member
						// zone air   					SGDTTZNAIR    ZNR.qSgAir
						// (zone check/results total  	SGDTTZNTOT    ZNR.qSgTot/qSgTotSh (not here; gen'd in cgsolar 2-95)
						// surface in/outside			SGDTSURFI/O
    *i TI sd_targTi  	// subscript of targeted entry in RAT above: *i in SGI; *nest merges variation flags.
    *mh FRAC sd_FSO		// frac of gain to target, shades open
    *mh FRAC sd_FSC		// frac of gain to target, shades closed (defaults to sgd_FSO)
*END		// SGDIST
//========================================================================================================
RECORD HCI "hci sub" *SUBSTRUCT		// HCI: helper for managing variable inside convective coeffs
    *prefix hc_
	*declare "void hc_Init( float hc);"
	*declare "double hc_HC( double hc);"
	#define HCHISTL 4				// length of value history re smoothing
	*declare "enum { hcHISTL=4 };"	// make HCHISTL known to C++ (must agree with HCHISTL)

#if defined( CONV_ASHRAECOMPARE)
   	*declare "void hc_InitAsh( float tilt, int si);"
	*declare "double hc_HCAsh( int mode, float taRoom, float tSurf);"
	*r *array 3 FLOAT hc_t					// array of possible values for this coeff
											//   [ 0] = still air, tAir > tSurf
											//   [ 1] = still air, tAir <= tSurf
											//   [ 2] = moving air (system on)
#endif
	*r *array HCHISTL FLOAT hc_history		// value history (used by hc_HC to average over prior calls)
	*r INT hc_iXHist						// hc_history index (cycles 0 .. hcHISTL-1)

*END	// HCI
//=======================================================================================
RECORD SGTARG "sg targ" *SUBSTRUCT	// solar gain target
						// Note: values can be Btuh or Btuh/ft2 depending
						//       on inclusion of area in setup
*prefix st_
*s *e DBL st_bm		// beam
*s *e DBL st_df		// diffuse
*s *e DBL st_tot	// total

*END // SGTARG
//=======================================================================================
RECORD SBCBASE "SBCBASE" *SUBSTRUCT *HIDEALL
*prefix sb_
*declare "virtual double sb_AreaNet() const = 0;"
*declare "virtual const char* sb_ParentName() const = 0;"
*declare "virtual int sb_Class() const = 0;"

  *mh FRAC sb_absSlr	// solar (SW) absorptance, dimless
  *mh DBL sb_awAbsSlr	// area-weighted solar absorptance
						//   = sb_absSlr * area / zn_surfASlr
						//   exterior surf outside: always 0
						//   windows inside: TBD 12-8-10
						//   ducts: always 0
  *r FRAC sb_epsLW		// thermal (LW) emittance
  *r TI sb_zi			// adjacent zone idx, 0 if exposed to ambient
  *r DBL sb_F			// solar (short wave) fraction ?  TODO: NOT USED? as of 4-2012
  *r DBL sb_Fp			// "view factor" to zone radiant temp, dimless.  Includes Oppenheim surface conductance.
						//   aka "F-prime" in CZM documentation.

  *r DBL sb_frRad		// re radiant to radiant temp (room radiant node or sky)
  *r DBL sb_fSky		//   "view factor" to radiant surround at sky temp
  *r DBL sb_fAir		//   "view factor" to radiant surround at air temp (ground, horizon)

  *s *e FLOAT sb_hcNat	// surface natural convection coefficient, Btuh/ft2-F
  *s *e FLOAT sb_hcFrc	// surface forced (wind) convection coefficient, Btuh/ft2-F
  *s *e FLOAT sb_hcMult	// surface convection coefficient multiplier, dimless
  *s *e FLOAT sb_hxa	// overall coeff to sb_txa = sb_hcMult*(sb_hcNat + sb_hcFrc), Btuh/ft2-F
  *s *e FLOAT sb_hxr	// surface (linearized) radiative coefficient, Btuh/ft2-F
						//   = coupling to sb_txr
  *s *e FLOAT sb_hxtot	// sb_hxa + sb_hxr
  *s *e DBL sb_uRat		// ratio uC/(sb_hxa + sb_hxr + uC)
						//     = 1/(1 + rC*(sb_hxa + sb_hxr)
						// where uC = surface-to-surface conductance
						//       rC = 1/uC
						// but: duct model outside surf to duct air

  *s *e DBL sb_fRat		// sb_hxtot * sb_uRat, Btuh/ft2-F
						//   = overall conductance not including other side
						//     surface resistances
						//   (ducts: overall conductance from duct air to sb_txe)
  *s *e DBL sb_cx		// air/radiant coupling due to this surface, Btuh/ft2-F
						//

  *declare "double sb_sgf[ socCOUNT][ sgcCOUNT];"
						// accumulators used *only* re cgsolar gain SGTARG setup
						//  = gain per unit exterior solar
						//      dimless if gain per (receiving) unit area
						//      ft2 if gain for entire receiving area
						//    [ shades open/closed][ sgcBMXBM/sgcDFXDF/sgcDFXBM]
  *s *e *nest SGTARG sb_sgTarg	// solar gain target: bm, df gain from insolation
  *s *e DBL sb_sg		// absorbed solar total, Btuh (NOT Btuh/ft2), summed from sb_sgTarg

#if 0	// TODO
x  *h RIGTARG sb_rIg  	// radiant internal gain target (float) (Btuh).  TODO
#endif

  *s *e FLOAT sb_tSrf	// most recently calculated surface temp, F
  *s FLOAT sb_tSrfls	// last step surface temp, F
						//	 copied from sb_tSrf at step end
						//   not *e (available for probing)
  *s *e DBL sb_qrAbs	// total absorbed radiant heat gain at surface, Btuh/ft2 (+ = into surface)
						//   = (sb_sg + sb_rIg)/area
  *s *e FLOAT sb_txa	// adjacent air temp, F (from prior step)
						//   inside: prior step zone tz
						//   outside: current step ambient dry bulb temp
  *s *e FLOAT sb_txr	// adjacent radiant temp, F
						//   inside: prior step zone tr
						//   outside: current step sky temp
  *s *e FLOAT sb_txe	// adjacent environmental temp, F
						//   combined sb_txa and sb_txr; simplifies calcs in some cases
						//   set but unused? for inside
						//   set/used for ASHWAT outside
  *s *e DBL sb_w		// adjacent air humidity ratio if known (else 0)
						//   used re duct leakage
  *s *e DBL sb_qSrf		// conduction into surface, Btuh/ft2
						//   updated at end of timestep

*END		// SBCBASE
//=======================================================================================
RECORD SBC "SBC" *SUBSTRUCT *BASECLASS SBCBASE		// surface boundary condition substructure
// Partial overlap with MASSBC and SBC, should merge?
  *prefix sb_
  *declare "void sb_Init( XSURFP xs, int si);"
  *declare "void sb_SGFInit();"
  *declare "virtual double sb_AreaNet() const;"
  *declare "virtual int sb_Class() const;"
  *declare "void sb_CalcAwAbsSlr();"
  *declare "virtual const char* sb_ParentName() const;"
  *declare "int sb_HasHcNat() const;"
  *declare "void sb_SetRunConstants( int dbPrint);"
  *declare "void sb_SetCoeffs( double area, double uC);"
  *declare "void sb_HCAmbient();"
  *declare "float sb_CGrnd() const;"
  *declare "void sb_SetCoeffsWallBG( float a[]);"
  *declare "void sb_SetCoeffsFloorBG( float a4, float a5);"
  *declare "void sb_HCZone();"
  *declare "void sb_SetTx();"
  *declare "double sb_QHT() const { return sb_qrAbs + sb_hxa*sb_txa + sb_hxr*sb_txr; }"
  *declare "void sb_BalCheck();"
  *declare "const char* sb_SideText();"
  *declare "static void sb_DbPrintf( const char* tag, const SBC& sbcO, const SBC& sbcI);"


  *r XSURFP sb_pXS		// parent pointer
  *r int sb_si			// side of *sb_pXS represented by this SBC
						//   0=inside, 1=outside
  *r DBL sb_fcWind		// wind constant re sb_hcFrc (includes roughness, unit conversion, height adj, ...)
						// value is model specific
						//   Walton: sb_hcFrc = sb_fcWind * Top.windSpeedSqrtSh
						//   Unified: sb_hcFrc = sb_fcWind * Top.windSpeedPt8
  *r DBL sb_fcWind2		// unified: add'l constant re sb_eta
  *s *e DBL sb_eta		// unified: wind speed adjustment included in sb_hcNat
						//   windV=0: sb_eta=1, sb_hcNat=still-air value
						//   windv>0: sb_eta<1, sb_hcNat is reduced

						// characteristic dimensions re convection models
						// not always set or used
						// Note: may be derived from parent surface TODO
  *r DBL sb_widNom		//	 nominal width, ft (smaller dimension assuming rectangle)
  *r DBL sb_lenNom		//   nominal length, ft (larger dimension assuming rectangle)
  *r DBL sb_lenCharNat	//	 characteristic length for some natural convection models, ft
  *r DBL sb_lenEffWink	//   effective length for Winkelmann forced convection model, ft

  *r DBL sb_cosTilt		// cos( Tilt ) for the boundary -- note parent surface tilt is defined
						// relative to outside normal (sbcO), so inside sb_cosTilt is oposite (+180 deg)
  *r DBL sb_atvDeg		// angle-to-vertical, deg (inside: 90-tilt; outside: tilt-90)
  *r DBL sb_cosAtv		// cos( angle to vertical) 0 - 1 (never < 0)
  *i CONVMODELCH sb_hcModel // surface convective coefficient model
						//       specifies calc method sb_hcNat and sb_hcFrc
  *r FLOAT sb_hcLChar	// characteristic length, ft
						//   used in derivation of exterior forced convective coeff
						//   default = 10 ft
						//   unused re natural convective coeff (interior or exterior)
  *r *array 3 DBL sb_hcConst
						// convection coefficient model constants
						//    Unified: exposure to zone or ambient
						//			   hcNat = sb_hcConst[]*abs( TD)^.33)
						//			   [ 0]: tAir<=tSrf, [ 1]: tAir>tSrf
						//			   [ 2]: unused
						//    ASHRAE: exposure to zone, hcNat = sb_hcConst[]
						//			   [ 0]: sys off, tAir<=tSrf, [ 1]: sys off, tAir>tSrf
						//             [ 2]: sys on

						// re sfExCnd = GROUND: conductances to weather vars, Btuh/ft2-F
						//  correlation values derived by Bazjanac/Huang for various
						//  insulation configurations
  *i GROUNDMODELCH sb_groundModel	// ground model in use (not input 1/1/2015)
									//   C_GROUNDMODELCH_D2INP: DOE-2 model w/ user coeffs
									//   C_GROUNDMODELCH_D2COR: DOE-2 model w/ correlation coeffs
  *i FLOAT_GEZ sb_cTaDbAvgYr	// to annual avg taDb
  *i FLOAT_GEZ sb_cTaDbAvg31	// to last 31 day avg taDb
  *i FLOAT_GEZ sb_cTaDbAvg14	// to last 14 day avg taDb
  *i FLOAT_GEZ sb_cTaDbAvg07	// to last 7 day avg taDb
  *i FLOAT_GEZ sb_cTGrnd		// to computed ground temp
  *r FLOAT_GEZ sb_rGrnd			// resistance = 1/(sum of above) (0 if sum=0)
  *i FLOAT_GEZ sb_rConGrnd		// ground model implicit construction resistance, ft2-F/Btuh
								//    = approx resistance of construction film/carpet/slab/soil
								//    Caution: construction should be consistent with configuration
								//      implicit in coefficient values.

  *i *noname *hide *nest HCI sb_hCX	// maintains convection coefficient moving average
									//   at runtime (zone-exposed surfaces only)

 #if defined( CONV_ASHRAECOMPARE)
  *s FLOAT sb_hcNatAsh
  *i *nest HCI sb_hCXAsh	// manages convective coefficient at runtime
 #endif

*END		// SBC
//========================================================================================================
RECORD XSURF "xsurf sub" *SUBSTRUCT	// for PRI, SFI, XSRAT.
// XSURF: represents one radiant/conductive coupling to ambient (or to exT).
// Each Zone's ZNR record points to a chain of XSURFs.
// Each XSURF represents an exterior opaque surface, window, or perim.
// An XSURF has a uval from the ambient (or .exT) to the zone air
//		(except to outside surface of mass for CTMXWALL).
// An XSURF receives radiation per its area, orientation, & absorptivity,
//		and distributes ("targets") the solar gain to zone air or
//		mass inside or outside surface, per info in the structure.
//	XSURFs are used at runtime as a substruct of XSRAT (next),
//	       and during input as a substruct of SFI and PRI.

	*prefix xs_
	*declare "XSURF();"
	*declare "~XSURF();"
	*declare "void xs_DeleteFENAW();"
	*declare "void xs_Init( record* pParent, int options=0);"
	*declare "XSURF& Copy( const XSURF* pXS, int options=0);"
	*declare "RC xs_Validate( int options=0);"
	*declare "SBC& xs_SBC( int si) { return si ? xs_sbcO : xs_sbcI; }"
	*declare "const char* xs_Name() const;"
	*declare "int xs_CanHaveExtSlr() const;"
	*declare "RC xs_SetUNom();"
	*declare "float& xs_AbsSlr( int io) { return xs_SBC( io).sb_absSlr; }"
	*declare "float xs_AreaGlazed() const;"
	*declare "void xs_SetRunConstants();"
	*declare "void xs_AccumZoneValues();"
	*declare "void xs_sbTest();"
	*declare "RC xs_SubhrBC();"
	*declare "RC xs_ASHWAT();"
	*declare "RC xs_SubhrQS();"
	*declare "RC xs_EndSubhr();"
	*declare "void xs_AfterSubhr();"
	*declare "void xs_AfterHour();"
	*declare "TI xs_GetZi( int si) const;"
	*declare "int xs_IsASHWAT() const;"
	*declare "int xs_HasControlledShade() const;"
	*declare "int xs_IsDelayed() const { return xs_msi != 0; }"
	*declare "int xs_IsKiva() const;"
	*declare "int xs_IsPerim() const;"
	*declare "int xs_CanBeSGTarget() const;"
	*declare "int xs_Class() const;"
	*declare "int xs_TyFromTilt() const;"
	*declare "void DbDump() const;"

	*declare "record* xs_pParent;"	// pointer to parent record (SFI, XSRAT, PRI, )
    *z SI xs_ty		// type CTEXTWALL, CTINTWALL, CTWINDOW, CTMXWALL, CTPERIM, CTKIVA set by cult or code.

	// inputs.  *r's where set by topCkf in at least some cases.
    *r AREA_GZ xs_area	// (net) area, sf.  Reflects window multiplier.
    *r ANGLE azm 		// azimuth (radians, 0 = North, Pi/2 = East)
    *r ANGLE tilt 		// tilt (radians, 0 = horiz up, Pi/2 = vert.
    *r *array 3 FLOAT xs_dircos	// outward normal direction cosines for given azm/tilt
    *r FLOAT_GEZ xs_depthBG	// depth below grade of bottom of wall, ft
    *r FLOAT_GEZ xs_height	// height of surface, ft (currently only used for Kiva)
    *z SFMODELCH xs_model	// surface model: user input
							//   quick/auto/delayed(massive)/delayed_hour/delayed_subhour/forward_difference/kiva
    *r SFMODELCH xs_modelr	// resolved to quick (runtime XSURF generated),
    						//    or to delayed_hour or _subhour (runtime MASS generated)
							//    or to kiva (runtime KIVA generated)
    *r FLOAT xs_lThkF		// thickness factor, adjusts max thickness allowed for mass sublayers
							//    default = 0.5
	*declare "class FENAW* xs_pFENAW[ 2];"	// re ASHWAT xs_fenModel: ASHWAT data shades open/closed
											//   else NULL

    *r TI gti		// window glazeType subscript. Used at runtime re incidence angle.
    *mh FRAC sco    // window: SMSO: Solar Heat Gain Coef multiplier, shades Open
    *mh FRAC scc    // window: SMSC: Solar Heat Gain Coef, shades Closed
    *r *nest SBC xs_sbcI	// inside (zone side) surface boundary conditions
    *r *nest SBC xs_sbcO	// outside (ambient or adjacent zone) surface boundary conditions

    *i FENMODELCH xs_fenModel	// fenestration model: user input
    *i FRAC xs_SHGC				// rated SHGC of assembly
    *r FLOAT_GEZ xs_fMult		// window frame/mullion multiplier (input or from GT)
    *i UH_GZ xs_UNFRC			// overall U-factor evaluated under per NFRC heating conditions
    *i SI xs_NGlz				// # of glazings bare-glass assembly
	*i EXSHDCH xs_exShd		// exterior shade (ASHWAT only)
	*i INSHDCH xs_inShd		// interior shade (ditto)
    *r FLOAT_GEZ xs_dirtLoss	// window dirt loss factor (input or from GT)

    // next 3 are input for surface, copied from surface of door or window
    *r EXCNDCH sfExCnd	// adjacent cond: adiabatic/ambient/specT/adjZn.
    *s TEMP sfExT    	// outside temp if .sfExCnd==C_EXCNDCH_SPECT
    *i TI sfAdjZi  		// zone for sfExCnd==ADJZN, or 0 for exterior surface/door/window.
    *r UH_GZ uI			// interior surf (air film) conductance. input.
    *r UH_GZ uC			// uval of construction, excl surfaces (air films). From CON, GT, or SFI.sfU user input.
    *r UH_GZ uX			// exterior surface (air film) conductance. input.
    *r FLOAT xs_Rf		// exterior roughness factor, re convection (new 10-10)
						//   default: windows=1, all others=2.17
    *mh FRAC grndRefl	// ground reflectivity, default: wall: Top.grndRefl; door/win: owning wall.

// view factors for diffuse (only) radiation so user can precompute shading effects of window overhang/fins
    *mh FRAC vfSkyDf	// sky view factor for diffuse solar, default .5 + .5*cos(tilt)
    *mh FRAC vfGrndDf	// ground view factor for diffuse solar, default .5 - .5*cos(tilt)

// view factors re outside surface LW (thermal) radiant exchange
    *r FRAC vfSkyLW		// sky view factor for long-wave radiation, hard-coded .5 + .5*cos( tilt)
    *r FRAC vfGrndLW	// ground view factor for long-wave radiation, hard-coded .5 - .5*cos( tilt)

    *r UH_GZ xs_uval 	// Overall air-to-air conductance, Btuh/sf-F
						//   includes uX and uC surf cond

						// *Nominal* U-factor etc including ASHRAE heating surface resistance
						// documentation only!
    *r UH_GZ xs_UNom		// nominal air-to-air U-factor, Btuh/sf-F
    *r UA xs_UANom			// area * xs_UNom, Btuh/F
							// surface values, [0]=inside, [1]=outside
    *r *array 2 FLOAT xs_rSrfNom;	// surface resistance sf-F/Btuh
    *r *array 2 FLOAT xs_hSrfNom;	// surface conductance (1/xs_rSrfNom), Btuh/sf-F

    *r UH_GZ xs_cFctr	// surface-to-surface conductance (not populated!)

    *r TI iwshad 		// 0 if none or subscr in WSHADRAT of overhang/fin info for a shaded window
    *r TI xs_msi		// 0, or mass (MsR) subscript for CTMXWALL.
    *array XSMXTLRB *h *e
		FLOAT xs_tLrB	// layer boundary temps re probes
						// populated at end of hour

// solar gain distributions: [partly] based on SGDIST inputs
    *r SI nsgdist	 		// Number of SG distributions
    // SGDIST sgdist[ HSMXSGDIST]:
    *array HSMXSGDIST	// =8 (2-95), cndefns.h. explicit solar gain distribs
       *r			// min variation here: no members set at input time
       *nest SGDIST sgdist	// solar gain distribution (struct just above).  set: cncult3.cpp:cnuSgDist().
*END		// XSURF
//=============================================================================
RECORD PRI "perimeter" *RAT	// perimeter input RAT

	*excon
	*ovrcopy
	*declare "RC pr_Ckf( int options);"
	*declare "void FixUp();"	// virtual fixup after basAnc reAl
								// .ownTi (base class) is zone subscript
    *r *hide *noname *nest XSURF x	// hs info (struct above).
    						// *hide and *r as contains no input members (except .ty -- probe unlikely).
    *i LEN_GZ prLen			// length. input.
    *i F2_GZ prF2			// conduction per unit length. input.
    *r TI xi				// subscript in runtime XSURF rat, to facilitate access by probers 1-92
*END		// PRI
//=============================================================================
RECORD SFI "surface" *RAT	// opaque surface / door / window input info RAT
	*prefix sf_
	*excon		// explicit constructor
	*exdes		// explicit d'tor
	*ovrcopy
	*declare "virtual SFI& CopyFrom( const record* src, int copyName=1, int dupPtrs=0);"
	*declare "RC sf_TopSf1();"
	*declare "RC sf_CkfSURF( int options);"
	*declare "RC sf_CkfSURFGround( int options);"
	*declare "RC sf_CkfDOOR( int options);"
	*declare "RC sf_CkfWINDOW( int options);"
	*declare "RC sf_TopSf2();"
	*declare "RC sf_MakMs();"
	*declare "RC sf_SetupKiva();"
	*declare "int sf_IsWallBG() const;"
	*declare "int sf_IsFloorBG() const;"
	*declare "int sf_IsBG() const;"
	*declare "RC sf_BGWallSetup( class AR_MASSLAYER& arML);"
	*declare "RC sf_BGFloorSetup( class AR_MASSLAYER& arML);"
	*declare "RC sf_BGFinalizeLayers( class AR_MASSLAYER& arML, float RFilm, float RNom=-1.f);"
	*declare "static int sf_IsSubhrly( int m);"
	*declare "static int sf_IsDelayed( int m);"
	*declare "static int sf_IsKiva( int m);"
	*declare "static int sf_IsFD( int m);"
	*declare "int sf_IsChild() const;"
	*declare "SFI* sf_GetParent();"
	*declare "const SFI* sf_GetParent() const;"
	*declare "TI sf_GetZI( int si) const;"
	*declare "ZNR* sf_GetZone( int si) const;"
	*declare "RC Validate( int options=0);"
	*declare "void FixUp();"	// virtual fixup after basAnc reAl
	*declare "std::vector<TI> sf_sharedFndWalls;"

 //surface/door/window
    // .ownTi (base class) is zone for surface, or surface for window or door.
    //   CAUTION: ambiguous base
    *i *noname *nest XSURF x	// hs info (struct above)
    *i INT sfClass			// sfcNUL, sfcSURF, sfcDOOR, sfcWINDOW
    *i AREA_GZ sfArea   	// surface: gross area, net in x.xs_area.
    *i UH_GZ sfU			// uval input if no sfCon given (excl surf films)
    // sfInH, sfExH: input/default to x.uI, x.uX.
    *i TI sfCon 			// surface construction (optional)
    // sfInAbs, sfExAbs: input/default to x.xs_AbsSlr(0, 1)
 //surface only
    *z OSTYCH sfTy 			// wall/floor/ceil/[intmass1/2]: for input cking.
    *i TI sfFnd 			// surface foundation object (floors only, optional)
    *i TI sfFndFloor		// surface foundation floor object (walls only, optional)
	*i LEN sfExpPerim		// foundation floor exposed perimeter (floors only)
 //window only
    *i LEN_GZ sf_width 		// width and height: used to compute shading,
    *i LEN_GZ sf_height		//  ... and to compute area b4 mutliplier.
    *i FLOAT_GZ mult		// area multiplier (for multiple identical windows)
 //derived/internal
    *r TI xi		// subscript in runtime XSRAT, to facilitate access by probers 1-92
    *r TI sf_msi	// 0 or MSRAT MsR subscr which will be used if delayed model
		    		// (must be known eg for sgdists b4 MsR record can be made eg because net area must be known)
*END		// SFI
//=============================================================================
RECORD XSRAT "xsurf" *RAT

	// runtime XSURFs (substruct above) for surfaces, doors, windows, perimeters, and mass outsides.
	// Each XSURF represents conductive/radiant coupling to ambient of exterior surface(s).  More comments above.

	*excon		// explicit constructor
	*exdes				// d'tor
	*ovrcopy
	*declare "RC Validate( int options=0);"
	*declare "void FixUp();"	// virtual fixup after basAnc reAl
	*declare "void xr_SGAccumAbsTrans();"
	*declare "void xr_SGFInit();"
	*declare "void xr_SGFAccum( const double sgf[ sgcCOUNT]);"
	*declare "void xr_SGIncTrans( int sunup, float verSun);"
	*declare "void xr_SGMakeSGRATs();"
	*declare "class Kiva::Aggregator* xr_kivaAggregator;"
    *declare "RC xr_ApplyKivaResults();"
    *declare "RC xr_KivaZoneAccum();"

				// .name: is that of of surface, door, window, perimeter, or mass (see x.ty) 1-92
				// .ownTi: ZNR subscript
    *r TI nxXsurf		// 0 or XSRAT subscr of next record for zone.  Chain head is ZNR.xsurf1.
    *r TI nxXsSpecT		// addl chain of records w/ x.sfExCnd==C_EXCNDCH_SPECT: used hourly.  Head is ZNR.xsSpecT1.
    *r *noname *nest XSURF x	// substruct above.  Omit "x." from probe names.  merge variation bits with members.
*END		// XSRAT
//=============================================================================
RECORD WSHADRAT "shade" *RAT		// shading info
	/* each entry holds info re a window's overhang, left fin, & right fin, & win's ht/wid (not needed except re shading).
	   WSHADRAT entries are accessed via subscript in .iwshad in shaded window's XSURF (in ZNR's component chain). */

  *declare "float SunlitFract( float gamma, float cosz) const;"
  // .ownTi (base class) is window subscript
  // all following members are inputs, set by cncult.cpp
    *r  LEN_GZ wWidth	// Window width.  *r: set (from window) by input check/setup (topCkf).
    *r  LEN_GZ wHeight	// Window height
    *mh LEN ohDepth  	// Depth of overhang.  *mh: may change monthly-hourly: m-h user exprs accepted.
    *mh LEN ohDistUp   	// Distance from top of window to bot of OH
    *mh LEN ohExL    	// Overhang extension beyond left edge of window
    *mh LEN ohExR    	// Ditto right edge
    *mh LEN ohFlap   	// Len of flap hanging down from front of overhang
    *mh LEN lfDepth  	// Left fin depth
    *mh LEN lfTopUp    	// Left fin top of window to top of fin
    *mh LEN lfDistL    	// Left fin distance to left edge of window
    *mh LEN lfBotUp    	// 	Left fin bottom to window bottom distance
    *mh LEN rfDepth	    // 	Right fin values analogous to left
    *mh LEN rfTopUp     // 
    *mh LEN rfDistR     // 
    *mh LEN rfBotUp     // 
*END		// WSHADRAT
//=======================================================================================
RECORD MASSBC "massbc sub" *SUBSTRUCT	// MASSBC: boundary conditions substruct for MSRAT.inside and .outside
// Note: some values are for unit area and other are for actual mass area.
// inputs. next 7 set by cncult3:makMs().
	*prefix bc_
	*declare "RC bc_Setup( int msi, int _ty, int si);"

	*r TI bc_msi		// parent mass subscr
    *r SI bc_ty 		// Bound cond type: MSBCADIABATIC, MSBCAMBIENT, MSBCGROUND, MSBCZONE, or MSBCSPECT.
    *r TI bc_zi 		// Zone sbscr if .bc_ty == MSBCZONE.
    *h FLOAT bc_exTa	// adjacent air temp, F
						//   if MSBCSPECT, set by user input (often expression)
						//   else set to ambient, zone, etc. per bc_ty
	*h FLOAT bc_exTr	// adjacent radiant temp, F
    // Solar must pass thru rsurf.  Conduction thru rsurf in series with surf film = h.
    *r FLOAT bc_rsurf 	// extra surf resis, from masstype, for "light" surf lyrs eg carpet: res for solar to 1st hvy lyr.
    *r FLOAT bc_h		// combined surface conductance, air to 1st "heavy" layer (Btuh/ft2-F)
						//   = surface conductance combined w .rsurf.
    *r FLOAT bc_ha		// bc_h * area, Btuh/F

// runtime - solar gain setup - temps used while computing 1 hour for month
    #define OC 2		// shades Open/Closed array dimension. subscripts: 0 = open, 1 = closed.
    *h RIGTARG rIg  	// radiant internal gain target (float) (Btuh). Pointed to by ZNR.rIgDist; set/used in cnloads. 11-95
  // next 6 for reports and energy balance check.
    // these are 0'd at start hr/day/month then accumulated to, so only valid at end interval: *e: usable in reports.
    // for general probability would need "prior" copy, not *e, always valid prior day/month value.
    *h *e DBL qxhnet	// Net heat xfer for hour (Btu, + = into mass): signed sum of all transfers.
    *d *e DBL qxdnet 	// ... ditto current day
    *m *e DBL qxmnet 	// ... ditto current month
    *h *e DBL qxhtot 	// Total xfer for hour (Btu): sum of abs(xfer).  Used as divisor for determining relative error.
    *d *e DBL qxdtot 	// ... ditto current day
    *m *e DBL qxmtot 	// ... ditto current month
  // for probe-ability (can't probe thru pointer MSRAT.temp[]) 1-19-94
    *s *e FLOAT bc_surfTemp	// probe-able duplicate copy of inside or outside layer surface temp, set in loadsSurfaces.

*END		// MASSBC

//=======================================================================================================
RECORD MSRAT "mass" *RAT 	// Masses run rat
	*prefix ms_
	*exdes				// d'tor
	*ovrcopy
	*declare "ZNR* ms_GetZone( int si) const;"
	*declare "void ms_RddInit( double t);"
	*declare "void ms_StepMX( float dur, float tDbO);"
	*declare "void ms_StepFD();"
	*declare "double ms_InternalEnergy() const;"
	*declare "int ms_IsMassless() const;"
	*declare "inline int ms_NLayer() const;"
	*declare "RC ms_SetMSBCTNODE( int erOp=WRN);"
	*declare "void DelSubObjects( int options=0);"
	*declare "RC ms_Make( SFI* sf, const CON* con, int options=0);"
	*declare "const SFI* ms_GetSFI() const;"
	*declare "const XSRAT* ms_GetXSRAT() const;"
	*declare "XSRAT* ms_GetXSRAT();"
	*declare "void ms_BegIvl( int ivl);"
	*declare "void ms_EndIvl( int ivl);"
	*declare "void ms_QXSurf( int ivl, double& qxNet, double& qxTot) const;"
	*declare "RC ms_Enbal( int ivl, float tol, double& ovNet, double& ovTot);"
	*declare "const char* ms_SurfBCDesc( int si) const;"

	*r TI ms_sfi			// associated surface subscript
	*r INT ms_sfClass		// associated surface class (sfcSURF or sfcDOOR)
	*r TI ms_xri			// XSRAT subscript: ditto
	*r FLOAT ms_area		// area, ft2
	*r BOO isSubhrly		// TRUE iff this mass simulated subhourly (else hourly)
	*r BOO ms_isFD			// TRUE iff this mass used forward-difference model (always subhourly)
	*r *nest MASSBC inside  // inside surface boundary conditions
	*r *nest MASSBC outside // outside...
	*r UH_GZ ms_UNom   		// overall uval incl nominal surface films, Btuh/ft2-F
							//   used for reporting only
	*r FLOAT ms_tc 			// time constant (con->hc/sfInH) as used to default sfModel & isSubhrly, for reporting, 1-95

	// re-work interval energy balance info, 2-3-2012
	// *h *e DBL ms_qBal		// total hour energy balance error for this mass, Btu
	*h *e *hide *array IVLDATADIM DBL ms_qBal		// net energy balance during interval, Btu
	*declare "double& ms_QBal( int ivl) { return IvlData( ms_qBal, ivl); }"
	*h *e *hide *array IVLDATADIM DBL ms_qIE		// internal energy at beg of interval, Btu
	*declare "double& ms_QIE( int ivl) { return IvlData( ms_qIE, ivl); }"
	*h *e *hide *array IVLDATADIM DBL ms_qIEDelta	// internal energy change during interval, Btu
	*declare "double& ms_QIEDelta( int ivl) { return IvlData( ms_qIEDelta, ivl); }"
	*h *e *hide *array IVLDATADIM INT ms_flags	// flag values (e.g. msfNOBAL)
												//   out of service 2-2012, retain for future
	*declare "int& ms_Flags( int ivl) { return IvlData( ms_flags, ivl); }"
   	*s *e *hide INT ms_ebErrCount	// count of short-interval (day/hour/subhour) energy balance errors
									//   detected for this zone; s/b 0; used to suppress excessive msgs

	*r MASSMODELP ms_pMM	// pointer to runtime mass model for this mass (type determined per input)
							//   see mspak.h

*END			// MSRAT

//=======================================================================================================
RECORD KIVA "kiva" *RAT 	// Kiva instance run rat
	*prefix kv_
	*exdes				// d'tor
	*declare "ZNR* kv_GetZone() const;"
	*declare "RC kv_Create();"
	*declare "RC kv_RddInit();"
	*declare "RC kv_SetInitBCs(DOY jDay);"
	*declare "RC kv_SetBCs();"
	*declare "RC kv_Step(float dur);"

	*declare "class Kiva::Instance* kv_instance;"
	*declare "std::vector<TI> kv_walls;"

	*r TI kv_floor				// floor reference
	// list of wall references
	*r FRAC_GZ kv_perimWeight	// weight of this kiva instance for results of corresponding floor

*END			// KIVA


//=============================================================================
RECORD SGI "sgdist" *RAT		// solar gain distribution info during input

			// .ownTi (base class) is window subscript

    *i SIDECH sgSide	// C_SIDECH_INTERIOR or _EXTERIOR - side rcving gain
    *i *noname *nest SGDIST d	// solar gain distrib info: targTy, targTi, f.
		// d.targTi is that of surface
*END		// SGI
//=============================================================================
RECORD SGRAT "solarGain" *RAT *hideall		// HIDE 1-92 due to doubts about whether *m will work for it
	// Greater probe problem later 1-92: all rat members alloc/set AFTER expression time (makHrSgt).
	// ye olde question: should we use *e and/or a .prior (ZNR note 1), plus may be unalloc at start interval.
	// SOLAR GAINS runtime info to combine with weather data to get hour's
	//    solar gain to one particular target.
	// An entry is valid for one month (sun's position changes) [and season (window shuttering can change)].
	// A window with adjustable shades uses 2 entries
	//    2nd with .sg_pControl = &ZNR.znSC and (usually) neg factors for gain reduction when shut.
	// Set up in cgsolar.cpp
	*prefix sg_
	*declare "void sg_ToTarg( float bmRad, float dfRad);"
	*declare "void sg_DbDump() const;"
    *mh *e SI sg_addIt	// 0 to store gain to init targ, nz to add to target (additional entry for same targ)
    SGTARGP sg_pTarg	// where to add gain -- zone or surface
    BOO sg_isSubhrly	// non-0 for subhourly target, 0 for hourly
  #ifdef SOLAVNEND		// undef in cndefns.h (via cnglob.h) 1-18-94: only if computing & using end-ivl as well as ivl avg solar values
  o  BOO sg_isEndIvl	// non-0 to use end-interval value (zones) not interval average value (masses)
  #endif
    FLOATP sg_pControl	// &0..1.f to multiply gain, or NULL to use 1.0
								// standard time hourly factors
									// = Btuh to target per unit weather file irrad (Btuh/ft2)
    *mh *e *array 24 DBL sg_bmXBmF	//    beam per unit beam
    *mh *e *array 24 DBL sg_dfXBmF	//    diffuse per unit beam (e.g. ground reflected)
    *mh *e *array 24 DBL sg_dfXDfF	//    diffuse per unit diffuse
	    			// These reflect size/orientation of surfaces/windows and are
	    			// merged (summed) in cgsolar.cpp for all that have same sg_targ and sg_control.
*END		// SGRAT

//=============================================================================
RECORD GT "glazeType" *RAT	// glazing type input or run info

	*declare "int gt_IsASHWAT() const { return gtFenModel == C_FENMODELCH_ASHWAT; }"
 //input. also .name (base class) is required.
    *i  FRAC gtSHGC		// rated SHGC of assembly
    *mh FRAC gtSMSO		// optional solar heat gain coef multiplier, shades open, used if not spec'd in window, dflt 1.0.
    *mh FRAC gtSMSC		// ditto shades closed, defaults at window level.
    *i FLOAT_GEZ gtFMult   	// optional frame/mullion multiplier for use when not spec'd in window. constant.
    *i *nest PY4 gtPySHGC	// beam SHGC incidence angle multiplier: 4th-order polynomial in cosine of angle.
    						//   4 inputtable coefficients (no constant). .val1(x) returns value.
    *i FRAC gtDMSHGC	// diffuse SHGC multiplier used (in place of polynomial). RQD. constant.
    *i FRAC gtDMRBSol	// reflectance for diffuse solar on inside of glass, for Cavity Absorptance calc'ns (cgsolar.cpp).
    *i UH_GZ gtU		// optional u-value for use when not spec'd in window. contant.
    *i UH_GZ gtUNFRC	// overall U-factor evaluated under per NFRC heating conditions
    *i SI gtNGlz		// # of glazings bare-glass assembly
    *i FENMODELCH gtFenModel	// fenestration model: user input
								//   SHGC or ASHWAT (added 11-8-2010)
	*i EXSHDCH gtExShd			// exterior shade (ASHWAT only)
	*i INSHDCH gtInShd			// interior shade (ditto)
	*i FLOAT_GEZ gtDirtLoss		// dirt loss fraction (all solar gain reduced by this factor
*END		// GT
//=============================================================================
RECORD CON "construction" *RAT	// construction (of surface or door) input info
    *declare "RC cn_Layers( class AR_MASSLAYER& arML, int options=0) const;"
    *declare "int cn_IsFramed() const {	return nFrmLr > 0; }"
 //input.  also .name (base class) is required.
    *i UH conU		// U-value.  Entered by user or calculated from associated layers (LRs).  0 allowed.
 //derived
    *r SI nLr		// 0 or number of layers (in LR rat). Layers are entered in order from inside out.
    *r SI nFrmLr   	// # framed layers: error if > 1; is-Framed flag.
    *r RES_GZ r		// thermal resistance of layers accumulated here for conU
    *r HC_AREA hc   	// accumulated heat capacity per square foot
    *r RES_GZ rNom   	// nominal r value
*END		// CON
//=============================================================================
RECORD LR "layer" *RAT	// layer input info.  Layers for a given construction are entered in order from inside out.
	*prefix lr_

    *declare "RC lr_TopLr();"

// input.  Also .ownTI (base class) is owning CONstruction subscript.
    *i LEN_GZ lr_thk	// thickness of layer, ft. dfl mt_thk else RQD. *i cuz VEOI in cncult:lrT[].
    *i TI lr_mati		// primary material (MAT subscript). RQD.
    *i TI lr_frmMati	// framing material in layer, 0 if unframed layer
    *i FRAC lr_frmFrac	// fraction framing in layer. RQD if lrFrmMati nz.
 //derived:
    *r CNDVY_GZ lr_uvy	// conductivity: weighted combo of pri & framing; NOT specific to thickness.
    *r RES_GZ lr_r		// layer r-value (for thk, per ft2)
    *r HC_VOL lr_vhc	// volumetric heat capac (dens*spHt, framing-weighted)
*END		// LR
//=============================================================================
RECORD MAT "material" *RAT	// material (for construction layer) input info
*prefix mt_
*declare "static double mt_CondT( float T, float kRtd, float kCT, float kTRat)"
*declare "{	return max( .001, kRtd*(1.+kCT*(T-kTRat))); }"
*declare "double mt_CondT( float T) const"
*declare "{ return mt_CondT( T, mt_cond, mt_condCT, mt_condTRat); }"
*declare "static void mt_CondAB( float kRtd, float kCT, float kTRat, double& A, double& B)"
*declare "{	A = mt_CondT( 0.f, kRtd, kCT, kTRat); B = kCT*kRtd; }"
*declare "void mt_CondAB( double& A, double& B) const"
*declare "{	mt_CondAB( mt_cond, mt_condCT, mt_condTRat, A, B); }"

 //input.  *i's cuz VEOI's in cncult.
    *i LEN_GZ mt_thk    	// -1 or optional default thickness, ft
    *i CNDVY_GZ mt_cond 	// conductivity, Btuh-ft/ft2-F (at mt_condTRat)
    *i FLOAT mt_condTRat	// rating temp for mt_cond, F (typically 70 F)
    *i FLOAT mt_condCT		// conductivity temp coefficient, 1/F
							//   condAtT = mt_cond*(1 + mt_condCT*(T - mt_condTRat)
    *i SPECHEAT mt_spHt 	// specific heat, Btu/lb-F
    *i DENSITY mt_dens  	// 0 (massless) or density, lb/ft3
    *i RESVY_GZ mt_rNom 	// nominal R of insulation, ft2-F/Btuh-ft
							//  = resistance of 1 ft2 per ft thick.
							//  documentation only (typically round number, e.g. 13)
							// -1 = not given
	// derived.  *r: set in input check/setup.
    *r HC_VOL mt_vhc  		// volumetric heat capac (Btu/ft3-F): mt_spHt*mt_dens
*END		// MAT

//=============================================================================
RECORD FOUNDATION "foundation" *RAT	// foundation input info
*prefix fd_
*declare "class Kiva::Foundation* fd_kivaFnd;"
*declare "RC fd_SetupKiva();"

 //input
 *i LEN fd_wlHtAbvGrd		// Height of foundation wall above grade
 *i LEN fd_wlDpBlwSlb		// Depth of foundation wall below the slab
 *i TI fd_ftWlConi			// Foundation wall construction (CON subscript) RQD if
							// no walls associated with this foundaiton
							// (i.e., it is a slab)

*END		// FND

//=============================================================================
RECORD FNDBLOCK "foundationBlock" *RAT	// foundation component input info
*prefix fb_

 //input
 *i TI fb_mati				// Material (MAT subscript) for this component
 *i FBXREFCH fb_x1Ref		// Point 1 X reference
 *i FBZREFCH fb_z1Ref		// Point 1 Z reference
 *i FLOAT fb_x1				// Point 1 X value (relative to reference)
 *i FLOAT fb_z1				// Point 1 X value (relative to reference)
 *i FBXREFCH fb_x2Ref		// Point 2 X reference
 *i FBZREFCH fb_z2Ref		// Point 2 Z reference
 *i FLOAT fb_x2				// Point 2 X value (relative to reference)
 *i FLOAT fb_z2				// Point 2 X value (relative to reference)

*END		// FDC

//========================================================================================================
RECORD RFI "reportFile" *RAT	// REPORTFILE (RfiB) and EXPORTFILE (XfiB) (.what altered) input records.
    *exdes						// cncult4.cpp: frees .fileName
    *ovrcopy
	*declare "RC rf_CkF( int isExport);"
	*declare "RC rf_CkF2( int isExport);"
    *declare "RC rf_CheckForDupFileName();"
	*declare "int rf_CheckAccessAndAlias( const char* fName, char* &fNameAlias, const char** ppMsg=NULL);"
 //input
    *i CHP fileName		// file name, path optional, in dm (or pseudocode, but not "text").  *i cuz VEOI in cncult.
    *r FILESTATCH fileStat	// fresh(overwrite,default)/new(err if exists)/append
    *i NOYESCH pageFmt  	// page formatting on no/yes
 //derived
    *r SI fileStatChecked	// check fileStat only once to prevent "file exists" error or re-setting "overWrite" on later run
    *r SI overWrite			// append if 0.  set by fileStat=fresh, cleared on use, so addl runs do not erase earlier output.
	*r SI wasNotEmpty			// nz if existed and size > 0 at fileStat check
*END		// RFI
//=============================================================================
RECORD RI "report" *RAT	// REPORT (RiB) and EXPORT (XiB) (.what altered) input records
    *prefix ri_
    *exdes						// cncult4.cpp: frees .rpTitle
    *ovrcopy
	*declare "RC ri_CkF();"
	*declare "RC ri_oneRxp();"
 //input                .ownTi is owning reportFile or exportFile subscript
    *i TI zi 		// zone for zone-specific reports. Can be TI_SUM, TI_ALL.
    *i TI mtri		// meter to report/export for meter-specific reports. Can be TI_SUM, TI_ALL.
    *i TI ahi		// air handler to report/export for air-handler-specific reports. Can be TI_SUM, TI_ALL.
    *i TI tui		// terminal to report/export for terminal-specific reports. Can be TI_ALL
    *i TI ri_dhwMtri// DHW meter to report/export for DHW meter-specific reports. Can be TI_ALL.
    *i TI ri_afMtri	// Air flow meter to report/export for AF meter-specific reports. Can be TI_ALL.
    *i BOO isExport	// 1 if export not report, so same fcns can be used with RiB and XiB records
    *z RPTYCH rpTy 	// report/export type C_RPTYCH_EB etc
    *z IVLCH rpFreq	// r/xport frequency C_IVLCH_M etc
    *i DOY rpDayBeg	// start 1-based Julian day of year, where applicable
    *i DOY rpDayEnd	// end ..
    *i FLOAT_GZ rpBtuSf	// energy (Btu) scale factor
    *s *e LI rpCond	// condition: if given, rpt lines omitted when FALSE (SI; LI used to hold NAN) (LI currently unprobeable)
    *i CHP rpTitle 	// title, for UDT, in dm
    *i SI rpCpl		// chars per line, inputtable re UDT's (default -1="as wide as needed")
    *i RPTHDCH rpHeader	// table header or export header yes/no (default yes)
    *i NOYESCH rpFooter	// table footer (summary line) or export footer (just blank line?) yes/no (default yes)
    *hide *r SI putAtEnd	// used internally to make pre-stuffed LOG report follow user reports
 //user-defined report columns
    *r TI coli		// RcolB/XcolB subscript of first column (thence linked by .nxColi).
    *r SI nCol		// # columns
    *r SI wid		// total col width for user-defined report
 //generated
    *r INT vrh		// assigned virtual report handle, used from here to build UnspoolInfo.
*END		// RI
//=============================================================================
RECORD COL "reportCol" *RAT	// holds info for columns in user-defined table reports and exports
					// for report input rat (RcoliB) and run rat (RcolB)
					// and export input rat (XcoliB) and run rat (XcolB) (.what fudged at runtime)
    *excon
    *exdes
    *ovrcopy
    *declare "virtual record& CopyFrom( const record *src, int copyName=1, int dupPtrs=0);"
	*declare "virtual RC Validate( int options=0);"

 //input		.ownTi is RI subscript of owning report/export.   Column order is order of input.
    *i CHP colHead  	// column head string, in dm.  *i cuz VEOI in cncult.cpp:rpColT[].
    *i SI_GEZ colGap	// space to left of column, default 1
    *i SI colWid	// column width
    *i SI colDec	// colDecimals: max digits after point
    *i JUSTCH colJust	// justification: C_JUSTCH_L or _R
    *s *p VALNDT colVal	// value .val and data type .dt (TYFL/TYSTR in input, DTFLOAT/DTCHP in run), used at end report interval.
 //derived
    TI nxColi		// for runtime: COL subscript of next column in this report, 0 if last one
*END		// COL
//=============================================================================
RECORD DVRI "dvri" *hideall *RAT	// Date-dependent Virtual Report Info -- at runtime (DvriB)
	*prefix dv_
    *exdes		// cncult4.cpp. frees rpTitle
	*ovrcopy
	*declare "void dv_vpDHWMtrRow( RXPORTINFO *rxt, TI dhwMtri=-1);"
	*declare "void dv_vpAfMtrRow( RXPORTINFO *rxt, TI afMtri=-1);"
    *declare "bool dv_IsReportActive( DOY jDay) const;"

  // from inputs to RiB/XiB		.ownTi is zone subscript or TI_SUM or ?TI_ALL.
    *r TI mtri			// meter to report/export. can be TI_SUM, TI_ALL.
	*r TI dv_dhwMtri	// DHW meter to report/export.  can be TI_ALL.
	*r TI dv_afMtri		// AF meter to report/export.  can be TI_ALL.
    *r TI ahi			// air handler to report/export. can be TI_SUM, TI_ALL.
    *i TI tui			// terminal to report/export for terminal-specific reports. Can be TI_ALL. 6-95.
    *r BOO isExport 	// non-0 if export not report (rpTy values are shared)
    *r BOO isAll		// non-0 if All- (zones, meters, etc) report
    *r RPTYCH rpTy 		// report/export type: C_RPTYCH_EB, _UDT, etc
    *r IVLCH rpFreq		// r/xport frequency C_IVLCH_MON etc
    *r DOY rpDayBeg		// start 1-based Julian day of year
    *r DOY rpDayEnd		// end ..
    *r float rpBtuSf	// energy (Btu) scale factor
    *s LI rpCond 		// condition: if given, report lines omitted when FALSE (SI; LI used to hold NAN for expression)
    *r SI rpCondGiven	// nz if user-given condition: may be reflected in title (when 0, rpCond is TRUE).
    *r CHP rpTitle 		// title, for UDT, in dm
    *r SI rpCpl			// chars per line, inputtable for UDT's
    *r RPTHDCH rpHeader	// table header or export header yes/no/col (default yes)
    *r NOYESCH rpFooter	// table footer (summary line) or export footer (just blank line) yes/no (default yes)
  // user-defined reports columns
    *r TI coli			// RcolB/XcolB subscript of first column (thence linked by .nxColi).
    *r SI nCol			// # columns
    *r SI wid			// total col width for user-defined report, including colGaps.
						// generated
    *r INT vrh			// virtual report handle, used from here for runtime output
						//   linking
    *d TI nextNow  		// 0 or subscript of next report/export of this type that is active today
    					//  (list headed by Top.drviY, -M, D, H, HS, S updated daily so don't need to search subHourly)
*END		// DVRI
//=============================================================================
RECORD IMPF "importFile" *RAT	// IMPORTFILE input (Impfib) and run (ImpfiB) records
    *exdes					// destructor (cncult4.cpp) frees heap items
    *ovrcopy
    *declare "BOO FC scanHdr();"		// impf.ccp member fcns
    *declare "BOO FC readRec();"
    *declare "BOO FC scanNextField();"
    *declare "BOO    scanField( char *&p, char *&start);"
    *declare "BOO FC readBuf();"
    *declare "void FC close();"
    *declare "void FC fnrtAl(SI nNfnr);"
 //input. name is required.
    *f CHP fileName			// file name, path optional, in heap or pseudocode. *i cuz VEOI in cncult. RQD.
    *f CHP imTitle			// title string. If given, file's must match.
    *z SI imPhaseSpare		// for possible future AUTOSIZE/MAINSIM/BOTH choice 6-95
    *i IVLCH imFreq			// frequency of record reads, Y M D H; HS and Subhour not allowed. RQD.
    *f NOYESCH hasHeader	// file has header no/yes, default yes.
    *i *hide NOYESCH imBinary	// possible future binary file option. default no.
 //derived during input processing
    *r TI iffnmi			// subscript of import file field record in IffnmB. Holds used names b4 file opened;
							// used for runtime access to IMPF record to handle forward references
 //runtime
    //file
    *r BOO isOpen		// non-0 if file is open and buffer has been allocated successfully
    *r SI fh			// file handle. CAUTION: initial value, 0, is a valid file handle.
    *r LI posEndHdr		// file pointer after header, for repositioning file after warmup
    //buffer
    *r *hide CHP buf		// file buffer, in heap
    *r USI bufSz		// 0 or allocated size of buffer (actually 1 larger to hold \0)
    *h USI bufN			// number of characters in buffer === subscript of 1st unused byte
    *h BOO eofRead		// TRUE after end file has been input to buffer (unused records may remain in buffer)
    *h BOO eof			// TRUE after last record has been used
    *h USI bufI1		// buffer subscript 1: start or next unscanned field in current record
    *h USI bufI2		// buffer subscript 2: end current record. ==bufI1 if no current record.
    *h USI lineNo		// 1-based line number (\n count) in file
    *r USI lineNoEndHdr		// lineNo corresponding to posEndHdr
    *h *e SI nFieldsScanned	// 0 or number of fields already scanned in current record
    *h *e BOO eorScanned	// non-0 if all fields in record have been scanned
    //fields-by-number info. IFFNM.fnmt[] used to get #'s of named fields at runtime.
	*declare "struct FNRT* fnrt;" // ptr to heap array of info subscripted by 1-based field number.
    *r *hide USI fnrtNAl 	// allocated size of .fnrt[]. Max subscript fnrtNAl-1; [0] unused.
*END		// IMPF
//=============================================================================
RECORD IFFNM "impFileFldNames" *RAT	// IMPORT FILE FIELD NAMES TABLE (IffnmB) records
		/* Made when Import() fcn for file is seen.
		   When file with header is opened, field numbers for in names table are set,
		   then table is used during run to translate fnmi's to fnr's.
		   .fnmiN used during run to access IMPORTFILEs from IMPORT pseudo-code to handle forward references. */
    *exdes   						// free strings, also fnmt.
    *ovrcopy
    // name (base class) is set to that seen in import()s and used to match with IMPF record.
 //derived
    *i TI impfi			// 0 or subscript of IMPF record for file in ImpfiB/ImpfB
    //fnmt[]: array of info on fields ref'd by name, in order seen (before numbers known).
    // used at runtime to get fnr's to access fields. subscript: "fnmi", "field name index"
    *i SI fnmiN			// number of named fields seen for this file / max fnmi (+ 1 if 0-based)
	*declare "struct FNMT* fnmt;"	// pointer to field names info array in heap
    *i *hide SI fnmtNAl		// allocated size of fnmt. Max subscript fnmtNAl-1. [0] unused.
*END		// IFFNM
//===========================================================================================================
RECORD AUSZ "autoSizing sub" *SUBSTRUCT	// AUTOSIZING VARIABLES substructure for one autoSized member
						// uses include:  TU .hcAs .vhAs .vcAs;  AH .hcAs .ccAs .fanAs.
    *declare "int fazInit( float* xptr, BOO negFlag, record *r, SI fn, int isAusz);"
    *declare "void az_CallPVF( void( AUSZ::*pvf)(), const char* fmt, ...);"
    *declare "void rddiInit();"
    *declare "void begP1Dsd();"
    *declare "void begP1aDsdIter();"
    *declare "BOO resizeIf( float x, BOO goose);"
    *declare "BOO unsizeIf( float x);"
    *declare "void endP1a();"
    *declare "void begP1b();"
    *declare "void endP1bDsd();"
    *declare "void p2Init();"
    *declare "void begP2Dsd();"
    *declare "void begP2DsdIter();"
    *declare "void endP2Dsd();"
    *declare "void p2EndTest();"
    *declare "void afterP2EndTest();"
    *declare "void cvgTest();"
    *declare "void final( record* r, record* ir, float fOverSize);"
    // *declare "int az_Active() const { return az_active && az_px; }" idea

   //---setup time members
    *r BOO az_active		// TRUE iff autoSizing this member
   //---runtime
    // set at initialization
    *r *e *hide FLOATP az_px // pointer to value being autosized, set at beginning of autosize phase.
							// CAUTION: storing pointer presumes record won't move during run.
							// x is ASSUMED to be followed by:
							// float x_As:    receives x as autoSized, or user's x at end autoSize phase if not autoSized
							// float x_AsNov: rcvs x, w/o oversize factor if autoSized. Used in "sizing" reports, 7-95.
    *r *e *hide BOO isNeg	// non-0 for negative quantity
    // pass 1 part a: find size, simplified/idealized models.
    *s *e float az_a   		// 1a size (load) -- max of warmup-converged design days
    // pass 1 part b and pass 2: enlarge size if necess, real models.
    *s *e float az_b   		// 1b rated size plus increases during simulation incl pass 2 -- max of design days
    // for pass 2 (increase size if necess, measure load, reduce oversize sizes) and for main sim load reports
    *s *e float ldPk		// largest load this design day iteration or in main sim
    *d *e float ldPkAs		// autoSize peak load: max of warmup-converged design days
    *d *e float ldPkAs1   	// autoSize pass 1 peak load, re reporting overloads of devices that only
							//   exceed limit on pass 1, eg supply fan when sizing terminals, 7-6-95.
    *s *e float plrPk		// largest plr this design day iteration or in main sim
    *d *e float plrPkAs		// autoSize peak plr: max of warmup-converged design days
#if 1 // trial rob 6-17-97. Not sure needed (no magic effect; not sure x's ever reduced) but not harmful, rob 6-97.
    *s *e float xPk			// rated size (*px) when plrPk set
    *d *e float xPkAs		// rated size (xPk) when plrPkAs set - use when reducing oversize in case x has changed. 6-97.
#endif
    // internal temporaries
    *d *hide CHP az_doing	// optional desc of current action re Top.verbose > 2 display
							//    on stack or tmpstr, do not release
							//    NULL if not known
    *s *e *hide float az_e1	// two prior results for warmup convergence tests
    *s *e *hide float az_e2	// ..
    *s *e *hide float az_orig	// original value for no-change 1-iteration convergence test for part 1B;
    						    // also original value for small-change pass 2 outer endTest.

    // autoSizing results go in parent object to have desired probe names. Members assumed, TOGETHER, IN ORDER:
    //   *s *e float x		value being autoSized
    //   *f float x_As		autoSize result, with minimal variation for use in probes in main sim
    //   *f float x_AsNov	autoSize result before overSize applied, for "sizing" report
    // the values must be together cuz only one .px is used and for probe name lookup search to work right.
*END			// AUSZ
//=============================================================================
RECORD CONVERGER "converger sub" *SUBSTRUCT	// iteration convergence aid: extrapolates, binary searches value v

    *declare "CONVERGER( DBL _mxInc=1., DBL _mnMxInc=1.e-11, DBL _mnSigChg=1.e-4) { init(_mxInc, _mnMxInc, _mnSigChg); }"
									//constructor default-inits (non-record) uses, eg cncoil.cpp.
    *declare "void init( DBL _maxIncr=1., DBL _minMaxIncr=1.e-11, DBL _minSigChange=1.e-4);"	//optional (re)initializer, cnah1.cpp

    *declare "BOO doit( DBL &v, SI &nIter);"		//do it: call each iteration. cnah1.cpp.

    *s *e BOO isSetup    		// TRUE if init called since doit
    *s *e DBL minSigChange		// doit returns TRUE if it changes value more than this
    *s *e DBL minMaxIncr 		// 2 times smallest change to restrict v to in searching for solution
    *s *e DBL maxIncr			// current max change to allow in value
    *s *e DBL v2  DBL v1  DBL v0	// current (v0) and 2 previous values
    *s *e DBL d1  DBL d0   		// current (d0) and previous value deltas
    *s *e SI nRev  				// number of delta sign reversals (negative r's)
    *s *e SI nitSince			// number of calls since v altered
*END			// CONVERGER
//=============================================================================
RECORD AIRSTATE "AirState" *SUBSTRUCT
*prefix as_
*declare "AIRSTATE() {}"
*declare "AIRSTATE( const AIRSTATE& as) { as_tdb=as.as_tdb; as_w=as.as_w; }"
*declare "AIRSTATE( double tdb, double w) : as_tdb( tdb), as_w( w) { }"
*declare "void as_Init() { as_tdb=0.; as_w=0.; }"
*declare "void as_Set( double tdb, double w) { as_tdb=tdb; as_w = w; }"
*declare "void as_Set( const AIRFLOW& af);"
*declare "void as_SetWFromRh( float rh) { as_w = psyHumRat2( as_tdb, rh); }"
*declare "float as_Twb() const { return psyTWetBulb( as_tdb, as_w); }"
*declare "float as_Enthalpy() const { return psyEnthalpy( as_tdb, as_w); }"
*declare "float as_RelHum() const { return psyRelHum4( as_tdb, as_w); }"
*declare "float as_RhoDry() const { return psyDenDryAir( as_tdb, as_w); }"
*declare "float as_RhoMoist() const { return psyDenMoistAir( as_tdb, as_w); }"
*declare "double as_AddQSen( double q, double amf);"
*declare "double as_AddQSen2( double q, double amf);"
*declare "double as_QSenDiff2( const AIRSTATE& as, double amf) const;"
*declare "double as_AddQLat( double q, double amf);"
*declare "double as_AddDeltaT( double dt) { as_tdb += dt; return as_tdb; }"
*declare "int as_AddQSenLat( float& qSen, float& qLat, double amf, float rhMax=1.f);"
*declare "AIRSTATE& as_MixF( float f, const AIRSTATE& asX) { return as_MixF( f, asX.as_tdb, asX.as_w); }"
*declare "AIRSTATE& as_MixF( float f, double tdb, double w);"
*declare "int as_IsEqual( const AIRSTATE& as, double tol=.001) const;"
*declare "int operator==( const AIRSTATE& as) const { return as_IsEqual( as); }"
*declare "int operator!=( const AIRSTATE& as) const { return !as_IsEqual( as); }"
*declare "static double as_HXEff( double xSup, double xExh, double eff) { return (1.-eff)*xSup + eff*xExh; }"
*declare "int as_HX( const AIRSTATE& asSup, float amfSup, const AIRSTATE& asExh, float amfExh, float effS, float effL);"

*s *e DBL as_tdb			// air dry-bulb temp, F
*s *e DBL as_w				// air humidity ratio, lb moisture/lb dry air
*END		// AIRSTATE
//=============================================================================
RECORD AIRFLOW "AirFlow" *SUBSTRUCT *BASECLASS AIRSTATE
*prefix af_
*declare "AIRFLOW() : AIRSTATE(), af_amf( 0.) { }"
*declare "AIRFLOW( double amf, double tdb, double w) { af_Init( amf, tdb, w); }"
*declare "AIRFLOW( double amf, const AIRSTATE& as) { af_Init( amf, as.as_tdb, as.as_w); }"
*declare "double af_Tdb() const { return as_tdb; }"
*declare "double af_W() const { return as_w; }"
*declare "double af_Wmf() const { return af_amf*as_w; }"
*declare "void af_GetAirState( AIRSTATE& as) const { as.as_Set( as_tdb, as_w); }"
*declare "void af_SetAirState( const AIRSTATE& as) { as_Set( as.as_tdb, as.as_w); }"
*declare "void af_SetAirState( const AIRSTATE& as, float& qLat, float& qSen);"
*declare "void af_Init() { af_amf=0.; as_tdb=0.; as_w=0.; }"
*declare "void af_Init( double amf, double tdb, double w) { af_amf=amf;	as_tdb=tdb; as_w=w; }"
*declare "void af_Copy( const AIRFLOW& af){ af_amf=af.af_amf; as_tdb=af.as_tdb; as_w=af.as_w; }"
*declare "void af_Mix( const AIRFLOW& af);"
*declare "void af_AccumDry( double amf, double tdb, double w);"
*declare "void af_AccumDry( double amf, const AIRSTATE& as) { af_AccumDry( amf, as.as_tdb, as.as_w); }"
// tp_airSH (air specific heat) evaluated at tp_refW (reference humidity ratio)
*declare "void af_AccumMoist( double amf, double tdb, double w) { af_AccumDry( amf*Top.tp_refWX, tdb, w); }"
*declare "double af_AmfCp()  const { return af_amf*Top.tp_airSH; }"
*declare "double af_AmfCpT() const { return af_amf*as_tdb*Top.tp_airSH; }"
*declare "double af_QLat( double wx) const { return af_amf*(as_w - wx)*PsyHCondWtr; }"
*declare "double af_AddQSen( double q) { return as_AddQSen(q, af_amf); }"
*declare "double af_AddQSen2( double q) { return as_AddQSen2(q, af_amf); }"
*declare "double af_QSenDiff2( const AIRSTATE& as) const { return as_QSenDiff2(as, af_amf); };"
*declare "double af_AddQLat( double q) { return as_AddQLat(q, af_amf); }"
*declare "int af_AddQSenLat( float& qSen, float& qLat, float rhMax=1.f) { return as_AddQSenLat(qSen, qLat, af_amf, rhMax); }"
*declare "int af_HX( const AIRFLOW& afSup, const AIRFLOW& afExh, float effS, float effL) {af_amf = afSup.af_amf; return as_HX(afSup, afSup.af_amf, afExh, afExh.af_amf, effS, effL); }"

*s *e DBL af_amf		// mass flow rate, lb/hr dry air
// *s *e DBL as_tdb		// from AIRSTATE
// *s *e DBL as_w
*END		// AIRFLOW
//=============================================================================
RECORD FAN "fan sub" *SUBSTRUCT		// FAN SUBRECORD
//  Applications: air handler supply fan, air handler return fan, terminal fan,
//     zone exhaust fan, IZXFER fan
//  Fan schedules, where pertininent, are with each application.
*prefix fn_

*declare "RC fn_setup( FANAPPCH app, record *r, SI fanFn, float defVfDs, FAN* defCurveFrom);"	// init'l check/setup, cncult5.cpp
*declare "void fn_setup2( int options=0);"				// deriv mbrs common code, cnfan.cpp 7-95
*declare "double fn_puteVf( DBL /*CFLOW*/ vf, DBL /*TEMP*/ t, DBL /*FRAC*/ frOn=1.0);"
*declare "double fn_pute( DBL /*CFLOW*/ c, DBL /*TEMP*/ t, DBL /*FRAC*/ frOn=1.0);"	// runtime model, cnfan.cpp

// FAN inputtable members

*f FANTYCH fanTy	// fan position choice, according to application as follows; constant.
					//   air handler supply:  DRAWTHRU (default) or BLOWTHRU
					//     ah return/relief:  NONE (default), RETURN, or RELIEF
					//             terminal:  NONE (default), SERIES, or PARALLEL
					//     zone exhaust fan:  NONE or EXHAUST (no types, just whether exists)
					//     AirNet (IZXFER):	  ditto
*s *e AFLOW_GZ vfDs	// design volumetric flow (cfm actual air).  constant, RQD except as noted. *s cuz varies when autoSizing.
*f AFLOW vfDs_As	// autoSized ditto for ah sfan and rfan for naming consistency. 6-95.
*f AFLOW vfDs_AsNov	// raw autoSized ditto b4 overSize added, for report/probes. 7-95.
// cnausz.cpp code ASSUMES x, x_As, x_AsNov together for access thru one ptr. cuprobe.cpp's name search also requires together.
*f FLOAT vfMxF   	// factor by which fan flow will exceed vfDs (at reduced pressure). default 1.3. constant.
					// Error if < 1.0; typically <= 1.5.

*r PRESAIR_GEZ press	// system design pressure, "H2O (inches of water), constant, used in defaulting power / efficiency.
						// default: supply 3, r/r .75, tu .3, zx ???.
						// 0 allowed 5-1-92 to eliminate fan heat for test/calibration purposes.

//only one of eff and shaftPwr may be given:
*r FRAC_GZ eff		// fan (hydraulic) efficiency at vfDs and press (any temp), constant,
					// default from power if given, else .65.  (1-eff) of fan shaft power is converted to heat in airstream.
*r BHP_GZ shaftPwr	// fan shaft power at vfDs and press (any temp). constant. default: from eff
					// Btuh internally, entered in BHP (user name 'shaftBhp') (cvpak converts).
					// ^^^^make user name 'shaftBhp'.  field type name??
*r FLOAT_GZ elecPwr	// motor input power, W/cfm (based on vfDs); shaftPwr and elecPwr cannot both be
					//   input

*r MOTTYCH fn_motTy		// motor type (C_MOTTYCH_PSC or C_MOTTYCH_BPM)
						//   RSYS only minimal use 4-12, could effect defaults

*f FRAC_GZ motEff		// motor/drive efficiency, constant, default .9.

*f MOTPOSCH motPos 	// motor/drive position: choice of INFLO (default), INRETURN, EXTERNAL.  constant.
					// INRETURN is for supply fans only and will be deferred/omitted if difficult
					// chip per taylor 3-4-92).

*f *nest PYCUBIC2 curvePy	// fan part-load energy consumption curve cubic polynomial coefficients with x0

*i TI fn_mtri			// subscript of meter (MTR) to which energy consumption is charged
*f ENDUSECH fn_endUse	// end use to which energy consumption is charged
						//   not used for all fans (many implicitly default to "fan")

*r BOO ausz			// non-0 if fan being autoSized (AH sfan, rfan): input contained AUTOSIZE _fanVfDs. 7-1-95.
					//   see also AH::fanAs, asRfan, asFlow. 7-1-95. */

// FAN setup time members, set by cnfan.cpp:FAN::setup. May be resetup during autoSize run.
//  also cMx may be init by setup, to be non-0.
*s POWER outPower	// motor output power (work done by fan), member 7-95 for one setup check in cncult5.cpp
//inPower = shaftPwr/motEff  is computed as needed.
*s POWER airPower	// fan heat to air (Btuh) at vfDs (& pressure): work done by fan, plus motor/drive inefficiency if in flow.
			// Note work done by fan is modelled as HEAT ADDED TO AIR AT FAN per Chip/Niles (3-92, undocumented)
//heat to air around motor (in return air etc) at design flow is: (inPower - airPower). this is 0 if motor in air flow.

// FAN runtime members, set by cnah.cpp:FAN::pute( cFlow, temp)
*s *e CFLOW cMx	// max heat cap flow (Btuh/F) at curr air temp & run press & ref w: .vfMx * air vsh * 60 (min/hr)
*s *e CFLOW c	// current average flow in heat cap units (Btuh/F): input saved for probing by last call to FAN::pute()
*s *e TEMP t	// current air temp, input saved ditto, used in converting BtuF/F to cfm
*s *e FRAC frOn 	// fraction of time fan is on, saved input
// made local to pute()to save members 10-92:
// *s *e FRAC relFlow	// fraction of design flow
// *s *e FRAC relLoad	// fraction of full load per part load curve for fan type (1.0 if over design flow: assume pressure drops)
*s *e POWER p	// (motor) power consumption for subhour -- inPower * relLoad.  *subhrDur for meter.
*s *e POWER q	// heat (power) to air this subhour: airPower * relLoad.  Member needed in addition to c and dT??
*s *e TEMPDIFF dT	// temp difference due to fan: q/c
*s *e POWER qAround	// heat to air around motor, if not in air flow, for use re supply fan motor in return air

// FAN setup calculations (done once, after input, before run) (see cncfan.cpp for code)
//
//    vfMx = vfDs * vfMxF;
//
//    #define BtuhPerCfmInH2O (5.2022 * .0012854 * 60)
//                             |         |         min/hr
//                             |         Btu/ft-lb
//                             (lb/ft2)/(in H20)
//
//    //default power or efficiency from the other (if neither or both given, error occurs before getting here)
//       if (shaftPwr given)  eff = vfDs * press * BtuhPerCfmInH2O / shaftPwr;
//       else                 shaftPwr = vfDs * press * BtuhPerCfmInH2O / eff;
//
//    //input power consumption at design flow
//       inPower = shaftPwr / motEff;
//
//    //heat to air stream at design flow
//       if (motPos==INFLO)  airPower = inPower;
//       else                airPower = inPower * motEff;

*END		// FAN
//=============================================================================
RECORD ZNISUB "zone sub" *SUBSTRUCT
	*prefix zn_
	// zone input info substruct, used in ZNR and ZNI
    *declare "int IsCountable( int options) const { return options==0 || options==znModel; }"
    *declare "float zn_HeightZ( float f) const;"
    *declare "int zn_IsConvRad() const { return znModel >= C_ZNMODELCH_CZM; }"
    *declare "int zn_IsUZ() const { return znModel >= C_ZNMODELCH_UZM; }"

// ZNISUB general user inputs
    *i ZNMODELCH znModel   	// zone model (CNE, CSE, CZM, UZM, UZX)
    *i AREA_GZ znArea		// flrarea Conditioned floor area of zone (ft2)
    *i VOL_GZ znVol			// zone nominal volume (ft3)
    *i FLOAT zn_floorZ		// zone floor Z above ground, ft.  Used re airNet vent Z etc.
							//   (can be <0 re below grade spaces)
    *r LEN_GZ zn_ceilingHt	// zone nominal ceiling height, ft. default = znVol / znArea
    *i HC_GZ znCAir			// effective "air" heat cap (Btu/F): models all non-mass heat cap in zone.
	    					//   defaults to 3.5*area. heat cap of surfaces not modelled as "massive" may be added.
	*r *hide HC_GZ znCAirSh	// cnCAir / Top.tp_subhrDur (often-used)
	*r FLOAT_GZ zn_HIRatio	// hygric inertia ratio for zone, default 1
							//   for moisture balance calcs in non-CNE zones,
							//    effective dry-air mass = zn_HIRatio * zn_dryAirMass
    *i ANGLE znAzm 	// zone azimuth wrt bldgAzm, deg.  + = clockwise
    *i BOO plenumRet // TRUE for plenum return, FALSE for ducted return, for all air from this zone.  default FALSE. 3-92.
					// not yet inputtable 10-92. If changed eg to yes-no fix cncult5 errmsg "...when zone plenumRet is 0".
     				//  ** where is the plenum, and whether it is active or passive, specified?
    *h FRAC znSC  	// zone Shade Closure optional hourly expression, 0. open, 1. closed.
    				// default: closed if cooling in prior hour (cnloads::loadsAfterHour) (see ZNR:znSCF)
					// Determines choice between window sco/scc, SGDIST sgd_FSC/sfFSC, via cgsolar.cpp.
					// Pointed to by .cppontrol of SgR entries (whose factors are (neg) closed-shade gain reductions).
					// Subhourly variablility desirable (rob's opinion); requires duplicating
					// loadsHourBeg solar gain code in loadsSubhr with znSC-change trigger.

	*s TEMP_GZ znTH // base heating set point, F (from input, may be modified for autosizing)
	*s TEMP_GZ znTD // base desired temp (vent) set point, F (from input, may be modified for autosizing)
    *s TEMP_GZ znTC // base cooling set point, F (from input, may be modified for autosizing)

					// available nominal system capacity, Btuh (added 9-10)
    *h FLOAT znQMxH			// heating cap for current hour (>= 0)
    *r FLOAT znQMxHRated	// heating cap rated (>=0, constant for run)  TODO: s/b autosizable?
    *h FLOAT znQMxC			// cooling cap for current hour (<= 0)
    *r FLOAT znQMxCRated	// cooling cap rated (<=0, constant for run)  TODO: s/b autosizable?
    *r TI zn_loadMtri       // idx of LOADMETER for accumulation of zone heating and cooling loads

	*r TI zn_rsi;			// idx of RSYS serving zone

    *h FLOAT zn_hcFrcF		// forced convection coefficient factor, default = 0.2
							//     interior hcFrc = zn_hcFrcF * zn_hcAirX^.8
	*s *e FLOAT zn_hcAirX;	// zone air change rate (1/hr), input for testing
							//     else calculated subhourly in zn_AirXMoistureBal()
	*r INT zn_hcAirXIsSet	// 1 iff zn_hcAirX is set from input (for testing)
							//     WHY: ZNI status bytes not passed to ZNR, need flag

// re comfort calculations (allowed only for CR zones 1-20-2011)
#ifdef COMFORT_MODEL
	*s FLOAT_GZ znComfClo		// clothing insulation value used for comfort calcs, clo
	*s FLOAT_GEZ znComfMet		// activity level (metabolic rate) for comfort calcs, met
	*s FLOAT_GEZ znComfAirV		// air velocity for comfort calcs, ft/sec
	*s FRAC znComfRh			// RH used for comfort calcs (0-1)
								//   if input, used to derive humrat for comfort calcs
								//   if omitted, znComfUseZoneRH is set
								//      zone humrat used for comfort calcs
								//      and znComfRH is derived (for e.g. reports)
	*r INT znComfUseZoneRH		// nz iff comfort calc should use zone relative humidity
								//   else uses i.znComfRH
#endif

// Zone exhaust fan members (from Taylor's terminal description 3-92)
    *h FRAC xfanFOn			// zone exhaust fan schedule, fraction on, hourly scheduleable, default 1
    *i *nest FAN xfan		// subrecord for other fan members.
							//   if xfan.vfDs is not given, no fan, other inputs disallowed.

// ZNISUB infiltration inputs.
    *h FLOAT_GEZ infAC		// ac	    Base air changes/hr, for q proportional to tempDiff ("constant" portion). (1/hr)
    *h AREA2 infELA			// ela	    Zone effective leakage area, for q prop to tempDiff ^ 3/2 (cuz flow prop to sqrt(tDiff))
    						//			(in2 to user, ft2 internally)
    *z SI_GZ zn_infShld		// local shielding (obstructions) class (1 - 5)
    *z SI_GZ zn_infStories	// # stories in zone (1-3); provides default for zn_eaveZ else unused
    *r LEN_GZ zn_eaveZ		// zone nominal eave Z above ground, ft re wind speed adjustment
							//   default = zn_floorZ + zn_infStories * 8.f;
	*s FLOAT zn_windFLkg	// wind factor for infiltration and airnet, dimless
							//   default derived from zn_infShld and zn_eaveZ
							//   else input
							// Note: Top.windF also applied
	*r TI zn_afMtri			// AFMTR (air flow meter) idx, 0 if none
							//   provides default for IZXRAT.iz_afMtri in this zone
							//   perhaps additional?

// ZNISUB setup time: reports.  (Most zone report info is in DvriB, accessed by interval via list heads in Top.)
    *r INT vrZdd	// 0 (report not requested) or vrh (virtual report handle) for zone description (ZDD report).
					// in ZNISUB to persist from autosize to main sim, when most runtime stuff is cleared & resetup,
					// incl zones but excluding most report stuff.
*END		// ZNISUB
//=============================================================================
RECORD ZNI "zone" *RAT		// zone input info RAT
    				// .name (base class) is required; .ownTi is unused.
    *declare "RC zi_Top( int re);"
    *i *noname *nest ZNISUB i	// input info, substruct record above
*END		// ZNI
//=============================================================================
RECORD ZNR "zone" *RAT	// zone runtime info RAT.  Set mainly from separate ZNI
	*prefix zn_
	*excon
    *exdes
    *ovrcopy

    // .name (in base class) is required.  .ownTi is unused.
    *declare "void addRIgDist( RIGTARGTY targTy, TI targTi, float targFr);"
    *declare "void zn_AddIZXFERs();"
    *declare "TI zn_AddIZXFER( IZNVTYCH _ty, const char* nmSfx, const AIRFLOW* pAF=NULL);"
    *declare "TI zn_FindOrAddIZXFER( IZNVTYCH _ty, const char* nmSfx, const AIRFLOW* pAF=NULL);"
    *declare "XSRAT* zn_FindXSRAT( const char* xsName);"
    *declare "MSRAT* zn_FindMSRAT( const char* xsName);"
    *declare "void zn_AccumBalTermsQS( double area, const SBC& sbcI, const SBC& sbcO);"
    *declare "void zn_EndSubhrQS( double area, double uC, SBC& sbcI, SBC& sbcO);"
    *declare "void zn_InitSurfTotals();"
    *declare "void zn_AccumSurfTotals( SBCBASE& S);"
    *declare "void zn_FinalizeSurfTotals();"
    *declare "void zn_DbDumpSGDIST( const char* tag) const;"
    *declare "void zn_SetAirRadXArea();"
    *declare "RC zn_RadX();"
    *declare "RC zn_FFactors( struct SFPLIST& sfpList);"
    *declare "RC zn_RddInit();"
	*declare "RC zn_BegHour1();"
    *declare "RC zn_BegHour2();"
    *declare "RC zn_XFan();"
    *declare "RC zn_BegSubhr1();"
    *declare "RC zn_BegSubhr2();"
    *declare "RC zn_InitSubhr();"
    *declare "RC zn_SetZtuCfIf( BOO azCf);"
    *declare "RC zn_CheckHVACConfig();"
    *declare "void zn_GetAirState( AIRSTATE& as) const { as.as_Set( tz, wz); }"
    *declare "void zn_GetAirStateLs( AIRSTATE& as) const { as.as_Set( tzls, wzls); }"
    *declare "bool zn_HasTerminal() const { return tu1 != 0; }"
    *declare "bool zn_HasAirTerminal() const { return zn_airTerminalCount > 0; }"
    *declare "bool zn_HasRSYS() const { return i.zn_rsi != 0; }"
    *declare "bool zn_HasAirHVAC() const { return zn_HasRSYS() || zn_HasAirTerminal(); }"
    *declare "RSYS* zn_GetRSYS();"
    *declare "const RSYS* zn_GetRSYS() const;"
    *declare "int zn_IsHCAvail( int what) const;"
    *declare "bool zn_IsAirHVACActive() const;"
    *declare "float zn_VentTSup();"
    *declare "double zn_TAirCR( double mCpT, double mCp, double qRad) const;"
    *declare "double zn_TAirCR( double mCpT, double mCp) const;"
    *declare "double zn_TRadCR( double tza, double qRad) const;"
    *declare "double zn_TRadCR( double tza) const;"
    *declare "double zn_QAirCR( double tza, double qRad) const;"
    *declare "double zn_QAirCR( double tza) const;"
    *declare "double zn_QsHvacCR( double tza, float fConv) const;"
    *declare "double zn_AmfHvacCR( double tza, double tSup, double qRad) const;"
    *declare "double zn_AmfHvacCR( double tza, double tSup) const;"
    *declare "void zn_TAirFloatCR() { tz = zn_balC1 / zn_balC2; }"
    *declare "void zn_SetRSYSAmf( float fSize, int iAux);"
    *declare "void zn_SetRSYSAmfFromTSup();"
    *declare "void zn_IdealHVAC();"
    *declare "void zn_MapTerminalResults();"
    *declare "RC zn_CondixCR2();"
    *declare "RC zn_AirFlowVsTsup();"
    *declare "int zn_AssessVentUtility();"
    *declare "int zn_OAVAttempt( double tSup);"
    *declare "int zn_FVentCR();"
    *declare "RC zn_CondixCR( ULI ventAvail);"
    *declare "RC zn_AirRequest( RSYS* rs, int options=0);"
    *declare "RC zn_AirX( double amfX=0., double _tz=-99.f);"
    *declare "double zn_HumRat( double amfX, double mwX, double _tz, double* pXLGain=nullptr);"
    *declare "double zn_AirXMoistureBal( bool bFinal, double amfX=0., double mwX=0., double _tz=-99., double* pXLGain=nullptr);"
    *declare "RC zn_ComfortCR();"
    *declare "void zn_DbDump() const;"

    *declare "RC zn_AfterSubhr();"
    *declare "RC zn_AfterHour();"
    *declare "RC zn_InfilSetup();"
    *declare "RC ztuEndSubhr();"
    *declare "bool zn_TrackUnmetLoads() const;"
    *declare "RC ztuCompute();"
    *declare "RC ztuMode();"
    *declare "RC ztuMdSeq();"
    *declare "RC ztuAbs( int md, BOO fromZtu, DBL &aqHvO, DBL &bHvO, DBL &wcO, DBL &wcO1, DBL &cO );"
    *declare "DBL znW( DBL wc, DBL c, DBL tz, DBL* pXLGain=nullptr);"
    *declare "void ztuMdSets( int md);"
    *declare "BOO nxTu( TU *&tu);"
    *declare "BOO nxZhx( ZHX *&x);"
    *declare "BOO nxZhxSt( ZHX *&x);"
    *declare "int IsCountable( int options) const { return i.IsCountable( options); }"
    *declare "int zn_IsConvRad() const { return i.zn_IsConvRad(); }"
    *declare "int zn_IsUZ() const { return i.zn_IsUZ(); }"
    *declare "int zn_IsSFModelSupported( int sfModel) const;"
    *declare "void zn_SGClearTots();"
    *declare "void zn_SGCavAbs();"
    *declare "void zn_SGToZone();"

// input info, substruct above. copy of ZNI.  noname: omit "i." from probe names in SFIR table.
    *noname *nest ZNISUB i

   // (following infil, vent, ceilfan info is mostly non-input members taken from former substructs of HSZN, 2-91)

// ZNR setup time: zone's objects
    *r TI xsurf1	// chain head (XSRAT subscr) of zone's XSURFs: surface/window/perim/massWall info. next: XSRAT.nxXsurf.
    *r TI xsSpecT1	// 0 or chain head of zn's XSURFs with .sfExCnd==C_EXCNDCH_SPECT: used hourly.  next: XSRAT.nxXsSpecT.
    *r TI tu1			// head of chain of zone's terminals: 0 or TuB subscript. next: TU.nxTu.
    *r TI zhx1			// chain head of zone's ZHX's (Zone Hvac Xfers): 0 or ZhxB subscript. next: ZHX.nxZhx4z.
    *r TI zhx1St		// ... zone's cmStxx (tstat-ctrl'd) ZHX's.    next: ZHX.nxZhzSt4z.
    *r SI zn_airTerminalCount;      // # of terminals serving this zone that can supply air
                                    //   known after all TU::tu_Setup()s complete

// ZNR setup time: other
    *r BOO znSCF		// non-0 if i.znSC given by user; 0 to default Shade Closure in cnloads.cpp

// ZNR infiltration setup time info, set by ZNR.zn_InfilSetup() for cnloads:loadsHourBeg.  Double infiltration model is supported.
    *r FLOAT zn_stackc 		// stack coefficient for zone height (Sherman-Grimsrud model)
    *r FLOAT zn_windc 		// wind coefficient for zone height and shielding (Sherman-Grimsrud model)

// ZNR radiant internal gain setup time info, 11-95
    //  Radiant internal gains distribution table entry use:      Much redundant info for debugging / poss future repoint needs.
    //    struct { RIGTARGTY targTy; TI targTi; float targFr; RIGTARG * targP; };  (cndtypes.def)
    //    .targTy  .targTi is for   target member    description
    //   znTot          ZNR          .qrIgTot       zone total rIg, for ebal check
    //   znTotO         --           .qrIgTotO      loss thru light surf to outdoors, for conduction in ebal check
    //   znTotIz        ZNR          .qrIgTotIz     to adjacent zone thru light surf (entries for both zones, + and -)
    //   znCAir         ZNR          .qrIgCAir      to zone CAir (light surface)
    //   massI          MSRAT        .inside.qIg    to mass inside in this zone
    //   massO          MSRAT        .outside.qIg   to mass outside in this zone
    *r USI rIgDistNAl		// 0 or number of allocated entries in...
    *r USI rIgDistN			// 0 or number of used entries in...
    *r RIGDISTP rIgDist   	// NULL or ptr to heap array of distrubution info for rad int gain originating in zone.

// ZNR solar gain targeting and radiation exchange variables set at setup time for use at runtime
//   added re cavity absorptance, 1995
//   reworked re CSE radiant exchange, 2010
    *declare "WVect< SBCBASE*> zn_sbcList;"
    *r DBL zn_surfA			// total surface area in zone, ft2 (surfaces, doors, windows, ducts)
							//    (includes exterior of C_EXCNDCH_ADJZN surfaces)
    *r DBL zn_surfASlr		// total "short wave" surface area in zone, ft2
							//   = opaque area that participates in solar gain distribution
							//   = surfaces and doors but not windows and ducts
							//   Note: ducts cannot receive solar gain as of 4-2012
	*r DBL zn_ductA			// total duct surface area in zone, ft2 (included in zn_surfA)
							//   (info only)
    *r DBL zn_surfEpsLWAvg	// area-weighted surface LW emissivity = SUM( surfArea * surfEpsLW) / zn_surfA
	*r DBL zn_airRadXC1		// constants re zn_airRadXarea calc
	*r DBL zn_airRadXC2
    *r DBL zn_airRadXArea	// area of air "surface", ft2
							//   participates in LW exchange network
	*r DBL zn_FAir			// air F "view factor" (constant during simulation)
    *h *e DBL zn_airCxF		// air factor for zn_cxSh re LW exchange
    						//   = zn_airRadXarea * zn_FAir * sigmaSB, Btuh/R^4
    *s *e DBL zn_airCx		// air contribution to zn_cxSh, Btuh/F

// ZNR solar gain targeting runtime variables 2-95
    //#define OC 2	above	// shades Open/Closed array dimension. subscripts: 0 = open, 1 = closed.
    // temporaries used during one hour's m-h solar calculations in cgsolar.cpp. m-h cuz inputs include gtSMSO/C, sfIn/ExAbs.
    *mh *e *array OC DBL rmTrans  		// area-weighted summed diffuse transmissivity of windows in zone,
   										//    shades open/closed, re adjRmAbs
    *mh *e FRAC rmAbs					// sum of area-weighted solar (SW) absorptivity for opaque room surfaces (dimensionless).
    *mh *e *array OC DBL adjRmAbs  		// rmAbs adjusted for reflected energy that goes out windows (m-h):
		                       			//    divisor in computing cavAbs's for znCAir and massive surfaces
    *mh *e DBL rmAbsCAir				// sum of area-weighted absorptivity for non-massive room surfaces
    *mh *e *array OC DBL cavAbsCAir		// zone CAIR cavity absorptance === portion insolation to no particular surface
    *mh *e *array OC DBL sgfCavBm 		// zone's solar gain factors from its windows not explicitly targeted for hour,
    *mh *e *array OC DBL sgfCavDf 		// .. to be distributed amoung surface and CAir SgR entries after accumulation.
    *mh *e *array OC DBL sgSaBm 		// CAIR adjustments to above for gains getting to other side of (quick) surface or
    *mh *e *array OC DBL sgSaDf 		// .. lost to outdoors due to surface film vs conductance thru (quick) surface
    *mh *e *array OC DBL sgfCAirBm		// beam solar gain factor this hour to zone CAir
    *mh *e *array OC DBL sgfCAirDf		// diffuse .. These are multipliers for wthr data, later, via SgR

// ZNR loads setup time variables: ua's (uval*area), used for zn_aqLdHr for 'a' for "Tz = (a + q)/b".
    *r DBL zn_uaSpecT	// ua to specified temps (exCnd=specT surfaces), for zn_bcon. set/used only in cnguts.cpp.
    *r DBL zn_ua		// Overall loss to ambient (sum uval*area), constant for run, for zn_bcon and zn_aqLdHr. Btuh/F.
						// Accumulation to double found nec for CEC custom budget *EXACT* match: float sometimes
						// gave 1 part in 100000 differences (CEC certification test calls for 2-digit match).
    *r DBL zn_UANom		// UA to ambient based on surface UNom (derived with default surf conductances), Btuh/F
	*r DBL zn_ductCondUANom	// nominal total UA of ducts in zone, Btuh/F (due to conduction, not air leakage)

    *r DBL haMass	 	// Total ha (surf conductance * area) to mass (Btuh/F)

						// re determination of below grade floor coefficients
						// floor coupling depends on wall insulation
						// walls processed first and accumulate here
    *r DBL zn_BGWallPerim	// total below grade wall perimeter, ft
    *r DBL zn_BGWallPA4		// sum (perim*a4)
    *r DBL zn_BGWallPA5		// sum (perim*a5)

// ZNR loads runtime: hourly q's for  Tz = (a + q)/b.
	*h *e DBL qSgTot			// hour total solar gain to some
    *h *e *nest SGTARG zn_sgTotTarg	// hourly part of s g total (Btuh) for zone: hourly mass insides.
								// Added to in cnloads.cpp:loadsHour via pointers in SgR entries made monthly
								// in cgsolar.cpp per info in XSURFs made in cncultn.cpp. Used: cnztu.cpp re results qSlr
    // radiant internal gain from GAIN inputs. All POWER (Btuh). Next 4 set via rIgDist. 11-95.
    *h *e RIGTARG qrIgTot	// total originating in this zone: redundant total for energy balance check only.
    *h *e RIGTARG qrIgTotO	// subtotal lost to outdoors thru light surfaces, to show in ZEB rpt as -Cond.
    *h *e RIGTARG qrIgTotIz	// net subtotal to other zones thru light surfaces, to show in ZEB rpt as -Izone.
     // energy balance: qrIgTot - qIgTotIz - qIgTotO = qrIgAir + qrIgMs
    *h *e RIGTARG qrIgAir	// rad int gain to this zone's CAir (for light surfaces/windows), for zn_aqLdHr. 11-95.
    *h *e POWER   qrIgMs 	// rad int gain to mass sides in this zone, for energy balance, set in cnLoads. 11-95.

    // *e? next five contain prior hour's value at start hour expr time, new value by 2nd subhour. see note 1, 1-92. *e's 11-95.
    *h *e DBL /*POWER*/ znSGain	// zn's hr's sens gain (Btuh), total from zn's GAINs, to qsIgHr.
									// set cnguts, used cnloads.
     // qsIgHr (just below) includes znSGain but excludes qrIgAir.
    *h *e DBL /*POWER*/ znLGain	// latent gain (Btuh), from ditto, used by ZNR::znW.
     // additional accumulators for lighting end use gains, re daylighting, for NREL. set cnguts, used cnztu.cpp. 9-94.
    *h *e DBL /*POWER*/ znLitDmd	// lighting demand (before reduction by gnDlFrPow)
    *h *e DBL /*POWER*/ znLitEu	// lighting energy use (after reduction by gnDlFrPow; also posted to znS/LGain & meter).

    *h *hide DBL qsIgHr 	// hour sens int gain rate (Btuh), from wthr file + znSGain, for zn_aqLdHr.
							// does NOT include radiant gain (qrIgAir above). loadsHourBeg sets. note 2.
    *s *e DBL /*POWER*/ znXLGain	// excess latent gain (Btuh) rejected in znW() to prevent over-saturated w. 10-96.
    *s *e DBL /*POWER*/ znXLGainLs	// previous subhour ditto: added to sensible gain to simulate condensation in zone, 5-97.

// ZNR loads runtime: hourly  a's, b's  for  Tz = (a + q)/b.   Notes 1 and 2 are below in ZNR record description.
    //a's (sigma(UAi*Ti)).  no acon (no ua*t or q constant for run)
    *h *hide DBL zn_aqLdHr 	// non-hvac portions of a (sigma(UAi*Ti)) and q's constant for hour. note 2.
							//  sum of: aMassHr, qsIgHr, zn_uaXSpecT (= specT uaT's)
	*h *hide DBL zn_uaXSpecT	// sigma( U * A * specT) (term for zn_aqLdHr, needed separately for conv/rad model)
    *h *hide DBL aMassHr   	// Hourly mass portion of zn_aqLdHr: sum ha*T to hourly masses exposed to zone. note 1. was aMassNxt.

    //b's (sigma(UAi))
    *r DBL zn_bcon  		// portion of b constant for run: ua + uaSpecT. setup time.
    *h *hide DBL zn_bLdHr   // b constant for hour (subhr b same): zn_bcon.  (note 2)
    *h *hide DBL zn_xqHr	// tz*zn_bLhHr - zn_aqLdHr: load hourly portions using old tz, re detecting load changes only. 12-94.

// ZNR loads runtime: subhourly q's, a's, b's for  Tz = (a + q)/b.
    *s *e DBL /*POWER*/ qMsSg	// subhour's solar gain rate (Btuh) to mass surfaces in zn, to subtract from subhour results qMass.
    							// note 2.
	*s *e DBL zn_qSgAir			// subhour's solar gain rate (Btuh) to air
    *s *e *nest SGTARG zn_sgAirTarg   // Solar gain (Btuh) target (float) for zone air: all sun thru windows not SGDIST'd to a mass.
								//  Added to in cnloads.cpp:loadsSubhr via pointers in SgR entries made monthly
								//  in cgsolar.cpp per info in XSURFs made in cncultn.cpp. Used: cnloads.cpp re aqLdSh. */
	*s *e DBL qSgTotSh
    *s *e *nest SGTARG zn_sgTotShTarg	// subhourly part of s g total (Btuh) for zone: air + mass insides.
								//  Added to in cnloads.cpp:loadsSubhr via pointers in SgR entries made monthly
								//  in cgsolar.cpp per info in XSURFs made in cncultn.cpp. Used: cnztu.cpp re results qSlr */
    *h *hide DBL aMassSh  		// Subhourly mass portion of zn_aqLdHr: sum ha*T to subhourly masses exposed to zone. note 1.
    *s *hide DBL zn_uaInfil 	// Infiltration UA (uval * area, === heat cap flow), this hour, for aq-,bLdSh and zone w.  note 2.
								// === heat capacity of entering air (Btuh/F).  Divide by top.airxO for cfm.
	*s *e DBL zn_qIzXAnSh			// subhourly gain due to non-airnet IZXFERs (Btuh, +=into zone)
    *s *e DBL zn_qIzSh				// subhourly part of interzone gain rate (Btuh, +=into zone)
									//   due to non-airnet IZXFERs

									// subhourly values re airnet heat gains (see IZXFER)
									//   [ 0]=minimum (generally infil only)
									//   [ 1]=maximum (generally infil+vent)
   	*s *e *array 2 DBL zn_pz0W		// working zone pressures relative to patm at nominal z=0, lbf/sf
									//  [ 0]=infil only; [ 1]=infil+vent
  	*s *e DBL zn_pz0				// final zone pressure relative to patm at nominal z=0, lbf/sf
  									//    = zn_fVent-weighted avg of zn_pz0W[ 0] and zn_pz0W[ 1]
	*s *e SI zn_ventUt				// vent utility for this substep
									//  <0=bad (don't vent), 0=don't care, 1=maybe helpful
	*declare "void zn_AccumAirFlow( int iV, double mDot, const AIRSTATE& as, double td=0.);"

    *s *e *hide DBL zn_aqLdSh	// non-hvac portion of a+q for subhr:
    							//  zn_aqLdHr + aMassSh + zn_qIzSh + qSgAir + top.tDbOSh*(ua + uaInfil) + tzlh*znCAir*subhrDur (told*hc/t)
    *s *e *hide DBL zn_bLdSh	// b ditto: zn_bLdHr + uaInfil + znCAir*subhrDur (hc/t).   These 2 are LOADS OUTPUT TO HVAC.
    *s *e *hide DBL zn_xqSh		//  like zn_xqHr but subhourly

								// subhour zone gains from duct conduction losses, Btuh
								//   (convective/radiant only)
								// CAUTION: subhr initialization not at beginning of step
								//    re lagged values in zone balance
    *s *e DBL zn_qDuctCondAir	//	to ta (convection)
    *s *e DBL zn_qDuctCondRad	//  to tr (radiation)
    *s *e DBL zn_qDuctCond		//  sum FROM LAST STEP (else energy balance trouble)

								// subhour DHW zone transfers, Btuh
								//   (convective/radiant only)
    *s *e DBL zn_qDHWLossAir	//	to ta (convection)
    *s *e DBL zn_qDHWLossRad	//  to tr (radiation)
    *s *e DBL zn_qDHWLoss		//  sum
	*declare "void zn_CoupleDHWLossSubhr( double qLoss, float fR=0.5f);"
	*s *e DBL zn_qHPWH			//  heat extracted from zone by heat pump DHWHEATER(s)
								//     assumed from ta (convective) (always <=0)
								//     Included in zone balance as heat, not air flow,
								//     else energy bal error possible
	*s *e FLOAT zn_hpwhAirX		// approximate zone air change rate due to
								//   heat pump water heater source air (changes/hr)
								//   air assumed returned to source zone
								//   affects zn_hcFrc but not pressure balance

	*h *e SI zn_anVentEffect;				// # of IZXRATs that could impact airnet
											//   zone vent flow. Derived from ad_Ae/ad_mdotP,
											//   ok whether zn_airNetI[ 1] is calc'd or not
 	*array 2 *s *e *nest AIRFLOW zn_airNetI		// total *possible* airnet flow into zone
 												// note actual flow depends of zn_fVent
 												//   [ 0]=infil only
 												//   [ 1]=infil+vent (calc'd only if needed)

    *declare "double zn_AnAmfCp( int iV) const { return zn_airNetI[ iV].af_AmfCp(); }"
    *declare "double zn_AnAmfCpT( int iV) const { return zn_airNetI[ iV].af_AmfCpT(); }"
    *declare "double zn_AnAmf() const;"			// returns actual
    *declare "double zn_NonAnIVAmf( double dryAirMass=-1.) const;"

	*s *e FLOAT zn_fVentPrf				// preferred vent fraction for this zone in isolation
										//   (not limited by e.g. C_VENTAVAILVC_WHOLEBLDG)
	*s *e FLOAT zn_tzVent				// zone air temp with full vent, F (debug aid)
										//    0 if vent not possible
   	*s *e FLOAT zn_fVent				// vent fraction actual; venting used to hold zone at zn_tzspD
										//    = (actual mCp) / (possible mCp)
    *s *e DBL zn_anAmfCpVent			// vent flow (in excess of zn_airNetI[ 0]), Btuh/F
    *s *e DBL zn_anAmfCpTVent			// vent flow*temp (in excess of zn_airNetI[ 0]), Btuh

										// total HVAC-related air flows for step
										//  includes run fract (i.e. =0 when system off)
	*s *e *nest AIRFLOW zn_ductLkI		//   duct leak into zone
	*s *e *nest AIRFLOW zn_ductLkO		//   duct leak out of zone
	*s *e *nest AIRFLOW zn_sysAirI		//   HVAC air into zone (supply)
	*s *e *nest AIRFLOW zn_sysAirO		//	 HVAC air out of zone (return)
	*s *e *nest AIRFLOW zn_OAVRlfO		//   HVAC OAV air out
										//		in OAV mode, zn_sysAirO = 0 and zn_OAVRlfO > 0

	*s *e *nest AIRFLOW zn_sysDepAirIls	// total system dependant flow into zone from prior step
										//    = zn_ductLkI
										// lagged value used in zone HB re duct leaks, etc.
										//    that depend on HVAC performance.
										//  * does NOT include zn_sysAirI
										//  * NOT used in mass balance



								// subhour values for convective/radiant model (9-10)
    *s *e *hide DBL zn_nAirSh	//  air numerator
    *s *e *hide DBL zn_dAirSh	//  air denominator
    *s *e *hide DBL zn_nRadSh	//  radiant numerator
    *s *e *hide DBL zn_dRadSh	//  radiant denominator
	*s *e *hide DBL zn_cxSh		//  cross-coupling

								// useful combos of above
	*s *e *hide DBL zn_dRpCx	//   zn_dRadSh + zn_cxSh
	*s *e *hide DBL zn_nRxCx	//   zn_nRadSh * zn_cxSh
	*s *e *hide DBL zn_dRxCx	//   zn_dRadSh * zn_cxSh
	*s *e *hide DBL zn_balC1	//   zn_nAirSh*zn_dRpCx + zn_nRxCx
	*s *e *hide DBL zn_balC2	//   zn_dAirSh*zn_dRpCx + zn_dRxCx

	*s *e *hide DBL zn_hcATMsSh	//  re zone heat bal accounting: sigma( Amass * hcMass * tSrfMass)
	*s *e *hide DBL zn_hrATMsSh	//  ditto radiant
	*s *e *hide DBL zn_hcAMsSh	//  re zone heat bal accounting: sigma( Amass * hcMass)
	*s *e *hide DBL zn_hrAMsSh	//  ditto radiant
	*s *e DBL zn_qCondQS		// total quick surface conduction, Btuh (+ = into zone)
	*s *e DBL zn_qCondMS		// total mass exterior surface conduction, Btuh (+ = into zone)
								//   computed/unused 12-21-10
	*s *e *hide DBL zn_ieMass	// total internal energy of all zone masses, Btu (computed/unused 12-21-10)
	*s *e *hide DBL zn_ieMassls	// ditto, end of last step (computed/unused 12-21-10)
	*s *e *hide INT zn_ebErrCount	// count of short-interval (day/hour/subhour) energy balance errors
									//   detected for this zone; s/b 0; used to suppress excessive msgs
	*array 2 *s *e DBL zn_rsAmfSysReq;	// requested RSYS air mass flow (at system) to hold current step set point, lbm/hr
										//  [ 0]=with main source
										//  [ 1]=with main+aux (ASHP only)
	*s *e FLOAT zn_rsFSize;		// fraction of requested air that RSYS could provide
	*s *e DBL zn_rsAmfSup;		// final RSYS supply air mass flow (at register, +=in), lbm/hr
	*s *e DBL zn_rsAmfRet;		// final RSYS return air mass flow (out of zone at grille, +=out), lbm/hr
	*s DBL zn_rsAmfRetLs;		// last step zn_rsAmfRet (+ = out)

    *s *e TEMP_GZ zn_tzsp       // current step controlling set point, F
                                //    may not be reliably set for all modes
                                //    0 if no active setpoint
	*s *e TEMP_GZ zn_tzspH		// current step heating set point, F
    *s *e TEMP_GZ zn_tzspD		// current step desired temp set point, F
    *s *e TEMP_GZ zn_tzspC		// current step cooling set point, F

    *h TEMP_GZ zn_tzspHlh		// end-of-last-hour heating set point (re autosize setpoint ramping), F
    *h TEMP_GZ zn_tzspDlh		// end-of-last-hour desired temp set point (re autosize setpoint ramping), F
    *h TEMP_GZ zn_tzspClh		// end-of-last-hour cooling set point (re autosize setpoint ramping), F

	*s *e SI zn_hcMode			// heating / cooling mode required per set point (rsmHEAT, rsmCOOL, )
								//   (may not match RSYS.rs_mode due to e.g. RSYS availability or
								//    conflicting zone requests)

								// HVAC convective delivery fraction (TODO: now all 1, 6-2012)
	*s FLOAT zn_fConvH			//    heating
	*s FLOAT zn_fConvC			//    cooling
	*s FLOAT zn_fConv			//    current step

// runtime comfort calcs (only for CZM zones 1-20-11)
#ifdef COMFORT_MODEL
	*declare "class CThermalComfort* zn_pComf;"	// interface to comfort models
	*s *e FLOAT zn_comfPMV7730		// ISO 7730 Predicted mean vote (0 = neutral)
	*s *e FLOAT zn_comfPPD7730		// ISO 7730 prediced percent dissatisfied
#endif

// ZNR runtime subhourly hvac a,b,c,q's.  *hide; not fully analyzed re note 1, note 2.

    *s *e *hide DBL zn_aqHvO    // hvac a + q except active terminal: sum of lh q's and ah cz*Ts's
    *s *e *hide DBL zn_bHvO	    // hvac b except active terminal: sum of ah tu cz's
                //aqO,bO			for loads plus all zhx's but active: __LdSh+__Hvo: in TERMINAL cuz AH's update them as they go.
                //cO			total flow (heat cap units) except active zhx: same as bHvO, use that.
    *s *e *hide DBL zn_aq  	// zone total a+q: loads and all terminals including active
    *s *e *hide DBL zn_b	// zone total b ditto.
    //aStA  			set-temp active (tstat) zhx part of 'a' for current md; 0 if floating. compute if need found.
    //bStA  			.. b.
    *s *e *hide DBL/*CFLOW*/ cM	// 0 if floating or or active-zhx heat cap flow to zone (after leaks) for current mode (Btuh/F)
    *s *e *hide DBL qM   	// 0 if floating or power of active zhx: q to yeild setpoint (Btuh).
    *s *e DBL zn_qsHvac 	// subhour total (sensible) power of all hvac, Btuh
							//   NB: power (Btuh) q is *subhrDur'd to yield energy (Btu) q's for results.
    *s *e DBL zn_qlHvac		// subhour total latent power (Btuh) (moisture * 1061) likewise
#if 0	// unused, 9-12
x  	*s *e DBL zn_qsHvacls	// last subhour zn_qsHvac
x   *s *e DBL zn_qlHvacls	// last subhour zn_qlHvac
#endif
    *s *e DBL zn_qlIz		// latent gain from IZXFER sources (infil, vent, and duct leakage), Btuh
							//   does NOT include HVAC
	*s *e DBL zn_rho		// zone moist air density at nominal w=tp_refW, lb/cf
	*s DBL zn_rho0ls		// prior step zone moist air density at nominal z=0, lb/cf; computed from tzls and zn_pz0[ 0]
	*s *e DBL zn_dryAirMass	// total mass of *dry* air in zone, lbm
	*s *e DBL zn_dryAirMassEff	// effective dry air mass in zone, lbm
								//  = zn_dryAirMass*i.zn_HIRatio except when zone moisture time constant
								//    requires increase for numerical stability
								//    See zn_AirXMoistureBal()
	*s *e FLOAT zn_ivAirX	// zone infiltration/ventilation air change rate (changes/hr)
							//   includes flow induced by system (HVAC, duct leakage, )
							//   but not system flows
	*s *e FLOAT zn_airX		// overall zone air change rate (changes/hr)
							//   includes *all* air flows; used re convective coeff determination

	// *s *e FLOAT i.zn_hcAirX	// zn_airX + add'l 4.8 ACH for non-air zones having HVAC loads
								//   inputable for testing; used re convection coeff model
	*s FLOAT zn_hcAirXls	// prior subhour value of i.zn_hcAirX
	*s FLOAT zn_hcFrc		// inside surface forced convection coefficient, Btuh/ft2-F
	*s FLOAT zn_windPresV	// wind velocity pressure, lbf/ft2
							//     zone-specific per zn_EaveZ and zn_infShield

// ZNR runtime humidity balance equation variables
// wcSum turns out to be unused 6-92; later code out, rename wcSum1 back if still unused.
    *s *e *hide DBL /*CFLOW*/ cSum		// c:   total ah flow to zone (after duct leaks): part of 'bw' for hum bal eqn.
    *s *e *hide DBL /*CFLOW*/ wcSum		// wc:  sigma(tu->cz*ah->ah_wSup): sum of ah flows each times its supply w: part of 'aw'.
    *s *e *hide DBL /*CFLOW*/ wcSum1	// wc1: wc, possibly using average not latest ws, for humidity algorithm.

// ZNR runtime zone temps and w's
    *s *e DBL /*TEMP*/ tz		// zone air temp: official copy for results: active setpoint or floating
    *s *e DBL /*TEMP*/ aTz		// air handler working copy of tz, possibly abandoned if change very small.
    *s *e DBL /*HUMRAT*/ wz		// zone humidity ratio (w)
    *s *e FLOAT zn_relHum		// zone relative humidity, 0 - 1
	*s FLOAT zn_relHumls;		// zone relative humidity, end last subhour, 0 - 1
	*h FLOAT zn_relHumlh;		// zone relative humidity, end last hour, 0 - 1
    *s *e DBL zn_twb			// zone wet bulb temp, F
    *s *e DBL /*HUMRAT*/ aWz	// air handler working copy of wz, possibly abandoned if change very small.
    *s DBL /*TEMP*/ tzls    	// zone temp, end last subhour, F
    *s DBL /*HUMRAT*/ wzls  	// zone hum rat, end last subhour (same as wz in 1st iteration of subhr)
    *h DBL /*TEMP*/ tzlh    	// zone temp, end last hour
    DBL /*TEMPDIFF*/ tzlsDelta	// zone temp change during last subhour: tzls - tz at end subhour
    DBL /*HUMRAT*/ wzlsDelta	// zone hum rat change during last subhour: wzls - wz at end subhour
	*declare "DBL zn_Rho0() const;"

							// re radiant/convective model
	*s *e DBL /*TEMP*/ zn_tr	//  zone radiant temp, F
	*s *e DBL /*TEMP*/ zn_trls	//  zone radiant temp, end last subhour, F
	*h DBL /*TEMP*/ zn_trlh	    //  zone radiant temp, end last hour, F

// ZNR runtime hvac internal, mostly sub or hourly
    *s *e SI zn_md				// current hvac mode: subscript of mdSeq
    *h *e *hide SI nMd			// number of modes: number of used entries in mdSeq[]
    *s *e *hide *array MAX_ZONEMODES SI mdSeq	// mode sequence table: SI mdSeq[21].
    						// contains subscript of active ZHX, or MDS_FLOAT (-1) for floating mode.

// ZNR runtime: temps used by air handler, not valid outside of air handler
    *s *e *hide DBL tuCz	    // zone flow: tu->znC(tu->aCv): cv less leaks (terminal flow, set/used here by AH::upCouple())
    *s *e *hide DBL tuCzWas   	// prior zone flow -- tu->znC(tu->aCv) at entry to ah (likewise)

    /* note 1: items set at end interval: should they be flagged *e?
	       tentatively no, useage more flexible if not.
	          nb probing gets prior interval value; document it thus; change names to include "prior"?
	       best solution might be current *e and prior copies, as with results:
	       1.  flag *e, allowing probe only at end inverval: so current could be shown in reports, but most
	           other probes would get error messages.
	       2.  and have another member containing a copy of it, not *e, but named and documented to reflect
	           the fact that it is last interval's value.
               Meanwhile, use flexibility could perhaps be improved with a method to force probing at end interval.
       ADDITION 3-92: now have loadsAfterHour and such fcns, called AFTER probes/reports.  Moving end-interval computations
       there, when applicable, will make the variable appear as a pure, clean, start-interval 'prior' to probes. ***
       NOTE 11-95: tending toward flagging these *e for safety, and adding probable prior's only when clear need found. */

    /* note 2: set in cghinit, currently 1-92 called AFTER exprs evaluated, probe at start hour will get stale value
	       (but not a clean end-hour item as probing after subhour 0 will get current hour's value).
	       A way to force end-interval probing would get good current hour value for reports.  *hide for now. */

// ZNR runtime: change flags for recompute control. Cleared in ztuCompute. "story" carefully to avoid contradictory uses.
    //re terminal code inputs, cleared in ztuCompute().
    *s *e *hide BOO spCf    	// setpoint of any tu or natvent zhx for zone changed (exman chaf's, cnztu.cpp): redo mode sequence.
    *s *e *hide BOO ztuCf	    // terminal change other than setpoint: zone load (aqLdSh/bLdSh, w), inputs, limits, .
            				    // set: loadsHourbeg, loadsSubhr, hvacIterSubhr, TU::tu_BegHour, AH::ah_SetMode,ahVshNLims,flagTus, , .
    				            // tested/cleared: ztuCompute.  tested to call ztuCompute: hvacIterSubhr. */

// ZNR runtime: Pr's: prior values for comparison in setting above change flags
    *s *e *hide DBL   zn_xqHrPr			// for cnloads:loadsHourBeg re b * t - a changes 12-94
    *s *e *hide DBL   zn_xqShPr			// for cnloads:loadsSubhr ditto 12-94
    *s *e *hide FLOAT qIzShPr
    *s *e *hide FLOAT tzlsPr
    *s *e *hide FLOAT wzlsPr
    *s *e *hide SI zn_mdPr		        // ..
    *s *e *hide DBL   znLGainPr					// for cnloads.cpp:loadsHourBeg and loadsSubhr.

*END					// ZNR
//========================================================================================================
RECORD ZNRES_IVL_SUB "zone interval results sub" *SUBSTRUCT	// zone interval result substruct for ZNRES_SUB for ZNRES

// For accumulation of values for one interval: subhourly, hrly, daily, monthly, or annual.
// Organized as a group of SI's (accumulated) followed by a group of FLOAT's.
// The floats are grouped as temps (average; first), counts (accumulate), and heats (accumulate and balance check).

// CAUTION: when changing check carefully: cnguts.h, cnguts.cpp, cgenbal.cpp; grep for uses of ZRxxxx defines. 12-91.

	*declare "double zr_TotAbsSen() const;"
	*declare "double zr_TotAbsLat() const;"
	*declare "void zr_Init1( int options=0, const ZNR* zp=NULL);"
	*declare "void zr_Zero() { memset( this, 0, sizeof( ZNRES_IVL_SUB)); }"	// 0 all (bitwise)

    INT n		// accumulate call count (to convert sums to averages)
				//   code assumes this is 1st member
//ints. code in cnguts.h and cnguts.cpp:cgaccum assumes SI members are together, start with nHrHeat, end with nHrCeilFan.
    //   6-92 there is now no code to set these hourly+ SI members... eventually use or delete; work out sh-->hr accumulation.
    SI nHrHeat   	// # of hours in which any heating occurred; 1st "# of hours"
    SI nHrCool		//    ditto cooling
    SI nHrFanv  	//    ditto fan vent
    SI nHrNatv  	//    ditto natural vent
    SI nHrCeilFan	//    ditto ceiling fan operation; last "# of hours"
//LIs. code in cnguts.h and .cpp assumes LI members together, first is nIter, last is nSubhrLX.
    LI nIter		// # of iterations
    LI nShVentH		// # of substeps int this interval when ventilation caused heating
					//   (initial implementation for OAV only, 10-13)
    LI nSubhr		// subhour counter (convenience)
    LI nSubhrLX		// # subhours with condensation (excess latent gain)
//floats. code in cnguts.h and cnguts.cpp:cgaccum assumes float members together, including subgroups to average and to sum.
 //floats to average
    float tAir   	// zone air temp; must be 1st float, is first float to average (see cnguts.h)
    float tRad		// zone radiant temp; meaningful iff convective/radiant model active for this zone
					// comfort statisitics (not computed for all zones)
    float PMV7730	//    ISO7730 predicted mean vote = predicted comfort per ASHRAE thermal sensation scale
					//       +3=hot, +2=warm, +1=slightly warm, 0=neutral, -1=slightly cool, -2=cool, -3=cold
    float PPD7730	//    ISO7730 predicted percent dissatisfied = % of people not satisfied with conditions
    float ivAirX	// zone air exchange rate not including HVAC or ducts, ACH
    float pz0		// zone air pressure relative to patm at nominal z=0, lbf/sf (from zn_pz0)
    float wAir		// zone air humidity ratio; last float to average
 //floats to sum: qCond thru qlBal/litEu, incuding subSubGroups of sensible and latent heats
  //1. sensible heats for heat balance: qCond thru qsMech (cgenbal.cpp)
    float qCond  	// zone wall conduction gain, Btu; 1st heat flow and first float to sum
    float qsInfil 	// zone infiltration sensible gain, Btu
    float qSlr   	// zone solar gain, Btu
    float qsIg    	// zone internal sensible gain, Btu
    float qMass  	// zone net sensible transfer from mass, Btu.  See qlAir for moisture.
    float qsIz    	// interzone gain to zone, Btu
    float qsMech  	// zone total sensible mechanical heat gain, Btu
                    //   includes HPWH heat removal
    float eqfVentHr	// equivalent full vent hours = sum( zn_fVent)
  //2. latent heats for latent heat balance: qlInfil thru qlMech
    float qlInfil	// zone infiltration latent gain, Btu
    float qlIg    	// zone internal latent gain, Btu
    float qlIz		// zone IZXFER latent gain (infil, vent, duct leakage)
    float qlAir		// latent heat of moisture removed from zone air: moisture analog of znCAir.
    float qlMech	// zone latent mechanical heat gain, Btu; last heat flow and last float to sum
  //3. floats to sum, not included in either balance
    float qsBal  	// sensible balance: sum of sensible heats, should be near 0. Set in cnguts.cpp.
    float qlBal  	// latent balance similarly.  Consider removing Bals after development.
    float qlX		// latent gain rejected to prevent zone supersaturation === heat of condensation.
					//   - added to next subr sens gain. Btu.

    *array 2 float unMetHrDH	// end-of-hour tz excursion below/above setpoint, deg-hr
                                //  [ 0]=heating (<0)  [ 1]=cooling (>0)
    *array 2 float unMetShDH	// subhour tz excursion below/above setpoint, deg-hr
                                //  [ 0]=heating (<0)  [ 1]=cooling (>0)
    *array 2 float unMetHrs	    // unmet hours (accumulated subhourly, tz excursion > 0)
                                //  [ 0]=heating  [ 1]=cooling
    *array 2 float unMetHrsTol 	// unmet hours (accumulated subhourly, tz excursion > tp_unMetTzTol)
                                //  [ 0]=heating  [ 1]=cooling

    float qscHvac   // zone accumulated HVAC sensible cooling, Btu (<=0) (OAV not included)
    float qshHvac   // zone accumulated HVAC sensible heating, Btu (>=0)
    float qcMech	// zone accumulated total mechanical (sensible + latent) cooling (including HPWH heat extraction), Btu (< 0)
    float qhMech	// zone accumulated total mechanical (sensible + latent) heating (including HPWH heat extraction), Btu (>0)
    float qvMech	// zone accumulated mechanical (OAV) total (sensible + latent) heat gains, Btu (< 0)
    float litDmd	// zone lighting demand and Energy Use, ...
    float litEu   	// ... from GAINs, in addition to posting Eu to meter, re daylighting for NREL. 9-94.
// floats that track min/max value
    *array 2 float unMetMaxTD   // maximum tz excursion below/above setpoint, F
                                //  [ 0]=heating (<0)  [ 1]=cooling (>0)    
*END		// ZNRES_IVL_SUB
//=============================================================================
RECORD ZNRES_SUB "zone results sub" *SUBSTRUCT
	// holds zones or all-zones current or prior simulation results for all intervals
    // CAUTION: code assumes these are in order matching IVLCH, so can add IVLCH-1 to ptr to .Y to access M,D,S. eg in cgresult.cpp.
    *y *nest ZNRES_IVL_SUB Y	// run results, aka year or annual
    *m *nest ZNRES_IVL_SUB M	// month
    *d *nest ZNRES_IVL_SUB D	// day
    *h *nest ZNRES_IVL_SUB H	// hour.
    *s *nest ZNRES_IVL_SUB S	// subhour, aka subStep or sub-time-step
*END		// ZNRES_SUB
//=============================================================================
RECORD ZNRES "znRes" *RAT		// holds zones and all-zones simulation results (later at subscript # zones + 1)
    							// .name (base class): same as corresponding zone, or sum_of_zones.
	*declare "ZNR* zr_GetZone() const;"
	*declare "LI zr_GetRunTotalLI( int fn) const;"
	*declare "void zr_InitPrior();"
	*declare "void zr_InitCurr();"

    *e *noname *nest ZNRES_SUB curr  	// current year,month,day,hour,subhr results, stored at end each interval
    *nest ZNRES_SUB prior 				// prior year,month,day,hour,subhr results, available throughout interval
    // CAUTION: code assumes prior and curr arranged so can offset from curr to prior. eg in cnguts.cpp.
*END		// ZNRES
//=============================================================================
RECORD ANDAT "AirNet data sub" *SUBSTRUCT		// working data for AirNet
   *prefix ad_
   *declare "void ad_ClearResults();"
   *declare "void ad_Setup( IZXRAT* pIZXRAT);"
   *declare "void ad_SetupPresDep();"
   *declare "RC ad_MassFlow( double delP);"
   *declare "void ad_SetFromFixedAVF( double avf);"
   *declare "void ad_DupHERV( const ANDAT& ad);"

   *r *hide IZXRATP ad_pIZXRAT	// parent pointer
   *h AREA_GEZ ad_Ae		// effective vent area, ft2; function of vent type and iz_cd
   *h AREA_GEZ ad_AeLin		// modified iz_Ae, ft2; prevents discontinuity at delPLinear
   *s *e DBL ad_delP		// pressure diff across element, lbf/sf (+ = pz1 > pz2)
   *s *e DBL ad_mdotP		// air mass flow rate, (lbm moist air)/sec (+ into z1)
							//   pressure driven: derived via pressure balance
							//   fixed flow: as set
   *s *e DBL ad_dmdp		// derivative of ad_mdotP wrt pressure (0 for fix flow)
   *s *e DBL ad_mdotB		// add'l buoyancy-driven mass flow, (lbm moist air)/sec
							//   balanced flow z1 <-> z2, used only for _ANHORIZ
   *s *e DBL ad_mdotX		// air mass exhaust flow, (lbm moist air)/sec (+ out of z2)
							//   HERV = exhaust flow
							//   Other = ad_mdotP
   *s *e DBL ad_xDelpF		// buoyancy flooding pressure factor
   *s *e DBL ad_xMbm		// buoyancy max possible flow factor
   *s *e DBL ad_tdFan		// air stream temp rise across fan, F
   *s *e DBL ad_pFan		// fan (electrical) power for meter, Btuh (*not* W)
*END
//=============================================================================
RECORD HEATEXCHANGER "heat exchanger sub" *SUBSTRUCT  // Used in DOAS and AIRHANDLER
    *prefix hx_

    *declare "RC hx_setup( record *r, SI parentFieldNum);"
    *declare "void hx_begSubhr(AIRFLOW supInletAF, AIRFLOW exhInletAF, DBL tWant);" // calculates bypass and final outlet air state given setpoint
    *declare "void hx_calc();"   // calculates hx only, called by begSubhr() 
    *declare "double hx_calcBypass(float bypassFraction);"  // returns outlet temperature for a given bypass fraction

    // Heat exchanger inputs
    *i AFLOW_GZ hx_VfDs           // Design supply volumetric flow rate of the heat exchanger
                                    // defaults to supply fan VfDs
    *i FLOAT_GZ hx_f2             // Flow fraction for second set of inputs (default 0.75)
    *array 2 *i FRAC hx_senEffH   // Heat exchanger heating sensible effectiveness
                                        //   [ 0]: at design 100% flow
                                        //   [ 1]: at hx_F2
    *array 2 *i FRAC hx_latEffH   // Heat exchanger heating latent effectiveness
                                        //   [ 0]: at design 100% flow
                                        //   [ 1]: at hx_F2
    *array 2 *i FRAC hx_senEffC   // Heat exchanger cooling sensible effectiveness
                                        //   [ 0]: at design 100% flow
                                        //   [ 1]: at hx_F2
    *array 2 *i FRAC hx_latEffC   // Heat exchanger cooling latent effectiveness
                                        //   [ 0]: at design 100% flow
                                        //   [ 1]: at hx_F2
    *i NOYESCH hx_bypass              // HX can be bypassed when not adventatgeous
    *s FLOAT_GEZ hx_auxPwr        // Auxiliary power, W
    *i TI hx_auxMtri              // Meter for auxiliary power
    *declare "MTR* hx_pAuxMtr;"
    // TODO: Add defrost control (see EnergyPlus options)

    // Outputs
    *s *e *nest AIRFLOW hx_supInAF  // Supply inlet air flow (splits to hx_hxInAF
                                    // and hx_bypassAF based on hx_bypassFrac)
    *s *e *nest AIRFLOW hx_hxInAF  // HX supply inlet air flow
    *s *e *nest AIRFLOW hx_hxOutAF  // HX supply outlet air flow
    *s *e *nest AIRFLOW hx_bypassAF  // Bypass air flow
    *s *e *nest AIRFLOW hx_exhInAF  // Exhaust inlet air flow
    *s *e *nest AIRFLOW hx_supOutAF // Supply outlet air flow (mixes to hx_hxInAF
                                    // and hx_bypassAF based on hx_bypassFrac)
    // *s *e *nest AIRFLOW hx_exhOutAF // Exhaust outlet air flow, not yet needed

    *s *e FRAC hx_bypassFrac        // Fraction of supply inlet air bypassing heat exchanger
    *s *e DBL hx_tSet               // Setpoint temperature for air exiting heat exchanger
    *s *e FRAC hx_sensEff           // Sensible efficacy
    *s *e FRAC hx_latEff            // Latent efficacy
   


*END		// HEATRECOVERY

//-----------------------------------------------------------------------------
RECORD DOAS "doas" *RAT
    *prefix oa_
    *declare "RC oa_CkfDOAS();"
    *declare "RC oa_Setup( DOAS* iRat);"
	*declare "RC oa_BegSubhr();"
	*declare "RC oa_EndSubhr();"

    // Fan inputs
    *i *nest FAN oa_supFan      // supply fan characteristics
    *i *nest FAN oa_exhFan      // exhaust fan characteristics

    // Tempering coil inputs
    *s TEMP oa_supTH            // supply temperature heating setpoint
    *s FLOAT_GEZ oa_EIRH         // heating coil energy input ratio (1/efficiency (or 1/COP)
    *i TI oa_coilHMtri          // Meter for heating coil
    *declare "MTR* oa_pCoilHMtr;"
    *s TEMP oa_supTC            // supply temperature cooling setpoint
    *s FLOAT_GEZ oa_EIRC         // cooling coil energy input ratio (1/efficiency (or 1/COP)
    *s FRAC_GZ oa_SHRtarget     // target cooling coil SHR. Could be overriden by oa_SHR.
    *i TI oa_coilCMtri          // Meter for heating coil
    *declare "MTR* oa_pCoilCMtr;"

    *i TI oa_loadMtri           // LOADMTR idx for accumulation of coil output
    *declare "LOADMTR* oa_pLoadMtr;"

    // Heat Exchanger
    *r *nest HEATEXCHANGER oa_hx  // heat exchanger substruct

    // Outputs
    *s *e *nest AIRFLOW oa_supAF    // Supply air flow going to IZXFERs (before supply fan, fan heat added to IZXFERs)
    *s *e *nest AIRFLOW oa_exhAF    // Exhaust air flow coming from IZXFERs
    *s *e FLOAT oa_supQSen          // Sensible heat added (+) or removed (-) from the supply for tempering
    *s *e FLOAT oa_supQLat          // Latent heat added (+) or removed (-) from the supply for tempering
    *s *e FRAC_GZ oa_SHR            // actual cooling coil SHR. Same as oa_SHRtarget unless adjusted for humidity limits.

*END
//-----------------------------------------------------------------------------
RECORD IZXRAT "izXfer" *RAT	// interzone heat transfers: conductive and/or vent.
    *prefix iz_
    *excon		// explicit constructor
   	*declare "void FixUp();"	// virtual
    *declare "RC Validate( int options=0);"
    *declare "RC iz_CkfIZXFER();"
	*declare "void iz_ClearResults( int iV);"
    *declare "RC iz_Setup( IZXRAT* izie);"
	*declare "void iz_AfMtrCats();"
	*declare "void iz_SetupAfMtrs();"
	*declare "RC iz_SetupNonAirNet();"
	*declare "bool iz_HasVentEffect() const;"
	*declare "bool iz_MightBeNatVent() const;"
	*declare "RC iz_BegHour();"
	*declare "RC iz_BegSubhr();"
	*declare "void iz_SetupPresDep();"
	*declare "void iz_GetZn2Conditions();"
	*declare "void iz_ClearZn2Conditions();"
	*declare "void iz_GetExteriorConditions( float windPresV);"
	*declare "void iz_GetDOASConditions();"
	*declare "RC iz_CalcHERV();"
	*declare "RC iz_Calc();"
	*declare "RC iz_MassFlow( int iV);"
	*declare "RC iz_ZoneXfers( int iV);"
	*declare "RC iz_EndSubhr();"
	// CAUTION: the following depend on C_IZNVTYCH_xxx values
	*declare "BOOL iz_IsAirNet() const { return iz_nvcntrl > C_IZNVTYCH_TWOWAY; }"
	*declare "BOOL iz_CanHaveAFCat() const { return iz_IsAirNet(); }"
	*declare "BOOL iz_IsExterior() const { return iz_nvcntrl == C_IZNVTYCH_ANEXT || iz_nvcntrl == C_IZNVTYCH_ANEXTFAN || iz_nvcntrl == C_IZNVTYCH_ANEXTFLOW; }"
	*declare "BOOL iz_IsAirNetIZ() const { return iz_nvcntrl == C_IZNVTYCH_ANIZ || iz_nvcntrl == C_IZNVTYCH_ANIZFAN || iz_nvcntrl == C_IZNVTYCH_ANIZFLOW || iz_nvcntrl == C_IZNVTYCH_ANHORIZ || iz_IsHERVIZ(); }"
	*declare "BOOL iz_IsHERV() const { return iz_nvcntrl == C_IZNVTYCH_ANHERV; }"
	*declare "BOOL iz_IsHERVIZ() const { return iz_IsHERV() && iz_zi2 != 0 && iz_zi1 != iz_zi2; }"
	*declare "int iz_IsCZ( int iZn) const;"
	*declare "BOOL iz_IsFan() const { return iz_nvcntrl == C_IZNVTYCH_ANIZFAN || iz_nvcntrl == C_IZNVTYCH_ANEXTFAN; }"
	*declare "BOOL iz_HasFan() const { return iz_IsFan() || iz_IsHERV(); }"
	*declare "BOOL iz_IsFlow() const { return iz_nvcntrl == C_IZNVTYCH_ANIZFLOW || iz_nvcntrl == C_IZNVTYCH_ANEXTFLOW; }"
	*declare "BOOL iz_IsDOAS() const { return iz_nvcntrl == C_IZNVTYCH_ANDOAS; }"
	*declare "BOOL iz_IsDuctLk() const { return iz_nvcntrl == C_IZNVTYCH_ANDUCTLK; }"
	*declare "BOOL iz_IsSysAir() const { return iz_nvcntrl == C_IZNVTYCH_ANSYSAIR; }"
	*declare "BOOL iz_IsSysOrDuct() const { return iz_IsDuctLk() || iz_IsSysAir(); }"
	*declare "BOOL iz_IsOAVRelief() const { return iz_nvcntrl == C_IZNVTYCH_ANOAVRLF; }"
	*declare "void iz_SetFromAF( const AIRFLOW* pAF);"
	*declare "BOOL iz_IsFixedFlow() const { return iz_HasFan() || iz_IsFlow() || iz_IsDuctLk() || iz_IsSysAir(); }"
	*declare "BOOL iz_IsIZ() const { return !iz_IsAirNet() || iz_IsAirNetIZ(); }"
	*declare "void iz_SetFromMCp( double mCp, double mCpT=0.);"
	*declare "static const double delPLinear;"		// pressure diff, lbf/sf, below which eqns are approximated
													//   with linear form to avoid undounded dmdp
													//	 = .000001
  // inputs
    *r TI iz_zi1		// subscripts of zones involved (air flow > 0 = into zone 1)
    *r TI iz_zi2		//   iz_zi2 = -1 iff not interzone
    *r TI iz_doas       // subscript of DOAS where air is supplied from (air flow > 0), or exhausting to (airflow < 0)
    *h UA iz_ua   		// air-to-air coupling const (Btuh/F) thru walls etc.
    *i IZNVTYCH iz_nvcntrl	// Control type for nat vents:
						//   C_IZNVTYCH_NONE: no venting (iz_ua only)
						//   C_IZNVTYCH_ONEWAY: "diode" variant of 2 way (xfer iff t1 > t2)
						//   C_IZNVTYCH_TWOWAY: high/low/hdiff vent (pre-2010)
						//   C_IZNVTYCH_ANEXT: airnet vent to exterior (zi2=-1)
						//   C_IZNVTYCH_ANIZ: airnet vent between zones
						//   C_IZNVTYCH_ANHORIZ: airnet large horiz opening (e.g. stairwell)
						//   C_IZNVTYCH_ANEXTFAN: airnet fan to/from exterior (zi2=-1)
						//   C_IZNVTYCH_ANIZFAN: airnet fan between zones
						//							 fan flow adds fan heat / uses electricity
						//   C_IZNVTYCH_ANEXTFLOW: airnet specified flow to/from exterior (zi2=-1)
						//   C_IZNVTYCH_ANIZFLOW: airnet specified flow between zones
						//							  specified flow transfers air (no fan heat, no elec)
						//   C_IZNVTYCH_ANHERV: heat/energy recovery ventilator
						//   C_IZNVTYCH_ANDUCTLK: duct leakage
						//   C_IZNVTYCH_ANSYSAIR: system air flow
						//   C_IZNVTYCH_ANOAVRLF: RSYS OAV relief air
						//                        ( = interzone hole sized per flow)
	*r AFCAT iz_afCatI	// air flow input category (accounting only) C_AFCAT_xxx
						//    or 0 = unknown
						//    resolved to iz_afMtrCat1 and iz_afMtrCat2 for runtime

						// AFMTR pointers, derived from zone zn_afMtri
						//   NULL if not specified or same on both sides of IZ type
    *declare "AFMTR* iz_pAfMtr1;"	// for iz_zn1
    *declare "AFMTR* iz_pAfMtr2;"	// for iz_zn2
	*declare "bool iz_doingAfMtr;"	// true iff iz_pAfMtr1 or iz_pAfMtr2 != NULL
						// runtime air flow categories re UZ/CZ distinction for IZ flow
	*r SI iz_afMtrCat1	//   ... for iz_pAfMtr1
	*r SI iz_afMtrCat2	//   ... for iz_pAfMtr2

    *h AREA_GEZ iz_a1  	// vent area 1, ft2
						//   _TWOWAY = low vent area
						//   AirNet = minimum vent area ("infil only")
    *h AREA_GEZ iz_a2  	// vent area 2, ft2
						//   _TWOWAY = high vent area
						//   AirNet = maximum vent area ("infil + vent")
						//            BUT note it is OK if a1 > a2
    *i LEN_GZ iz_L1		// opening dim 1, ft (_ANHORIZ)
    *i LEN_GZ iz_L2		// opening dim 2, ft
    *i FLOAT iz_hz		//   _AN (non FAN): height of iz_a1 relative to arbitrary 0 (ft)
						//   _TWOWAY: height a1 - height a2 difference (ft)

	*i FLOAT_GEZ iz_stairAngle	// stair angle, deg (_ANHORIZ) (90 = vert)
								//   default = 34 deg
    *i FRAC_GZ iz_cd	// orifice coefficient, dimless (user input, default 0.8)
    *r FLOAT iz_exp		// power law exponent, (user input, default 0.5)
    *i FLOAT iz_cpr		// wind pressure coefficient (ignored if not _ANEXT)

				        // fan volume flow (cfm, += into zone1; if <0, fan is exhaust)
    *s AFLOW iz_vfMin	//    min vent flow rate, cfm (for fixed flow types)
						//      (*net* supply flow for _ANHERV)
    *s AFLOW iz_vfMax	//    max vent flow rate, cfm (for fixed flow types)
    *s FRAC iz_ASEF		// apparent sensible effectiveness (for _ANHERV)
    *s FRAC iz_LEF		// latent effectiveness (for _ANHERV)
	*s FRAC iz_SRE		// HVI sensible recovery efficiency (for _ANHERV)
	*s FRAC iz_ASRE		// HVI adjusted sensible recovery efficiency (for _ANHERV)
	*s FRAC iz_RVFanHeatF	// fraction of HERV fan power that heats supply air (experimental)
							//   default 0
    *s FLOAT iz_vfExhRat // exhaust ratio (for _ANHERV) = (vfGross exhaust)/(vfGross supply)
						//  default = 1 (balanced)
	*s FRAC iz_EATR		// exhaust air transfer ratio (for _ANHERV)
						//  vfGross = vfNet / (1.-EATR)
    *i *nest FAN iz_fan	// vent fan characteristics (unused if not fan type)

  // derived / internal
   	*declare "const AIRFLOW* iz_pAF;"	// pointer to air flow source
   										//  re C_IZNVTYCH_ANDUCTLK / ANSYSAIR
    *r FLOAT iz_nvcoeff				// nat vent overall coeff Btuh/(dt^.5). set by izxSetup().
    *s *e *nest AIRSTATE iz_air1	// z1 air state (tdb and w)
    *s *e *nest AIRSTATE iz_air2	// z2 air state (may be ambient or from DOAS)

    *declare "inline float iz_T( int i) { return i ? iz_air2.as_tdb : iz_air1.as_tdb; }"
    *s float iz_rho1	// z1 moist air density, lb/cf
    *s float iz_rho2	// z2 moist air density, lb/cf (may be ambient or from DOAS)
    *declare "inline float iz_Rho( int i) { return i ? iz_rho2 : iz_rho1; }"
    *s *hide float iz_pres2	// z2 pressure (or portion thereof, see code), lbf/sf
    *array 2 *s *e *nest ANDAT iz_ad		// airnet working data
											//   [ 0]: infil only
											//   [ 1]: infil+vent
	*s *e float iz_amfNom;		// nominal air mass flow, lbm/sec
								//   = fVent weighted average of iz_ad[ 0] and iz_ad[ 1]
								//   NOTE: approximate when fVent not 0 or 1
*END		// IZXRAT
//=============================================================================
RECORD AIRNET "AirNet" *SUBSTRUCT *hideall	// AirNet calculation storage / code
*prefix an_
*excon	// explicit constructor
*exdes	// explicit destructor
*ovrcopy
*declare "RC an_Calc( int vMode);"
*declare "void an_ClearResults( int vMode);"
*declare "inline double& an_JAC(int i, int j) { return *(an_jac + i*an_nz + j); }"

*r DBLP an_jac		// jacobian matrix (nz x nz)
*r DBLP an_V1		// residual/correction vector #1 (nz)
*r DBLP an_V2		// residual/correction vector #2 (nz)
*r DBLP an_mdotAbs	// total abs flow by zone (nz)
*r INTP an_didLast	// re relax scheme (see code) (nz)
*r INT an_nz		// # of zones
*r *ARRAY 2 INT an_resultsClear	// flag: nz iff mode results have been cleared
								//   (avoid repeated clear in an_ClearResults())

*END	// AIRNET
//=============================================================================
#if 0	// not needed, save for possible use, 4-12
x RECORD DUCTMODE "DuctMode" *SUBSTRUCT *hideall
x *prefix dsm_
x
x *r DBL dsm_mCp		// air heat capacity flow rate, Btuh/F
x
x *r DBL dsm_beta		// segment loss parameter
x   					//  = 1 - effectiveness
x
x *END	// DUCTMODE
#endif
//-----------------------------------------------------------------------------
RECORD DBC "DBC" *SUBSTRUCT *BASECLASS SBCBASE	// duct boundary condition
*prefix sb_
*declare "void sb_Init( DUCTSEG* pDS);"
*declare "virtual double sb_AreaNet() const;"
*declare "virtual const char* sb_ParentName() const;"
*declare "virtual int sb_Class() const;"
*declare "void sb_SetRunConstants( ZNR* zpx);"
*declare "void sb_SetCoeffs( ZNR* zpx);"

*i DUCTSEGP sb_pDS			// pointer to parent DUCTSEG

*END // DBC
//-----------------------------------------------------------------------------
RECORD DUCTSEG "DuctSeg" *RAT	// duct segment
*prefix ds_
*excon	// explicit constructor
*exdes	// explicit destructor
*ovrcopy
*declare "void ds_Init( int options=0);"
*declare "ZNR* ds_GetExZone() const;"
*declare "RSYS* ds_GetRSYS() const;"
*declare "DUCTSEGRES* ds_GetDUCTSEGRES() const;"
*declare "RC ds_Ckf();"
*declare "bool ds_IsRound() const;"
*declare "RC ds_TopDS( const DUCTSEG* pDSi);"
*declare "void ds_SetRunConstants();"
*declare "RC ds_SetSizeFromAVF( float avf);"
*declare "double ds_InsulK( float T) const { return ds_insulKA + ds_insulKB * T; }"
*declare "int ds_IsSupply() const { return ds_ty == C_DUCTTYCH_SUP; }"
*declare "RC ds_BegHour();"
*declare "RC ds_BegSubhr();"
*declare "AIRSTATE ds_CalcFL( const AIRSTATE& as, double amf);"
*declare "AIRSTATE ds_CalcFLRev( const AIRSTATE& as);"
*declare "void ds_FinalizeSh( float runF);"
*declare "void ds_AfterSubhr();"
*declare "void ds_DbDump() const;"

*i DUCTTYCH ds_ty				// type: C_DUCTTYCH_RET / _SUP
*s *noname *nest DBC ds_sbcO	// (outside) surface boundary conditions
								//   represents coupling(s) between duct exterior
								//   surface and adjacent zone or ambient

*i FLOAT_GEZ ds_exArea		// exterior heat transfer surface area, ft2 (outside of insulation)
							//   if input, flat area-only model is used, many inputs have no effect
							//   if NOT input, round ducts assumed

*i FLOAT_GZ ds_diam			// duct diameter (w/o insulation), ft
*i FLOAT_GEZ ds_len			// total length (all branches), ft
*r FLOAT_GZ ds_branchLen	// average branch length, ft
*i SI_GZ ds_branchCount		// # of branches
*i FLOAT_GZ ds_branchCFA	// floor area served per per branch, ft2
							//    used re default ds_branchCount
*i FLOAT_GZ ds_airVelDs		// design air velocity, fpm
							//   re flow-based sizing

*i FLOAT_GEZ ds_inArea		// interior surface area, ft2
							//   = inside wetted area / duct surf area w/o insulation
							//   (duct wall thickness assumed negligible)

*i FLOAT_GEZ ds_insulR		// rated insulation resistance, ft2-F/Btuh
*i TI ds_insulMati			// insulation material, 0 if none

*r DBL ds_insulKA			// constants for insul conductivity: kInsul = kA + kB*T
*r DBL ds_insulKB
*r FLOAT_GEZ ds_insulThk	// insulation actual thickness, ft
*r FLOAT ds_insulThkEff		// effective insulation thickness, ft
							//   includes outside/inside geometry effects
							//   derived from input or estimated; can be 0
*f DBL ds_RconvIn			// inside surfce convection resistance, ft2-F/Btuh
							//   based on *exterior* area (i.e. value to be used in series with
							//   effective duct insulation resistance; typ value = 0.4
*h *e DBL ds_Rduct			// total resistance from duct air to exterior surface of insulation
							//  (not including exterior surface conductances), ft2-F/Btuh
							//  based on *exterior* (exposed) area
							//  updated hourly re temp-dependent insul conductivity
							//  Never 0 assuming rs_RconvIn > 0
*h *e DBL ds_Uduct			// 1/ds_Rduct

*h *e FLOAT ds_insulREff	// effective insulation resistance, ft2-F/Btuh
							//   includes all adjustments for geometry and temperatures

*i EXCNDCH ds_exCnd			// adjacent cond: adiabatic/ambient/specT/adjZn.

*i FRAC ds_leakF			// leakage fraction, 0-1
                            //   return: leak is modelled at duct inlet (return register)
                            //   supply: leak is modelled at duct outlet (supply register)
*s *e DBL ds_uaTot			// cur step total conductance between duct air
							//   and surrounding equivalent temp, Btuh/F

*s *e FLOAT ds_beta			// cur step conduction loss parameter (1 - effectiveness)
							//   depends only on ds_uaTot and air mass flow

*array 4 *r *nest AIRSTATE ds_air	// cur step air states
									//  [ 0]=entering
									//  [ 1]=after leak addition (return only)
									//  [ 2]=average (consistent w/ conduction loss)
									//  [ 3]=leaving

*s *e DBL ds_amfFL			// dry air mass flow rate at full load, lbm/hr
*s *e DBL ds_qCondFL		// full load total conduction losses to surround (+ = out of duct), Btuh
							//   (may be old: from last calc when rsMode != rsmOFF)
*s *e DBL ds_qCond			// total conduction loss rate to surround (+ = out of duct), Btuh
							//   (may be old: from last calc when rsMode != rsmOFF)
*s *e DBL ds_qCondAir		//  ... to txa (air)
*s *e DBL ds_qCondRad		//  ... to txr (radiant)
							//  ds_qCond = ds_qCondAir + ds_qCondRad
*s *e DBL ds_qLeakSen		// leakage sensible heat loss rate, Btuh (+ = out of duct)
*s *e DBL ds_qLeakLat		// leakage latent heat loss rate, Btuh (+ = out of duct)

*END	// DUCTSEG
//=============================================================================
RECORD DUCTSEGRES_IVL_SUB "DUCTSEG interval results sub" *SUBSTRUCT	// DUCTSEGresult substruct for DUCTSEGRES

    *declare "void dsr_Clear() { memset(this, 0, sizeof(DUCTSEGRES_IVL_SUB)); }"
	*declare "void dsr_Accum( const DUCTSEGRES_IVL_SUB* src, int firstFlg, int lastFlg);"
#if 0   // future: if needed
	*declare "void dsr_SetPrior() const;"
#endif

	INT n			// number of intervals added together in this one (divisor for averages)
					//  (maintained but unused)

	// float members: qhCond is first, xx is last (see code)
    //   heating values when rsmHEAT, cooling otherwise (rsmCOOL or rsmOAV)
    //   + = out of duct
    ENERGY qhCond     // heating conduction, Btu
    ENERGY qhLeakSen  // heating leakage sensible, Btu
    ENERGY qhTotSen   // heating total sensible, Btu

    ENERGY qcCond     // cooling conduction, Btu
    ENERGY qcLeakSen  // cooling leakage sensible, Btu
    ENERGY qcTotSen   // cooling total sensible, Btu
    ENERGY qcLeakLat  // cooling leakage latent, Btu

*END		// DUCTSEGRES_IVL_SUB
//=============================================================================
RECORD DUCTSEGRES_SUB "DUCTSEG results sub" *SUBSTRUCT
    // name: same as corresponding DUCTSEG, or sum_of_DUCTSEG.
    // CAUTION: code assumes these are in order matching IVLCH
    //    so can add IVLCH-1 to ptr to .Y to access M,D,S. eg in cgresult.cpp.
    *y *nest DUCTSEGRES_IVL_SUB Y  	// run results, aka year or annual
    *m *nest DUCTSEGRES_IVL_SUB M  	// month
    *d *nest DUCTSEGRES_IVL_SUB D  	// day
    *h *nest DUCTSEGRES_IVL_SUB H  	// hour.
    *s *nest DUCTSEGRES_IVL_SUB S  	// subhour, aka subStep or sub-time-step
*END		// DUCTSEGRES_SUB
//=============================================================================
RECORD DUCTSEGRES "DUCTSEGRes" *RAT	// holds DUCTSEG and all-DUCTSEG simulation results (later at subscript #DUCTSEG + 1)
    // name: same as corresponding DUCTSEG, or sum_of_DUCTSEG.
	*e *noname *nest DUCTSEGRES_SUB curr 	// current year,month,day,hour,subhr results, stored at end each interval
#if 0   // future: if needed
    *nest DUCTSEGRES_SUB prior 			// prior year,month,day,hour,subhr results, available throughout interval
    // CAUTION: code assumes prior and curr arranged so can offset from curr to prior. eg in cnguts.cpp.
#endif
*END		// DUCTSEGRES
//=============================================================================
RECORD RSYS "RSYS" *RAT	// residential HVAC system
*prefix rs_

// *excon	// explicit constructor
*exdes	// explicit destructor
*ovrcopy
*declare "RC rs_CkF();"
*declare "RC rs_CkFCooling();"
*declare "RC rs_CkFHeating();"
*declare "RC rs_CkFCd( int mode);"
*declare "RC rs_CkFAuxHeat();"
*declare "RC rs_CkFRatio( int fn1, int fn2, int fnRat, float vMin, float vMax);"
*declare "RC rs_TopRSys1();"
*declare "RC rs_TopRSys2();"
*declare "int rs_IsZoneServed( const ZNR* zp) const { return zp->i.zn_rsi == ss; }"
*declare "RC rs_FazInit( int isAusz);"
*declare "RC rs_RddInit( int isAusz);"
*declare "void rs_RddiInit();"
*declare "RC rs_pass1AtoB();"
*declare "RC rs_begP1b();"
*declare "RC rs_endP1DsdIter( int auszMode);"
*declare "RC rs_endAutosize();"
*declare "void rs_AuszFinal();"
*declare "float rs_ClgCapNomTons( float nearest=-1.f);"
*declare "float rs_ClgCapForAMF( float amf) const;"
*declare "float rs_AMFForClgCap( float cap95) const;"
*declare "float rs_HtgCapForAMF( float amf) const;"
*declare "float rs_AMFForHtgCap( float capH) const;"
*declare "void rs_SetRunConstants();"
*declare "void rs_SetMTRPtrs();"
*declare "RC rs_SetupSizes( BOOL bAlways=TRUE);"
*declare "RC rs_SetupCapH( float avfH=-1.f, int options=0);"
*declare "void rs_SetupFanC( float avfC=-1.f);"
*declare "RC rs_SetupCapC( float avfC=-1.f, int options=0);"
*declare "RC rs_SetDuctSizes();"
*declare "void rs_SetModeAndClear( int rsModeNew, float speedF=1.f);"
*declare "void rs_ClearSubhrResults( int options=0);"
*declare "RC rs_BegHour();"
*declare "RC rs_BegSubhr();"
*declare "RC rs_EndSubhr();"
*declare "RC rs_AfterSubhr();"
*declare "RC rs_AfterHour();"
*declare "void rs_EnteringAirState();"
*declare "int rs_IsModeAvailable( int rsMode);"
*declare "int rs_IsAutoSizing() const;"
*declare "int rs_SupplyAirState( int rsMode, float speedF=1.f);"
*declare "bool rs_IsSupplyAirTempUseful( int rsMode, float tSup, float& tSupUseful) const;"
*declare "float rs_SupplyDSEAndDucts(AIRSTATE& as, float amf = -1.f);"
*declare "void rs_SupplyDSEAndDuctsRev( AIRSTATE& as);"
*declare "float rs_TSupVarFlow( float fAmf, AIRSTATE& as);"
*declare "double rs_ZoneAirRequest( double znAmfSup, int iAux=0);"
*declare "RC rs_AllocateZoneAir();"
*declare "RC rs_TotalAirRequestForSpeedF( float speedF, int options=0);"
*declare "double rs_FxCapForSpeedF( double& speedF);"
*declare "RC rs_FindRequiredSpeedF();"
*declare "RC rs_FindSpeedFForTSup( double tSup);"
*declare "double rs_TSupForSpeedF( double& speedF);"
#if 0   // incomplete/unused ideas
*declare "void rs_AvgZoneCond();"
#declare "float rs_SenHeatDelivered();"
*declare "void rs_HeatDelivered( float& qhSen, float& qcSen, float& qcLat);"
#endif
*declare "double rs_AmfRequired( double tSup);"
*declare "float rs_ACReqCap95( float senLoad);"
*declare "RC rs_FinalizeSh();"
*declare "float rs_FanHRtdPerTon( float capNomTons);"
*declare "void rs_ACFactors();"
*declare "void rs_CoolingOutletAirState( int auszMode=rsmOFF);"
*declare "void rs_HeatingOutletAirState( int auszMode=rsmOFF);"
*declare "void rs_CoolingSHR();"
*declare "float rs_CoolingEff1Spd( float tdbOut=0.f);"
*declare "float rs_CoolingCapF1Spd( float tdbOut=0.f);"
*declare "void rs_CoolingEnteringAirFactorsVS( float& capF, float& inpF) const;"
*declare "void rs_GetPerfClg( float& capTot, float& capSen, float& pwrIn) const;"
*declare "RC rs_PerfMapAC();"
*declare "RC rs_ExportCorrelationValues();"
*declare "RC rs_PerfDataASHP();"
*declare "void rs_PerfDataASHP1( FILE* f,	float tDbOut);"
*declare "float rs_PerfASHP( int ashpModel, float tDbOut, float& COP, float fanHAdj=0.f);"
*declare "float rs_PerfASHP2( int ashpModel, float tDbOut, float fanHAdj, float& capHt, float& inpHt, float& capDfHt, float& capHtMin, float& inpHtMin, float& capDfHtMin, float COPAdjF=1.f);"
*declare "int rs_IsASHP() const { return rs_type == C_RSYSTY_ASHP || rs_type == C_RSYSTY_ASHPPKGRM || rs_IsASHPHydronic() || rs_IsASHPVC(); }"
*declare "int rs_IsASHPHydronic() const { return rs_type == C_RSYSTY_ASHPHYD; }"
*declare "bool rs_IsWSHP() const { return rs_type == C_RSYSTY_WSHP; }"
*declare "bool rs_IsHP() const { return rs_IsASHP() || rs_IsWSHP(); }"
*declare "bool rs_IsVCHtg() const { return rs_IsASHPVC(); }"
*declare "bool rs_IsVCClg() const { return rs_IsASHPVC(); }"
*declare "bool rs_IsVC() const { return rs_IsASHPVC(); }"
*declare "bool rs_IsFanCoil() const { return rs_type == C_RSYSTY_FANCOIL; }"
*declare "bool rs_IsASHPVC() const { return rs_type == C_RSYSTY_ASHPVC; }"
*declare "bool rs_IsElecHeat() const { return rs_IsHP() || rs_type==C_RSYSTY_ACRES || rs_type==C_RSYSTY_ACPKGRMRES || rs_type==C_RSYSTY_RES; }"
*declare "bool rs_IsFuelAuxH() const { return rs_typeAuxH == C_AUXHEATTY_FURN; }"
*declare "bool rs_IsPkgRoom() const { return rs_IsASHPPkgRoom() || rs_IsACPkgRoom(); }"
*declare "bool rs_IsASHPPkgRoom() const { return rs_type==C_RSYSTY_ASHPPKGRM; }"
*declare "bool rs_IsACPkgRoom() const { return rs_type==C_RSYSTY_ACPKGRM || rs_type==C_RSYSTY_ACPKGRMFURN || rs_type==C_RSYSTY_ACPKGRMRES; }"
*declare "bool rs_HasDefrost() const { return rs_IsASHP() && !rs_IsASHPPkgRoom() && rs_defrostModel != C_RSYSDEFROSTMODELCH_NONE; }"
*declare "bool rs_CanHeat() const { return rs_type != C_RSYSTY_AC && rs_type != C_RSYSTY_ACPKGRM; }"
*declare "bool rs_CanCool() const { return rs_type != C_RSYSTY_FURN && rs_type != C_RSYSTY_RES; }"
*declare "bool rs_CanOAV() const { return rs_OAVType != C_RSYSOAVTYCH_NONE; }"
*declare "bool rs_CanHaveAuxHeat() const { return rs_IsHP(); }"
*declare "ZNR* rs_GetOAVReliefZn() const;"
*declare "void rs_OAVSetup();"
*declare "void rs_OAVAirFlow();"
*declare "int rs_OAVAttempt();"
*declare "static double rs_CallCalcHSPF( void* pO, double &cop17);"
*declare "RC rs_HSPFMatchASHP();"
*declare "float rs_HSPFCheckASHP( int options=0);"
*declare "static float rs_DHR( float capHt);"
*declare "RC rs_SetupASHP();"
*declare "RC rs_SetRunConstantsASHP();"
*declare "float rs_CapRat1747() const;"
*declare "float rs_CapRat0547() const;"
*declare "float rs_Cap35Default( float cap47, float cap17) const;"
*declare "float rs_Inp35Default( float inp47, float inp17) const;"
*declare "float rs_CapHtCurSpeedF() const;"
*declare "float rs_CapDfHtCurSpeedF() const;"
*declare "float rs_InpHtCurSpeedF() const;"
#if 0
x *declare "float rs_Cap05Default( float cap47, float cap17) const;"
x *declare "float rs_Cap115Default( float cap95, float cap82) const;"
x *declare "float rs_Inp115Default( float inp95, float inp82) const;"
x *declare "RC rs_SetDefaultsClg();"
#endif
*declare "RC rs_SetupBtwxtClg();"
*declare "RC rs_SetupBtwxt( class Btwxt::RegularGridInterpolator* &pRgi, const std::vector<struct VSPERFP> ppV);"
*declare "RC rs_GetPerfBtwxt( class Btwxt::RegularGridInterpolator* pRgi, float tdbOut, float& cap, float& inp, float& capMin, float& inpMin);"
*declare "void rs_AuszFinalASHP();"
*declare "float rs_CapEffASHP( float tdbout=-999.f, int ashpModel=0, float fanHRtd=-1.f, float fanHOpr=-1.f, float COPAdjF=-1.f);"
*declare "float rs_CapEffASHP2();"
*declare "static double rs_CallCalcCapHt( void* pO, double &cop17);"
*declare "double rs_CapHtForCap47( float cap47);"
*declare "RC rs_SizeASHP( float dsnLoad, float tdbOut);"
*declare "void rs_DefaultCapNomsIf();"
*declare "enum { rsmOFF, rsmHEAT, rsmCOOL, rsmOAV, rsmCOUNT };"

*i RSYSTY rs_type			// system type (ACFURN, ACRES, ASHP, AC, FURN, RES)
*i CHP rs_desc				// optional description string (e.g. model #)
							//   included in perf map,
*i NOYESCH rs_perfMap		// if YES, make performance map (development aid)
							//   writes file <PM_name>.csv
*r DBL rs_areaServed		// total zone floor area served by this RSYS, ft2
*r INT rs_zonesServed		// # of zones served by this RSYS

*i TI rs_elecMtri			// meter for system electricity use
*i TI rs_fuelMtri			// meter for system fuel use
*i TI rs_loadMtri           // LOADMTR idx for accumulation of primary (coil) output
                            //    qHtg accums heating output, Btu (> 0)
                            //    qClg accums cooling output, Btu (< 0)
*i TI rs_srcSideLoadMtri    // LOADMTR idx for accumulation of source-side heat
                            //    aka heat of rejection or outdoor coil heat transfer
                            //    qHtg accums heat to RSYS from env during heating operation, Btu (> 0)
                            //    qClg accums heat from RSYS to env during cooling opersion, Btu (< 0)
                            //    Meaningful for compression rs_types.
*declare "MTR* rs_pMtrElec; MTR* rs_pMtrFuel; MTR* rs_pMtrHeat; MTR* rs_pMtrAux; LOADMTR* rs_pLoadMtr; LOADMTR* rs_pSrcSideLoadMtr;"
							// runtime pointers to meters, NULL if not accum'ing
							//   rs_pMtrAux either elec or fuel per rs_typeAuxH


							// parasitic consumption: accum'd to Par end use in
							//   appropriate meter; no thermal effect
*h FLOAT rs_parElec			//		electrical parasitic power, W
*h FLOAT rs_parFuel			//		fuel parasitic consumption, Btuh

							// nominal capacities, provide type-independent probe source for capacities.
							// daily variability because default value changes during autosizing
*d FLOAT rs_capNomH			//   nominal heating capacity, Btuh.  Default=rs_capH or rs_cap47
*d FLOAT rs_capNomC			//   nominal cooling capacity, Btuh.  Default=rs_cap95

*r *nest FAN rs_fan			// RSYS fan characteristics
*r NOYESCH rs_adjForFanHt   // YES: fanHtRtd derived from rs_fan.motTy
                            //        and removed from capacity and input values
                            //    NO: no rated fan heat adjustments

*s *e *nest AIRSTATE rs_asRet	// return duct entering air state (at grilles)
								//   (flow-weighted average of all zones)
*s *e *nest AIRSTATE rs_asIn	// entering air state (after return ducts)
								//   valid for all modes
*s *e DBL rs_twbIn;				// entering air wet bulb (after return ducts), F
*s *e *nest AIRSTATE rs_asOut	// leaving air state at plenum
								//    NOT including any aux heat
								//	  NOT including any DSE or supply duct losses
*s *e *nest AIRSTATE rs_asOutAux // aux heat leaving air state at plenum for ASHP heating (else 0)
								//    includes fan heat
								//    may include primary heat per rs_ctrlAuxH
								//	  NOT including any DSE or supply duct losses

								// supply air state (at registers)
*s *e *nest AIRSTATE rs_asSup	//   ... at full capacity under current conditions
*s *e *nest AIRSTATE rs_asSupAux //  ... at full cap + auxiliary (ASHP only, else unused)
*s float rs_tSupLs;				//   ... supply dry-bulb at last step, F
								//       used as e.g. 1st iteration guess in ASHP aux heat calc

#if 0
*s *e *nest AIRSTATE rs_asZn	// idea: avg air state of zones at end of step
#endif

					// Distribution system efficiency = simplified distribution loss model
					// Model discards 1-DSE of heat added by system
					//   if <0, use DUCTSEG else apply DSE
*h FRAC_GZ rs_DSEH;	//    heating
*h FRAC_GZ rs_DSEC;	//    cooling

					// autosizing
							// TODO: clarify re fan heat?
*r INT rs_isAuszH			// TRUE iff currently autosizing heating
							//   = Top.tp_autoSizing && IsAusz( RSYS_CAPH)
*r INT rs_isAuszC			// ditto cooling RSYS_CAP95
*r FLOAT_GZ rs_tdDesH		// design temperature difference (rise) across RSYS for heating
							//   autosizing, F.  default 30 F for ASHP else 50 F
*r FLOAT_LZ rs_tdDesC		// design temperature difference (fall) across RSYS for cooling
							//   autosizing, F.  default -25 F
*array 2 *s *e FLOAT rs_fxCap	// current step excess capacity factor = amfAvailable / max( amfRequest)
								//     >1 = excess capacity
								// [ 0]=primary   [1]=prim+aux or aux alone (per rs_ctrlAuxH)
*h *e FLOAT rs_fxCapCDay	// current day excess cooling capacity factor
							//   evaluated at last time step of hour
							//     >1 = excess capacity
*h *e FLOAT rs_fxCapHDay	// ditto heating
*r FLOAT_GZ rs_fxCapHTarg	// target excess capacity factor for heating autosize
							//   default = 1.4 (40% oversize)
*r FLOAT rs_fxCapHAsF		// working excess capacity factor for heating autosize
							//   ensures sufficient capacity to meet load
*r FLOAT_GZ rs_fxCapCTarg	// target excess capacity factor for cooling autosize
							//   default = 1.2 (20% oversize)
*r FLOAT rs_fxCapCAsF		// working excess capacity factor for cooling autosize
							//   ensures sufficient capacity to meet load
*f FLOAT_GZ rs_fxCapAuxHTarg // target excess capacity factor for auxH autosize
							//   default = 1.0
*nest AUSZ rs_auszH			// autoSizing working data members re heating
*nest AUSZ rs_auszC			// ditto cooling

						// ASHP heating (all values net = include rated fan heat / power)
*r FLOAT_GZ rs_HSPF			// rated HSPF, Btuh/W
*f *e FLOAT_GZ rs_cap47		// full speed net heating capacity at ODB=47 F
*f *e FLOAT_GZ rs_COP47		// COP at ODB=47 F
*f *e FLOAT_GZ rs_cap35		// full speed net heating capacity at ODB=35 F
*f *e FLOAT_GZ rs_COP35     // COP at ODB=35 F
*f *e FLOAT_GZ rs_cap17		// full speed net heating capacity at ODB=17 F
*f *e FLOAT_GZ rs_COP17     // COP at ODB=17 F
*f *e FLOAT_GZ rs_cap05		// full speed net heating capacity at ODB=5 F
*f *e FLOAT_GZ rs_COP05     // COP at ODB=5 F
*r FRAC_GZ rs_capRat1747	// cap17 / cap47 ratio (re autosizing)
							//   default based on HSPF or other correlations
*r FRAC_GZ rs_capRat0547	// cap05 / cap47 ratio (re autosizing)
							//   default ?
*r FLOAT_GZ rs_capRat9547   // total net cap95 (cooling) / net cap47 (heating)
                            //   re consistent htg/clg size iff both autosized
                            //   (else inconsistency ignored)
                            //   default=correlation per A. Conant
                            //   see ashpCap95FromCap47() and ashpCap47FromCap95()

						// re ASHPVC (variable capacity)
*f *e FRAC_GZ rs_loadFMin47;	// htg min load fract at 47 F (cycles below this)
*f *e FRAC_GZ rs_loadFMin17;	// htg min load fract at 17 F (cycles below this)
*f *e FRAC_GZ rs_loadFMin05;	// htg min load fract at 05 F (cycles below this)

*declare "float rs_CapMin47() const { return rs_cap47*rs_loadFMin47; }"
*declare "float rs_CapMin17() const { return rs_cap17*rs_loadFMin17; }"
*declare "float rs_CapMin05() const { return rs_cap05*rs_loadFMin05; }"
*f *e FLOAT_GZ rs_COPMin47	// COP at ODB=47 F, min speed
*f *e FLOAT_GZ rs_COPMin35	// COP at ODB=35 F, min speed
*f *e FLOAT_GZ rs_COPMin17	// COP at ODB=17 F, min speed
*f *e FLOAT_GZ rs_COPMin05	// COP at ODB=5 F, min speed

*f *e FRAC rs_CdH;			// heating cycling degradation factor

*f *e FLOAT_GZ rs_inp47		// input power at ODB=47 F, Btuh (w/ rated fan power)
*f *e FLOAT_GZ rs_inp35		// input power at ODB=35 F, Btuh (w/ rated fan power)
*f *e FLOAT_GZ rs_inp17		// input power at ODB=17 F, Btuh (w/ rated fan power)
*f *e FLOAT_GZ rs_inp05		// input power at ODB=5 F, Btuh (w/ rated fan power)

								// ASHP constants [ 0]=non-defrost, [1]=defrost (used when 17 < T < 45)
*array 2 *r FLOAT rs_ASHPCapF	// capacity slope: cap(T) = cap17 + CapF*(T - 17)
*array 2 *r FLOAT rs_ASHPInpF	// input slope: inp(T) = inp17 + InpF*(T - 17)

*declare "class Btwxt::RegularGridInterpolator* rs_pRgiHtg[ 2];" // ASHPVC heating performance map
                                                              // values in map are derived from rs_cap47 etc.
                                                              // thus include rated fan heat/power
                                                              //  [ 0]: integrated (degraded re defrost)
                                                              //  [ 1]: steady state (no defrost degrade)
                                                              //        (valid 17 - 47 F only)

*r AUXHEATTY rs_typeAuxH	// type of auxiliary heat (C_AUXHEATTY_NONE, _RES, _FURN)
*r AUXHEATCTRL rs_ctrlAuxH	// auxiliary heating control
							//   C_AUXHEATCTRL_LO    Compressor locked out if any aux
							//   C_AUXHEATCTRL_CYCLE Compressor runs continuously, aux cycles
							//   C_AUXHEATCTRL_ALT   Compressor/aux alternate
*f *e FLOAT_GEZ rs_capAuxH	// auxiliary heating capacity (NOT including fan heat), Btuh
							//   *always* 0 if !rs_IsASHP()
*f *e FLOAT rs_capAuxHInp	// rs_capAuxH as input (may be AUTOSIZE)
							// allows use of estimated rs_capAuxH during ASHP autosize
*f FLOAT_GZ rs_AFUEAuxH		// auxiliary furnace heating AFUE (assumed constant), default 0.9
*f FLOAT_GZ rs_effAuxH		// aux heat efficiency (= rs_AFUEAuxH or 1)
*r *e INT rs_underSizedAuxCount // # of subhours having aux heat capacity < compressor capacity
                                //   iff rs_ctrlAuxH != C_AUXHEATCTRL_CYCLE and rs_capAuxH > 0
*h FLOAT rs_ASHPLockOutT	// air source heat pump compressor lockout temp, F
							//   compressor capacity assumed 0 if outdoor tdb < tLockOut
							//   default is -999 (no lockout)
*r RSYSDEFROSTMODELCH rs_defrostModel	// defrost model
							//   NONE:        defrost ignored (no capacity reduction, no aux heat)
							//   REVCYCLE:    no additional aux heat (just capacity reduced per cap35)
							//   REVCYCLEAUX: aux heat used to compensate for capacity reduction due to
							//                reverse (cooling) operation

							// non-ASHP heating
*f FRAC_GZ rs_AFUE			//   heating system rated AFUE, 0 < AFUE <= 1

*f *e FLOAT_GEZ rs_capH;		// rated heating output (including fan), Btuh
*f *e FLOAT_GEZ rs_capH_As;		// autoSized capH (including fan), Btuh
*f *e FLOAT_GEZ rs_capH_AsNov;	// raw autoSized capH w/o oversizing (including fan), Btuh
// autoSize code ASSUMES x, x_As, x_AsNov together for access thru one ptr. cuprobe.cpp's name search also requires together.

// *r FLOAT rs_fanPwrRtdH      // fan power include in ASHP rated cap/COP/HSPF, W/cfm 
*f FLOAT rs_fanHRtdH		// fan heat included in ASHP rated cap/COP/HSPF, Btuh
							//   (generally estimated from rs_fanHRtdC)
*r FLOAT_GEZ rs_fanPwrH;	// operating heating fan power, W/cfm
*f *e FLOAT rs_fanHeatH		// operating heating fan electrical power at cfm, Btuh
							//   used re both electricity use and air heat gain
*f *e FLOAT rs_amfH;		// heating dry air mass flow rate, lbm/hr
*s *e FLOAT rs_effHt		// current step full load heating efficiency, dimless
                            //   includes rs_fEffH modification if any
							//   0 = ASHP compressor is unavailable (due to lockout, )
*s *e FLOAT rs_capHt		// current step full speed primary heating capacity, Btuh
							//   includes fan heat and strip/furn defrost makeup heat
							//   = fan heat only if compressor unavailable
*s *e FLOAT rs_inpHt		// current step full speed compressor input power
*s *e FLOAT rs_capDfHt		// current step defrost heating capacity, Btuh
							//   = typically resistance heat activated to prevent cold supply air
							//   0 if not ASHP or no defrost active
*s *e FLOAT rs_capHtMin		// current step min speed heating capacity (including fan and ASHP defrost heat), Btuh
							//   = fan heat only if compressor unavailable
*s *e FLOAT rs_inpHtMin		// current min speed compressor input power
*s *e FLOAT rs_capDfHtMin	// current step min speed defrost heating capacity, Btuh
*s *e FLOAT rs_COPHtAdj		// current step adjusted heating compressor COP (reflecting all adjustments)

					// compression cooling
*f *e FLOAT_GEZ rs_cap95;		// rated full speed net total cooling capacity at 95 F (>= 0), Btuh
*f *e FLOAT_GEZ rs_cap95_As;	// autosize cap95 net total cooling cap, Btuh
*f *e FLOAT_GEZ rs_cap95_AsNov;	// raw autoSized cap95 net total cooling cap w/o oversizing, Btuh
// autoSize code ASSUMES x, x_As, x_AsNov together for access thru one ptr. cuprobe.cpp's name search also requires together.

*f *e FLOAT_GZ rs_COP95;    // COP at 95 F (= rs_EER95 / 3.412)
                            //   rs_COP95 and rs_EER95 are consistent at runtime
*f *e FLOAT_GZ rs_EER95;	// EER at 95 F, Btuh/W (=rs_COP95 * 3.412)
                            //   rs_COP95 and rs_EER95 are consistent at runtime
*f *e FLOAT_GZ rs_SEER;		// cooling AHRI rated SEER, Btuh/W

*f *e FLOAT_GEZ rs_cap115;	// total full speed net cooling capacity at 115 F (>= 0), Btuh
*f *e FLOAT_GZ rs_COP115;   // full speed cooling COP at 115F
*r FRAC_GZ rs_capRat11595   // cap115 / cap95 (re autosizing)
                            //   default = .9155, 0 < x <= 1

*f *e FLOAT_GEZ rs_cap82;	// total full speed net cooling capacity at 82 F (>= 0), Btuh
*f *e FLOAT_GZ rs_COP82;    // full speed cooling COP at 82F
*r FLOAT_GZ rs_capRat8295	// cap82 / cap95 ratio (re autosizing)
                            //  default = 1.06, 1 <= x < 2 enforced at runtime

*f *e FRAC_GZ rs_loadFMin115;   // clg min load fract at 115 F (cycles below this)
*f *e FRAC_GZ rs_loadFMin95;    // clg min load fract at 95 F (cycles below this)
*f *e FRAC_GZ rs_loadFMin82;	// clg min load fract at 82 F (cycles below this)
*declare "float rs_CapMin115() const { return rs_cap115*rs_loadFMin115; }"
*declare "float rs_CapMin95() const { return rs_cap95*rs_loadFMin95; }"
*declare "float rs_CapMin82() const { return rs_cap82*rs_loadFMin82; }"

*f *e FLOAT_GZ rs_COPMin115 // COP at ODB=115 F, min speed
*f *e FLOAT_GZ rs_COPMin95	// COP at ODB=95 F, min speed
*f *e FLOAT_GZ rs_COPMin82	// COP at ODB=82 F, min speed

*declare "class Btwxt::RegularGridInterpolator* rs_pRgiClg;"  // ASHPVC cooling performance map
                                                              // values in map are derived from rs_cap95 etc.
                                                              // thus are net (include rated fan heat/power)

*f FLOAT_GZ rs_vfPerTon;	// air flow ratio, cfm/ton (= cfm/(rs_cap95/12000))
*f FLOAT_GEZ rs_fanPwrC;	// cooling fan operating power ratio, W/cfm (default 0.365)
*f *e FLOAT rs_fanHeatC		// cooling fan full speed operating electrical power, Btuh
							//   used re both electricity use and air heat gain
*f *e FLOAT rs_fanDeltaTC	// cooling fan heat temperature rise, F
							//   constant even if capacity is altered during autosize
							//   Why: air flow is function of rated capacity
*f *e FLOAT rs_amfC;		// cooling dry air mass flow rate, lbm/hr
*f *e FRAC rs_CdC;			// cooling cycling degradation factor
*h *e FRAC rs_rhInTest		// specified entering air relnum (for testing), 0-1
*s *e FRAC rs_rhIn			// plenum entering air relnum, 0-1
							//   ( = rs_rhInTest if given, else from zone + return duct)
*s *e FLOAT rs_twbCoilIn	// coil entering wet bulb, F (after blow-thru fan if any)
*s *e FLOAT rs_tdbCoilIn	// coil entering dry bulb, F (ditto)

*s *e FLOAT_GZ rs_SHR;		// cooling sensible heat ratio (sensible capacity / total capacity)
                            //   from coil model for compression types
                            //   from rs_SHRtarget for fancoil
                            //   may be modified re humidity constraints
*s FLOAT_GZ rs_SHRtarget    // inputable nominal sensible heat ratio (for fancoil)
                            //   default 0.7

*f FRAC rs_fChg				// refrigerant charge factor (default 1, 0.9 or 0.96 for CA compliance)
							//   multiplies cooling capacity (no effect on heating)
*f FLOAT rs_fanHRtdC		// fan heat included in rated rs_cap95, Btuh
*f FLOAT rs_capnfX;			// constant for rs_capXxxCt calc
*f *e FLOAT rs_SEERnfX;		// constant for rs_SEERnf calc
*f *e FLOAT rs_EERnfX;		// constant for rs_EERnfCalc

*s *e FLOAT rs_fCondCap		// conditions factor, capacity
*s *e FLOAT rs_fCondSEER	// conditions factor, SEER
*s *e FLOAT rs_fCondEER		// conditions factor, EER

							// values for current step (adjusted for outdoor and indoor temps)
*s *e FLOAT rs_SEERnf		//	SEER w/o fan power
*s *e FLOAT rs_EERnf		//	EER w/o fan power
*s *e FLOAT rs_EERt;		//  compressor EER, Btuh/W (temperature weighted mix of
							//     rs_SEERnf and rs_EERnf)
*s *e FLOAT rs_effCt;		// temp adjusted compressor efficiency (= CEt in ACM)
							//   (Btuh sensible)/(Btuh compressor electrical input)
*s *e FLOAT rs_capTotCt		// coil total cooling capacity at current conditions and speed, Btuh (<0)
*s *e FLOAT rs_capLatCt		// coil latent cooling capacity at current conditions and speed, Btuh (<0)
*s *e FLOAT rs_capSenCt;	// coil sensible cooling capacity at current conditions and speed, Btuh (<0)

#if 0
*s *e FLOAT rs_capTotCl		// coil full speed total cooling capacity, Btuh
							//   includes rated fan heat
*s *e FLOAT rs_inpCl		// current step full speed compressor input power
*s *e FLOAT rs_capClMin		// current step min speed cooling capacity (including fan heat\), Btuh
*s *e FLOAT rs_inpClMin		// current min speed compressor input power
*s *e FLOAT rs_COPHtAdj		// current step adjusted heating compressor COP (reflecting all adjustments)
#endif

// shared results (set for both heating and cooling)

						// Central outside air vent (aka OAV)
*i RSYSOAVTYCH rs_OAVType	// type: NONE, FIXEDFLOW (aka SmartVent), VARFLOW (aka SmartBreeze)
*i TI rs_OAVReliefZi		// OAV relief zone index
*s FLOAT rs_OAVTdbInlet		// OAV inlet dry-bulb temp, F
							//   default = from project weather data source (generally weather file)
							//   note: default varies subhourly but input expression is hourly
*h FLOAT_GZ rs_OAVTdiff		// OAV temperature differential, F
*i FLOAT_GEZ rs_OAVAvfDs	// OAV design air flow rate, cfm actual air
*i FLOAT_GEZ rs_OAVFanPwr	// OAV design fan power (based on rs_OAVVfDs), W/cfm
*i FRAC rs_OAVAvfMinF		// OAV minimum volume flow (rs_avfOAV always >= rs_OAVAvfMinF *rs_OAVAvfDs)

*d FLOAT rs_avfOAV			// OAV current air volume flow, cfm (set at beg of each day)
*d FLOAT rs_fanHeatOAV		// ditto fan power, Btuh
*d FLOAT rs_amfOAV			// ditto air mass flow, lbm/hr

							// DUCTSEG linkage
*declare "struct"
*declare "{ TI dsi[ 2];"			// idx of associated DUCTSEGs, 0 if none
									//  [ 0] = supply, [ 1] = return
*declare "  FLOAT ductLkXF[ 2];"	// nonleak fraction = (1 - ds_leakF) [ 0] = sup, [ 1] = ret
									// = 1 if no associated DUCTSEG  *never* 0
*declare "} rs_ducts[ 2];"			// [ 0]=htg [1] = clg
*declare "int rs_CanHaveDucts( int iHC) const;"
*declare "int rs_DsHC() const { return rs_mode > rsmHEAT; }"	// 0: use htg ducts, 1: use clg
*declare "int rs_Dsi( int iSR, int iHC=-1) const { if (iHC<0) iHC=rs_DsHC(); return rs_ducts[ iHC].dsi[ iSR]; }"

*s FLOAT_GZ rs_fEffH;	// heating efficiency adjustment factor (applied to substep efficency), default=1
*s FLOAT_GZ rs_fEffC;	// cooling efficiency adjustment factor (applied to substep efficency), default=1  

*s FLOAT rs_tdbOut		// outdoor dry-bulb temp at condensor or other outdoor components, F
						//   default = from project weather data source (generally weather file)
						// note: default varies subhourly but input expression is hourly
*h RSYSMODECTRLCH rs_modeCtrl	// mode control (off, heat, cool, auto }
*s *e USI rs_mode		// mode (rsmOFF, rsmHEAT, rsmCOOL, rsmOAV )
*s USI rs_modeLs		// last step mode (rsmOFF, rsmHEAT, rsmCOOL, rsmOAV )
*s USI rs_modeLastActive	// last active mode (rsmOFF, rsmHEAT, rsmCOOL, rsmOAV )
                            //   (allows guess re e.g. heating vs cooling season)
*array 2 *s *e DBL rs_amfReq	// total AMF (at system) requested by zones, lbm/hr
								//  [ 0] = primary source (compressor or burner)
								//	[ 1] = prim+aux or aux-only (per rs_auxControl)
								//         ASHP heating only else 0
*array 2 *s *e FLOAT rs_znLoad; // total load to hold zone(s) at setpoint, Btuh
                                //  [ 0] = primary (compreesor or burner)
                                //	[ 1] = prim+aux or aux-only (per rs_auxControl)
// calculated results
*s *e FLOAT rs_capSenNetFS      // net sensible capacity at full speed, Btuh

*s *e DBL rs_amf		// current dry air mass flow rate, lbm/hr
						//   = flow at blower / coil / furnace HX etc.
						//   set per rsMode from rs_amfH, rs_amfC, or OAV algorithm
                        //   modified by rs_speedF
*s *e FLOAT rs_PLF		// efficiency degradation due to cycling
						//   PLF = PartLoadEfficiency / FullLoadEfficency
*s *e FLOAT rs_PLR      // current step part load ratio = sensible load / full-speed sensible capacity
*s *e FLOAT rs_loadF	// current step load fraction = sensible load / current-speed sensible capacity
*s FLOAT rs_loadFLs		// last step loadF (for probe access at step beg)
*s *e FLOAT rs_runF		// primary (e.g. compressor) run fraction
*s *e FLOAT rs_speedF	// primary (compressor) current speed fraction
						//    fixed speed: 1; var spd: <= 1 per load
*s *e FLOAT rs_speedFMin // primary (compressor) current minimum speed fraction
                        //    fixed speed: 1; var spd: < 1 per min current min cap
*s *e FLOAT rs_runFAux	// auxiliary run fraction
*s *e DBL rs_outSen		// average primary (compressor, burner, ) sensible heat delivery rate for last subhr, Btuh
						//   (includes runF/speedF, does not include fan, defrost, or aux heat)
						//   used for both heating and cooling
*s *e DBL rs_outLat		// average latent heat delivery rate, Btuh
*s *e DBL rs_outFan		// average fan heat added to air stream, Btuh
*s *e DBL rs_outDefrost // averate defrost heat, Btuh
						//	  = typically resistance heat added to prevent cold supply air
						//    0 if not ASHP or if defrost not active
*s *e DBL rs_outAux		// average auxiliary heat added to air stream, Btuh (for ASHP)
*s *e DBL rs_outSenTot	// average total sensible heat delivery rate for last subhr, Btuh
						//   = rs_outSen + rs_outFan + rs_outDefrost + rs_outAux

*y *e *array 2 LI rs_calcCount; // # calls to rs_SupplyAirState, re optimizing rs_FindRequiredSpeedF()
                                //  [ 0] = heating, [1] = cooling

*s *e DBL rs_inPrimary	// primary input, Btuh (compressor, burner, )
*s *e DBL rs_inFan		// fan electricity input, Btuh (not kWh)
*s *e DBL rs_inDefrost	// defrost heating input, Btuh (ASHP only)
*s *e DBL rs_inAux		// auxiliary heating input, Btuh

*END	// RSYS
//=============================================================================
RECORD RSYSRES_IVL_SUB "RSYS interval results sub" *SUBSTRUCT	// RSYSresult substruct for RSYSRES
	*declare "void rsr_Accum( const RSYSRES_IVL_SUB* src, int firstFlg, int lastFlg);"
	*declare "void rsr_SetPrior() const;"
    *declare "void rsr_Zero() { memset( this, 0, sizeof( RSYSRES_IVL_SUB)); }"	// 0 all (bitwise)

	INT n			    // number of intervals added together in this one (divisor for averages)
					    //  (maintained but unused)

	// float members to add, hrsOn MUST be first (else change rsr_Accum() etc)
	HOURS hrsOn		    // operating hours
	HOURS hrsOnAux	    // auxiliary heating operating hours (ASHP only)
					    //   does not include defrost

	ENERGY qhPrimary	// heating output w/o fan, w/o defrost, Btu
	ENERGY qhDefrost	// defrost (strip) heat output, Btu
	ENERGY qhAux		// auxiliary heat output, Btu
    ENERGY qhFan        // heating mode fan heat, Btu
	ENERGY qhNet	    // heating mode net output (qhPrimary+qhDefrost+qhAux+qhFan), Btu

	ENERGY qcSen	    // sensible cooling output w/o fan (< 0), Btu
	ENERGY qcLat	    // latent cooling output (<0), Btu
    ENERGY qcFan        // cooling mode fan heat, Btu
    ENERGY qcSenNet     // sensible cooling net output (qcSen+qcFan), Btu

    ENERGY qvFan        // OAV mode fan heat, Btu
   
    ENERGY fhPrimary    // heating mode primary fuel, Btu
    ENERGY fhDefrost    // heating mode defrost fuel, Btu
    ENERGY fhAux        // heating mode auxiliary fuel, Btu
    ENERGY fhParasitic  // heating mode parasitic fuel, Btu
    ENERGY fhTot        // heating mode total fuel, Btu
                        //   primary+defrost+aux+parasitics

    ENERGY ehPrimary    // heating mode primary electicity use, Btu
                        //   (compressor, resistance, )
    ENERGY ehDefrost    // heating mode defrost (strip) electricity use, Btu
    ENERGY ehAux        // heating mode auxiliary (strip) electricity use, Btu
    ENERGY ehFan        // heating mode fan electricity use, Btu
    ENERGY ehParasitic  // heating mode parasitic electricity, Btu
    ENERGY ehTot        // heating mode total electricity use, Btu
                        //   primary+defrost+aux+fan+parasitic

    ENERGY ecPrimary    // cooling mode compressor electricity use, Btu
    ENERGY ecFan        // cooling mode fan electricity use, Btu
    ENERGY ecParasitic  // cooling mode parasitic electricity, Btu
    ENERGY ecTot        // cooling mode total electricity use, Btu
                        //   primary+fan+parasitic

    ENERGY evFan        // OAV mode fan electricity use, Btu
    ENERGY evParasitic  // OAV mode parasitic electricity use, Btu
    ENERGY evTot        // OAV mode total electricity use, Btu
                        //   fan+parasistic

                    // zone energy transfers (must be contiguous and in order, see code)
    ENERGY qhZoneSen    // heating mode sensible transfer to zone(s) (after dist losses), Btu
    ENERGY qhZoneLat    // heating mode latent transfer to zone(s) (after dist losses), Btu
    ENERGY qcZoneSen    // cooling mode sensible transfer to zone(s) (after dist losses), Btu
    ENERGY qcZoneLat    // cooling mode latent transfer to zone(s) (after dist losses), Btu
    ENERGY qvZoneSen    // OAV mode sensible transfer to zone(s) (after dist losses), Btu
    ENERGY qvZoneLat    // OAV mode latent transfer to zone(s) (after dist losses), Btu

*END		// RSYSRES_IVL_SUB
//=============================================================================
RECORD RSYSRES_SUB "RSYS results sub" *SUBSTRUCT
    // name: same as corresponding RSYS, or sum_of_RSYS.
    // CAUTION: code assumes these are in order matching IVLCH
    //    so can add IVLCH-1 to ptr to .Y to access M,D,S. eg in cgresult.cpp.
    *y *nest RSYSRES_IVL_SUB Y  	// run results, aka year or annual
    *m *nest RSYSRES_IVL_SUB M  	// month
    *d *nest RSYSRES_IVL_SUB D  	// day
    *h *nest RSYSRES_IVL_SUB H  	// hour.
    *s *nest RSYSRES_IVL_SUB S  	// subhour, aka subStep or sub-time-step
*END		// RSYSRES_SUB
//=============================================================================
RECORD RSYSRES "RSYSRes" *RAT	// holds RSYS and all-RSYS simulation results (later at subscript #RSYS + 1)
    // name: same as corresponding RSYS, or sum_of_RSYS.
	*e *noname *nest RSYSRES_SUB curr 	// current year,month,day,hour,subhr results, stored at end each interval
    *nest RSYSRES_SUB prior 			// prior year,month,day,hour,subhr results, available throughout interval
    // CAUTION: code assumes prior and curr arranged so can offset from curr to prior. eg in cnguts.cpp.
*END		// RSYSRES
//=============================================================================
RECORD AFMTR_IVL "Airflow meter interval sub" *SUBSTRUCT  // interval substruct for AIRFLOWMETER

    *prefix amt_
	*declare "void amti_Clear() { memset( this, 0, sizeof( AFMTR_IVL));}"
	*declare "void amti_Copy( const AFMTR_IVL* sIvl, float mult=1.f);"
 	*declare "void amti_AccumCat( AFCAT cat, FLOAT v) { (&amt_unknown)[ cat] += v; amt_total += v; }"
	*declare "void amti_Accum( const AFMTR_IVL* sIvl, int firstFlg, int lastFlg, int options=0);"

	*declare "static const int NAFCATS;"

	INT amt_count		// # of accums

    FLOAT amt_total		// total of following specific categories
						//   code assumes amt_total is 1st float
    //   Use by airflow category (C_AFCAT_xxx)
    //   CAUTION: order of members MATCHES DTAFCAT
    //      for subscripting (in cgcomp,cgresult.cpp) by category
	FLOAT amt_unknown		// unknown (= AFCAT 0, no associated choice)
	FLOAT amt_infEx		    // air flow by category
	FLOAT amt_vntEx
	FLOAT amt_fanEx
	FLOAT amt_infUz
	FLOAT amt_vntUz
	FLOAT amt_fanUz
	FLOAT amt_infCz
	FLOAT amt_vntCz
	FLOAT amt_fanCz
	FLOAT amt_ductLk
	FLOAT amt_hvac
*END		// AFMTR_IVL
//=============================================================================
RECORD AFMTR "AFMETER" *RAT 	// Airflow meter
    *prefix amt_
    *declare "RC amt_CkF();"
	// *declare "void amt_Clear();"
	*declare "bool amt_IsSumOf() const { return ss == b->n; }"
	*declare "RC amt_BegSubhr();"
	*declare "void amt_AccumCat( AFCAT afCat, float amf);"
	*declare "void amt_Accum( IVLCH ivl, int firstflg, int lastFlg);"
	*declare "AFMTR_IVL* amt_GetAFMTR_IVL( IVLCH ivl, int iPN=0);"


 // results: average cfm std air
 //     for each interval (member here), usage by end use (substruct member):
 // CAUTION: ordered for subscripting by IVLCH-1.
    *y *e *array 2 *nest AFMTR_IVL Y   	// run (aka year or annual)
    *m *e *array 2 *nest AFMTR_IVL M   	// month
    *d *e *array 2 *nest AFMTR_IVL D   	// day
    *h *e *array 2 *nest AFMTR_IVL H   	// hour
	*s *e *array 2 *nest AFMTR_IVL S	// subhour
*END		// AFMETER
//=============================================================================
RECORD DHWMTR_IVL "DHW meter interval sub" *SUBSTRUCT  // interval substruct for DHW meter
 // use results

	// accum function; see CAUTION below
	*declare "void wmt_Clear() { memset( this, 0, sizeof( DHWMTR_IVL));}"
	*declare "void wmt_Copy( const DHWMTR_IVL* s, float mult=1.f);"
	*declare "float wmt_GetByEUX( DHWEUXCH eux) { return (&total)[ eux-1]; };"
 	*declare "void wmt_AccumEU( DHWEUCH eu, FLOAT v) { (&unknown)[ eu] += v; total += v; }"
	*declare "void wmt_Accum( const DHWMTR_IVL* sIvl, int options=0, float mult=1.f);"
	*declare "void wmt_AccumTo( double* useTots) const { VAccum( useTots, NDHWENDUSES+1, &total); }"
    *declare "void wmt_SetPrior() const;"

    FLOAT total		// total of following specific end uses.  Code assumes precedes them.
    // Use by purpose (end use), water use, gal:
    // CAUTION: order of members MATCHES DTDHWEUCH choices (cndtypes.def)
    //    for subscripting (in cnguts,cgresult.cpp) by end use -1:
	FLOAT unknown		// unknown (= DHWENDUSE 0, no associated choice)
    FLOAT faucet		// faucet use
    FLOAT shower		// shower
    FLOAT bath			// bath
    FLOAT cwashr		// clothes washer
    FLOAT dwashr		// dish washer

*END		// DHWMTR_IVL
//=============================================================================
RECORD DHWMTR_SUB "DHW meter sub" *SUBSTRUCT

    *declare "RC wmt_CkF();"
	*declare "RC wmt_Init( IVLCH ivl);"
	*declare "void wmt_Accum( IVLCH ivl, int firstflg);"

 // results: accumulated water use for this meter (record subscript),
 //     for each interval (member here), usage by end use (substruct member):
 //CAUTION: ordered for subscripting by IVLCH-1.
    *y *nest DHWMTR_IVL Y   	// run (aka year or annual)
    *m *nest DHWMTR_IVL M   	// month's use
    *d *nest DHWMTR_IVL D   	// day's use
    *h *nest DHWMTR_IVL H   	// hour's use
*END		// DHWMTR
//==============================================================================
RECORD DHWMTR "DHWMETER" *RAT 	// DHWMTR: hot water consumption

    *declare "RC wmt_CkF();"
	*declare "RC wmt_Init( IVLCH ivl);"
	*declare "void wmt_Accum( IVLCH ivl, int firstflg);"

    *e *noname *nest DHWMTR_SUB curr    // current year,month,day,hour,subhr results, stored at end each interval
    *nest DHWMTR_SUB prior              // prior year,month,day,hour,subhr results, available throughout interval
    // CAUTION: code assumes prior and curr arranged so can offset from curr to prior. eg in cnguts.cpp.
*END		// DHWMTR
//=============================================================================
RECORD LOADMTR_IVL "LOADMETER interval sub" *SUBSTRUCT  // interval substruct for LOADMTR

    *prefix lmt_
	*declare "void lmt_Clear() { memset( this, 0, sizeof( LOADMTR_IVL));}"
	*declare "void lmt_Copy( const LOADMTR_IVL* s, float mult=1.f);"
	*declare "void lmt_Accum( const LOADMTR_IVL* sIvl, int firstFlg, int lastFlg, int options=0);"
	*declare "static const size_t lmt_NFLOAT;"

    *e INT lmt_count;   // # of accums

	// energy use
    *e FLOAT qHtg		// heating energy, Btu (assumed to be first float)
	*e FLOAT qClg		// cooling energy, Btu
*END		// LOADMTR_IVL
//=============================================================================
RECORD LOADMTR "LOADMETER" *RAT 	// LOADMETER: general way to track loads
    *declare "RC lmt_CkF();"
	*declare "RC lmt_BegSubhr();"
    *declare "LOADMTR_IVL* lmt_GetLOADMTR_IVL( IVLCH ivl);"
	*declare "void lmt_Accum( IVLCH ivl, int firstflg, int lastflg);"

 // accumulated values for each interval
 // CAUTION: ordered for subscripting by IVLCH-1
    *y *e *nest LOADMTR_IVL Y   	// run (aka year or annual)
    *m *e *nest LOADMTR_IVL M   	// month
    *d *e *nest LOADMTR_IVL D   	// day
    *h *e *nest LOADMTR_IVL H   	// hour
    *s *e *nest LOADMTR_IVL S   	// subhour

*END		// LOADMTR
//=============================================================================
RECORD DHWSYSRES_IVL "DHWSYSRES interval sub" *SUBSTRUCT  // interval substruct for DHWSYSRES
 // use results

	*declare "void wsr_Clear() { memset( this, 0, sizeof( DHWSYSRES_IVL));}"
	*declare "void wsr_Copy( const DHWSYSRES_IVL* s, float mult=1.f);"
	*declare "void wsr_Accum( const DHWSYSRES_IVL* sIvl, int firstFlg, int lastFlg);"
	*declare "void wsr_AccumTick( const struct DHWTICK& tk, float tLpIn);"
	*declare "static const size_t wsr_NFLOAT;"

	// water heating energy (not fuel), Btu
	//    values are for associated DHWSYS (wh_mult include, ws_mult not included)
    *e FLOAT qLoad		// hot water load (heat delivered to fixtures)
	*e FLOAT qLoss		// non-loop losses (jacket losses, T24DHW branch losses, )
	*e FLOAT qLoop		// DHWLOOP/DHWLOOPBRANCH losses
	*e FLOAT qDWHR		// drain water heat recovery
	*e FLOAT qSSF		// implied energy contribution from ws_SSF
    *e FLOAT qSolar		// DHWSOLARSYS
    *e FLOAT qWH		// DHWHEATER primary (compressor, burner, )
    *e FLOAT qLH		// Loop heater primary
    *e FLOAT qXBU		// add'l backup heat

*END		// DHWSYSRES_IVL
//=============================================================================
RECORD DHWSYSRES "DHWSYSRES" *RAT 	// DHWSYSRES: interval results for DHWSYS

	*declare "RC wsr_Init( IVLCH ivl=-1);"
#if 0
	*declare "void wsr_Accum( IVLCH ivl, int firstflg);"
#endif

 // results: accumulated values for paired DHWSYS for each interval
 // CAUTION: ordered for subscripting by IVLCH-1
    *y *e *nest DHWSYSRES_IVL Y   	// run (aka year or annual)
    *m *e *nest DHWSYSRES_IVL M   	// month's use
    *d *e *nest DHWSYSRES_IVL D   	// day's use
    *h *e *nest DHWSYSRES_IVL H   	// hour's use
    *s *e *nest DHWSYSRES_IVL S   	// subhour's use

*END		// DHWSYSRES
//=============================================================================
RECORD SEGTOTS "segment totals" *SUBSTRUCT  // aggregated segment info substruct 
// retains / accumulates PIPESEG info
// used in DHWSYS, DHWLOOP, DHWLOOPSEG, DHWLOOPBRANCH
	*prefix st_

	*excon
	*declare "void st_Init();"
	*declare "void st_Accum( const SEGTOTS& src, double count=1.);"
	
	*r DBL st_count		// # of segments included in totals
	*r DBL st_len		// length, ft
	*r DBL st_vol		// volume, gal
	*r DBL st_exArea	// outside surface area (at insulation surface), ft2
	*r DBL st_UA		// fluid-to-surround loss, Btuh/F-hr

*END	// SEGTOTS
//=============================================================================
RECORD DHWSYS "DHWSys" *RAT		// input / runtime DHW system
  *prefix ws_
  *exdes
  *ovrcopy
  *declare "virtual DHWSYS& CopyFrom( const record* src, int copyName=1, int dupPtrs=0);"
  *declare "RC ws_CkF();"
  *declare "RC ws_CheckVals( int erOp);"
  *declare "RC ws_CheckSubObject( record* r);"
  *declare "RC ws_Init( int pass);"
  *declare "RC ws_RddInit();"
  *declare "DHWSYSRES* ws_GetDHWSYSRES() const;"
  *declare "float ws_GetTSetpoint( int whfcn) const;"
  *declare "int ws_GetTSetpointFN( int whfcn) const;"
  *declare "virtual RC RunDup( const record* pSrc, int options=0);"
  *declare "RC ws_DoHour( IVLCH ivl, float centralMult=1.f);"
  *declare "RC ws_AccumCentralUse( const DHWSYS* pWSChild);"
  *declare "RC ws_DoHourDrawAccounting( float mult);"
  *declare "RC ws_DoEndPreRun();"
  *declare "RC ws_ApplySizingResults( float heatingCap, float* heatingCapTopN, float volRunning);"
  *declare "int ws_AssignDHWUSEtoFX( const DHWUSE* pWU);"
  *declare "void ws_AccumUseTick( DHWEUCH hwEndUse, int iTk, double fxUseMix, double whUse);"
  *declare "RC ws_DoSubhr();"
  *declare "RC ws_DoSubhrStart( int iTk0);"
  *declare "RC ws_DoSubhrTick( int iTk);"
  *declare "RC ws_DoSubhrEnd();"
  *declare "RC ws_EndIvl( int ivl);"
  *declare "void ws_SetMTRPtrs();"
  *declare "float ws_BranchFlow() const;"

  *i WSCALCMODECH ws_calcMode;	// calculation mode
  *i TI ws_centralDHWSYSi	// index of central (parent) DHWSYS, 0 if none
							//    child DHWSYSs specify unit-specfic draws only
							//    but have no heaters etc
  *declare "int ws_HasCentralDHWSYS() const { return ws_centralDHWSYSi > 0; }"
  *declare "DHWSYS* ws_GetCentralDHWSYS() const;"
  *declare "int ws_IsCentralDHWSYS() const;"

  *i FLOAT_GEZ ws_mult;		// multiplier: model as ws_mult identical systems
							//   fractional values supported
  *i TI ws_elecMtri;		// meter for system electricity use
  *i TI ws_fuelMtri;		// meter for system fuel use

							// energy inputs for current hour, Btuh
							//   NOTE: values DO NOT include DHWHEATER use
  *h *e FLOAT ws_inElec;	//    electricity (note not kWh)
  *h *e FLOAT ws_inFuel;	//	  fuel (for generality, always 0?)
  *declare "MTR* ws_pMtrElec; MTR* ws_pMtrFuel;"
							// runtime pointers to meters, NULL if not accum'ing

  *i TI ws_swTi;			// DHWSOLARSYS providing preheated water to this system
							//    0 iff no solar connected
  *declare "DHWSOLARSYS* ws_pDHWSOLARSYS;"	// pointer to connected solar system
  *h *e FLOAT ws_qSlr		// hour total water heating energy provided by
							//   DHWSOLARSYS (not via ws_SSF), Btu
  *y *e DBL ws_SSFAnnualSolar;	// Annual solar heat added (numerator to calculate SSF), Btu
								//   = SUM( ws_qSlr)
  *y *e DBL ws_SSFAnnualReq;	// Annual heat required (denominator to calculate SSF), Btu
  *y *e FLOAT ws_SSFAnnual;		// Annual solar savings fraction

  *h *e FLOAT ws_tInlet;	// current hour cold water inlet temp, F for this DHWSYS
							//   user expression or default Wthr.d.wd_tMains
							//   Not modified by solar and/or DHWHEATREC
  *h *e FLOAT ws_tInletX;	// hour average adjusted cold water temp, F
							//   reflects solar and/or DHWHEATREC
  *h FLOAT ws_hwUse;		// current hour hot water use (at fixtures), gal
							//   (scheduled input, does NOT include DHWDAYUSE draws)
  *declare "struct DHWTICK* ws_ticks;"	// array of runtime tick-level info
										//   draws, adjusted cold water temp, ...
  *h *e INT ws_iTk0DWHR;	// 1st tick with possible DWHR
  *h *e INT ws_iTkNDWHR;	// last+1 tick with possible DWHR
  *declare "void ws_TickInit( double whUseHr);"
  *declare "float ws_TickAvgTInletX( float& whUseTot) const;"
  *declare "RC ws_AddLossesToDraws( struct DHWTICK* ticksh);"
  *declare "RC ws_DoHourDWHR();"
  *h *e FLOAT ws_qDWHR;		// hour all DHWHEATREC total heat to fixtures and water heaters, Btu
  *h *e FLOAT ws_qDWHRWH;	// hour all DHWHEATREC total heat to water heater(s), Btu

						// DHWMTRs -- accumulates H/D/M/Y water use *with* ws_mult
  *i TI ws_WHhwMtri;		// DHWMTR for hot water use at water heater(s) (= ws_whUse), gal
  *i TI ws_FXhwMtri;		// DHWMTR for hot water use at fixtures (= ws_fxUseMix), gal
  *declare "DHWMTR* ws_pWHhwMtr; DHWMTR* ws_pFXhwMtr;"	// resolved DHWMTR pointers

						// mixed and hot water use for this DHWSYS (w/o ws_mult)
  *h *e FLOAT ws_whUseNoHR;				// current hour virtual hot water use w/o heat recovery, gal
										//    re verification / accounting of DWHR results
  *h *e *nest DHWMTR_IVL ws_fxUseMix	// current hour total (mixed) water use at fixtures, gal
  *y *e *array NDHWENDUSESXPP DBL ws_fxUseMixTot;	// annual total (mixed) water use at fixtures by end use, gal
  *h    *nest DHWMTR_IVL ws_fxUseMixLH	// prior hour total (mixed) water use at fixtures, gal
  *h *e *nest DHWMTR_IVL ws_whUse		// current hour hot water use by end use (at ws_tUse), gal
										//    water heater out = fixture hot in
										//    Also frequently assumed water heater in = water heater out
										//    BUT this is only approx due to e.g. mixdown and XBU.
  *y *e *array NDHWENDUSESXPP DBL ws_whUseTot;		// annual total hot water use by end use (at ws_tUse), gal
							
							// draw and load sizing info derived during C_WSCALCMODECH_PRERUN (only)
							//   copied to assocated input records in ws_DoEndPreRun()
							//   thus avail for use in sizing expressions during C_WSCALCMODECH_SIM input
							//   >> no direct uses in calcs <<
  *i SI ws_drawMaxDur					// draw duration window, hr (user input, default 4)
  *declare "VMovingSum< float> ws_drawMaxMS;"	// retains recent draw history
  *i FLOAT ws_drawMax					// largest draw total in any conseq ws_drawMaxDur hrs, gal

  *i SI ws_loadMaxDur					// load duration window, hr (user input, default 12)
  *declare "VMovingSum< float> ws_loadMaxMS;"	// retains recent load history
  *i FLOAT ws_loadMax					// largest load total in any conseq ws_loadMaxDur hrs, Btu

                            // EcoSizer sizing algorithm
  *declare "struct DHWSIZER* ws_pSizer;"     // tracks highest load days re sizing
  *i FLOAT ws_tSetpointDes;     // design (sizing) set point temp, F (constant)
                                //    default = ws_tUse
  *i FLOAT ws_tInletDes;        // design (sizing) cold water inlet temp, F
                                //    default = annual min mains temp
  *r *e FLOAT ws_ashpTSrcDes;      // design (sizing) HPWH source air temperature, F
                                //    default = heating design temp
  *r *e *array NDHWSIZEDAYS FLOAT ws_heatingCapDesTopN   // top N design heating capacities
                                //  [ 0] = largest
  *i FLOAT ws_heatingCapDes;    // design heating capacity, Btuh
                                //    = ws_heatingCapDesTopN[ 6] or as changed
                                //    defaults from EcoSizer at end of prerun if not input
                                //    No direct use, must be passed to DHWHEATER via ALTER
  *i FLOAT_GZ ws_volRunningDes; // design running volume, gal
                                //   = active volume (above aquastat)
                                //    full tank volume derived from running volume
                                //      in HPWHLINK::hw_DeriveVolFromVolRunning
                                //    defaults from EcoSizer at end of prerun if not input
                                //    No direct use, must be passed to DHWHEATER via ALTER
  *i FLOAT_GZ ws_fxDes;         // DHW design excess size factor, default 1
                                //    Applied if/when ws_heatingCapDes and/or ws_volRunningDes
                                //    are defaulted from EcoSizer at end of prerun.
                                //    No effect if those values are input.

  *r FLOAT ws_tUse;			// hot water use temp, F
							//   = temp of water delivered to fixtures or DHWLOOP(s)
							//   default = 120 F
  *h FLOAT ws_tSetpoint;	// DHWHEATER set point (for all DHWHEATERs using HPWH model), F
							//   default = ws_tUse
  *h FLOAT ws_tSetpointLH;	// DHWLOOPHEATER set point (for all child DHWLOOPHEATERs using HPWH model), F
							//   default = ws_tUse
  *r DHWDRMETH ws_drMethod	// DHW demand response control method
							//   C_DHWDRMETH_NONE, C_DHWDRMETH_SCHED, 
  *h DHWDRSIG ws_drSignal;	// DHW demand response control signal
  *h *e INT ws_drStatusHPWH;// DHW demand response HPWHsim base drStatus for hour
							//   may be modified at subhour or tick ivl

  *s *hide DBL ws_tOutPrimSum;	// working var re ws_tOutPrimLT
  *s *e FLOAT ws_tOutPrimLT;	// primary water heater outlet temp, F
								//   for HPWH only, re DHWLOOPHEATER entering temp
								//   best estimate from prior 1-min tick
  *d TI ws_dayUsei;			// idx of DHWDAYUSE
  *d CHP ws_dayUseName;		// name of DHWDAYUSE (resolved at runtime)
  *r INT ws_childDHWDAYUSEFlag;	// nz iff at least one child DHWSYS has specified ws_dayUseName
  *declare "bool ws_HasDHWDAYUSEDraws() const { return ws_dayUseName != NULL || ws_childDHWDAYUSEFlag; }"
  *h FLOAT_GEZ ws_parElec;	// electrical parasitic power, W
							//    for e.g. unmodeled recirculation pumps
  *i FLOAT_GZ ws_SDLM;		// standard distribution loss multiplier
							//   see ACM AppE Eqn RE-5
  *i FLOAT_GZ ws_DSM		// distribution system multiplier (AppE table RE-2)
  *h FLOAT_GEZ ws_SSF		// user input solar savings fraction
							//  valid range 0 - 0.99, see code
							//  approximates savings by modifyng inlet water temp
							//  not allowed (and set 0) when DHWSOLARSYS is specified
  *declare "void ws_TickApplySSF();"
  *h FLOAT_GEZ ws_WF		// waste factor applied to ws_hwUse and DHWUSEs
							//   default=1.  CEC procedures use 0.9 for
							//   systems having within unit recirc.
  *h *e *array NDHWENDUSESPP INT ws_drawCount;	
							// (approx) total # of draws in run (generally full year) by end use
							//   draws spanning midnight double counted
							//   draws with same eventID counted individually
							//  [ 0]: total (including unknown end use)
							//  [ 1..]: per C_DHWEUCH_xxx
  *r *array NDHWENDUSESPP FLOAT ws_drawsPerDay;

  *h *e *array NDHWENDUSESPP FLOAT_GEZ ws_drawDurF;	// water heater draw duration factors by end use
							// accounts for warm-up waste and pipe losses for DHWDAYUSE draws
							// factor = actual draw duration / nominal draw duration
							//   [ 0] = unknown end use (DHWUSEs w/o wu_hwEndUse) (*not* ws_hwUse)
							//   [1 ..] = per C_DHWEUCH_xxx
  *i DHWBRANCHMODELCH ws_branchModel	// branch model selection
							//   _T24DHW: prior ACM App-B
							//   _DRAWWASTE: draw duration increase per ws_drawWaste
                            //   _DAYWASTE: draw duration increase per ??
  *h *array NDHWENDUSESPP FLOAT ws_drawWaste;	// water waste per draw, gal
							// converts to time added to draw duration
							//   [ 0] unknown end use
							//   [ 1..] = per C_DHWEUCH_xxx
  *i *array NDHWENDUSESPP FLOAT ws_dayWasteDrawF;	// relative draw for day waste scheme
							//   [ 0] unknown end use
							//   [ 1..] = per C_DHWEUCH_xxx
  *i FLOAT_GEZ ws_dayWasteVol			// base daily total draw waste, gal/day
  *i FLOAT_GEZ ws_dayWasteBranchVolF	// additional daily draw waste, discards/day
										//    DHWLOOPBRANCH volume multiplier
  *r FLOAT_GEZ ws_dayWaste		// daily draw waste, gal/day
								// ws_dayWasteVol + ws_dayWasteBranchVolF * (total DHWLOOPBRANCH volume)
  *r *e FLOAT_GEZ ws_dayWasteScale
  *declare "double ws_DrawWaste( int iEU) const { return ws_drawWaste[ iEU] + ws_dayWasteDrawF[ iEU]*ws_dayWasteScale; }"

  *r FLOAT_GEZ ws_childDHWSYSCount; // # of child DHWSYSs iff central system (else 0)
									//    note may not be integral
  *r FLOAT_GEZ ws_whCount;		// # of (primary) DHWHEATERs serving this DHWSYS
								//   = SUM( DHWHEATER.wh_mult) (possibly non-integral)
  *r FLOAT_GEZ ws_wlhCount;		// # of DHWLOOPHEATERs in this DHWSYS
								//   = SUM( DHWLOOPHEATER.wh_mult) (possibly non-integral?)
  *r FLOAT_GEZ ws_whCountUseTS;	// # of DHWHEATERs serving this DHWSYS that respond to ws_tSetpoint
								//   used for re "ignore" msg(s)
  *r FLOAT_GEZ ws_wlhCountUseTS;// # of DHWLOOPHEATERs serving this DHWSYS that respond to ws_tSetpointLH
								//   used for re "ignore" msg(s)
  *r INT ws_wtCount;			// # of child DHWTANKs
  *r INT ws_wpCount;			// # of child DHWPUMPs
  *r INT ws_wlCount;			// # of child DHWLOOPs (aka NLOOPk)
  *r INT ws_configChecked;		// set non-0 when configuration has been checked (see ws_Init())
								//   WHY: reduces info message when >1 RUN
								//   side effect: does not re-check after ALTER

  *r *nest SEGTOTS ws_loopSegTotals;	// aggregated totals, all child loop segments

  *r *nest SEGTOTS ws_branchTotals;		// aggregated totals, all child branches

  *r INT ws_wrCount;		// total child DHWHEATRECs
  *r INT ws_wrFeedWHCount;	// count of child DHWHEATRECs that provide
							//    feed (cold) water to DHWHEATERs
							//    DHWHEATRECs may feed fixtures or WH or both
  *r INT ws_wrFxDrainCount;	// count of fixture drains feeding (possibly shared) DHWHEATRECs
  *r *array NDHWENDUSESPP SI_GEZ ws_fxCount;
							// end-use count of fixtures served by this DHWSYS
							//   non-central: user input, default 1
							//   central: derived from child DHWSYSs
							// used re allocation of shared loads
  *declare "int ws_ShowerCount() const { return ws_fxCount[ C_DHWEUCH_SHOWER]; }"
							// number of shower fixtures served by this DHWSYS
							//   re DHWHEATREC (DWHR) modeling
  *declare "struct DHWFX* ws_fxList;"	// fixture info list (re DHWHEATREC assignment)

							// Load sharing -- support of multiple DHWSYSs in single unit
							//   draws are distributed among DHWSYSs having suitable fixtures
							//   aka "deal-em-out" algorithm
  *i TI ws_loadShareDHWSYSi	// index of DHWSYS with which this DHWSYS shares load
  *r *array NDHWENDUSESPP INT ws_loadShareCount;
							// # of DHWSYSs sharing group load by end use
							//   ([ 0] = # of DHWSYSs in group)
							//   NOT effected by ws_mult.
							//   All DHWSYSs in group have same ws_loadShareCounts
  *declare "int ws_loadShareIdxRange[ NDHWENDUSESPP][ 2];"
							// draw (eventID%loadShareCount[ iEU]) yields idx
							// if idx is within this DHWSYS's range, draw is assigned
  *declare "int& ws_LSR( int iEU, int lh) { return ws_loadShareIdxRange[ iEU][lh]; }"
  *declare "void ws_LSRSet( int iEU, int fx0, int nFx) { ws_LSR( iEU,0) = nFx>0 ? fx0 : -1; ws_LSR( iEU,1) = nFx>0 ? fx0+nFx-1 : -1; }"
  *declare "bool ws_IsLSR( int iEU, int idx) { return idx>=ws_LSR( iEU,0) && idx<=ws_LSR( iEU,1); }"
  *d *e *array NDHWENDUSESPP INT ws_loadShareWS0;	// re allocation of shared load
							// idx for ws_eventID=0 by end use, set daily based on jDay

  *i NOYESCH ws_drawCSV		// iff C_NOYESCH_YES, write tick-level draw data to
							//    <inputFile>_<DHWSYS.name>_draws.csv
  *declare "FILE* ws_pFDrawCSV;"	// draw export file
  *declare "RC ws_WriteDrawCSV();"

  *h *e FLOAT ws_HHWO;		// current total recovery load (at water heater), Btu
  *h *e FLOAT ws_DLM;		// distribution loss multiplier (calc'd)
  *h *e FLOAT ws_volRL;		// current hour all-DHWLOOP return volume, gal
  *h *e FLOAT ws_tRL;		// current hour all-DHWLOOP return temp, F
  *h *e FLOAT ws_HRBL;		// current hour all-DHWLOOPBRANCH losses, Btu
  *h *e FLOAT ws_t24WL;		// current hour all-DHWLOOPBRANCH waste loss volume, gal
							//    per T24DHW branch model
							//    info only: associated energy is included in ws_HRBL
  *y *e DBL ws_t24WLTot		// annual total ws_t24WL, gal

  *h *e FLOAT ws_HRDL		// current hour recirculation loss, Btu
							//   = ws_HRBL + DHWLOOPSEG losses
							//     (adjusted re DHWLOOP wl_lossMakeupPwr)
  *s *e FLOAT ws_HJLsh;		// current subhour jacket losses (from DHWTANKs), Btu
  *h *e FLOAT ws_HJL;		// hour total jacket losses (from DHWTANKs), Btu
  *h *e FLOAT ws_HARL;		// hour total adjusted recovery load, Btu
*END		// DHWSYS

//=============================================================================
RECORD HPWHLINK "HPWHLink" *SUBSTRUCT	// Ecotope's HPWH tank and heater
*prefix hw_
*exdes

*declare "static WStr hw_GetHPWHVersion();"
*declare "static void hw_HPWHMessageCallback( const std::string message, void* contextPtr);"
*declare "void hw_HPWHReceiveMessage( const std::string message);"
*declare "void hw_Cleanup();"
*declare "RC hw_Init( record* pOwner);"
*declare "RC hw_InitGeneric( float vol, float EF, float resUse);"
*declare "RC hw_SetHeatingCap( float heatingCap, float ashpTSrcDes,	float tInletDes, float tUseDes);"
*declare "RC hw_GetHeatingCap( float& heatingCap, float ashpTSrcDes, float tInletDes, float tUseDes) const;"
*declare "enum HPWHATTR { hwatSMALL=0x1000, hwatLARGE=0x2000, hwatMASK=0xf000 };"
*declare "static int hw_HPWHInfo( WHASHPTYCH ashpTy, int& attrs);"
*declare "static int hw_IsAttr( WHASHPTYCH ashpTy, int attr) { int attrs; return hw_HPWHInfo( ashpTy, attrs) >= 0 ? (attr & attrs) != 0 : -1; }"
*declare "RC hw_InitPreset( WHASHPTYCH ashpTy);"
*declare "RC hw_InitResistance( WHRESTYCH resTy, float vol, float EF, float resHt, float resHt2, float tUse);"
*declare "RC hw_InitTank( float vol);"
*declare "RC hw_AdjustUAIf( float UA, float insulR, float tankCount=1.f);"
*declare "RC hw_InitFinalize( float inHtSupply, float inHtLoopRet);"
*declare "RC hw_GetInfo( float& vol, float& UA, float& insulR, float tankCount=1.f) const;"
*declare "float hw_GetTankSurfaceArea( float tankCount=1.f, float vol=-1.f) const;"
*declare "void hw_InitTotals();"
*declare "bool hw_HasCompressor() const;"
*declare "bool hw_IsSetpointFixed() const;"
*declare "float hw_GetTankVol() const;"
*declare "RC hw_DeriveVolFromVolRunning( float volRunning, float heatingCap, float tempRise, float& totVol) const;"
*declare "void hw_SetNQTXNodes( int nQTXNodes);"
*declare "float hw_GetTankQTXTemp() const { return float( hw_GetTankAvgTemp( 0, hw_nQTXNodes)); }"
*declare "double hw_GetTankAvgTemp( int iNode0=0, int nNodes=999) const;"
*declare "double hw_GetEstimatedTOut() const;"
*declare "void hw_SetQTX( float qTX);"
*declare "RC hw_DoHour( float& tSetpoint);"
*declare "RC hw_DoSubhrStart( float tEx, float tASHPSrc=-999.f);"
*declare "RC hw_DoSubhrTick( DHWTICK& tk, float tInlet, float scaleWH=1.f, float tMix=-1., float tMains=-1.f, float* pTOutNoMix=NULL, int drStatus=0);"
*declare "RC hw_DoSubhrTick( int iTk, float draw, float tInlet, float* pTOut, float scaleWH=1.f);"
*declare "RC hw_DoSubhrEnd( float mult, ZNR* pZn, ZNR* pZnASHPSrc);"

*declare "record* hw_pOwner;"		// owner (DHWHEATER, DHWSOLARSYS, ...)
*declare "class HPWH* hw_pHPWH;"	// pointer HPWH object

*r INT hw_HSCount;					// # of HPWH heatsources in use for current config
*declare "int* hw_HSMap;"			// runtime map by heat source (allocated at runtime)
									//   0=resistance, 1=compressor
*s FLOAT hw_tEx;					// tank surround temp, F
*s FLOAT hw_tASHPSrc;				// temp of heat pump air source, F

*s *e FLOAT_GEZ hw_qTXTick;			// current tick extra tank heat added lower tank nodes, Btu
									//   used re e.g. solar water heating tanks
									//   note <0 (tank cooling) not supported
*r INT hw_nQTXNodes					// # of tank 1/12s used in hw_qTX extra tank heat
									//   corresponds to nodes for HPWH default 12 node setup
*declare "std::vector< double>* hw_pNodePowerExtra_W;"	// runtime extra tank heat linkage to HPWH
*h FLOAT hw_fMixUse;				// factor for draw adjustment re HPWH setpoint > DHWSYS::ws_tUse
									//   Some HPWHs (e.g. Sanden) have fixed (high) setpoints
									//   draws are reduced to balance load at ws_tUse.
*h FLOAT hw_fMixRL;					// factor for loop return flow adjustment re HPWH setpoint > DHWSYS::ws_tUse
									//   Some HPWHs (e.g. Sanden) have fixed (high) setpoints
									//   Loop return flow is reduced to balance load at ws_tUse.

*s *e *array 2 DBL hw_inElec;		// current subhr HPWH electricity use, kWh
									//   [0]=resistance backup (iff HP) (not including hw_HPWHxBU)
									//   [1]=primary(=compressor or non-HP resistance) + misc
*r FLOAT hw_HPWHxBU;				// current subhr HPWH add'l backup resistance heat, Btu
									//   output water heated to ws_tUse iff HPWH output temp < ws_tUse
*s *e DBL hw_qEnv;					// current subhr heat removed by HPWH from environment, kWh
									//   + = to water heater; for 1 DHWHEATER (no wh_mult)
*s *e DBL hw_qLoss;					// current subhr HPWH standby losses, kWh.  + = to surround 
									//   for 1 DHWHEATER (no wh_mult)
*s *e DBL hw_qHW;					// current subhr HPWHtotal hot water heating, kWh.  always >= 0
									//   for 1 DHWHEATER (no wh_mult)
									//   includes heat to DHWLOOP, does not include hw_HPWHxBU
*s *e DBL hw_qTX;					// current subhr extra heat tank heat, kWh (not Btu)

*h *e INT hw_tankTempSet;			// nz iff HPWH tank temp has been initialized
*r FLOAT hw_tankHCNominal;			// nominal HPWH tank heat content, kWh (at 40 C)
									//   used as normalizing factor for energy balance checks
*s *e DBL hw_tankHCStart;			// current step starting tank heat content, kWh

*s *e DBL hw_tHWOutF;				// current substep working total re calc of hw_tHWOut
*s *e INT hw_nzDrawCount;			// current substep # of draws > 0
*h *e FLOAT hw_tHWOut;				// average hot water temp, F (at water heater)
  
*h *e INT hw_bWriteCSV;				// write HPWH debugging CSV iff nz
*declare "FILE* hw_pFCSV;"			// file for debugging CSV (opened on 1st use)

*s *e INT hw_balErrCount;			// annual count of energy balance errors
*r *e DBL hw_balErrMax;				// maximum substep energy balance error for run, kWh

*END // HPWHLINK

//=============================================================================
RECORD DHWHEATER "DHWHeater" *RAT	// input / runtime DHW heater
  *prefix wh_

  *exdes	// *declare "~DHWHEATER;"
  *declare "RC wh_CkF();"
  *declare "virtual RC RunDup( const record* pSrc, int options=0);"
  *declare "RC wh_Init();"
  *declare "void wh_InitRunTotals();"
  *declare "RC wh_RddInit();"
  *declare "void wh_SetDesc();"
  *declare "DHWSYS* wh_GetDHWSYS() const { return (DHWSYS *)getOwner();}"
  *declare "DHWHEATER* wh_GetInputDHWHEATER() const;"
  *declare "int wh_IsElec() const { return wh_heatSrc != C_WHHEATSRCCH_FUEL; }"
  *declare "int wh_IsStorage() const { return wh_type==C_WHTYPECH_STRGSML || wh_type==C_WHTYPECH_STRGLRG || wh_type==C_WHTYPECH_BUILTUP; }"
  *declare "int wh_IsScalable() const;"
  *declare "int wh_CanSetVolFromVolRunning() const;"
  *declare "int wh_UsesDerivedLDEF() const;"
  *declare "int wh_IsHPWHModel() const { return wh_heatSrc==C_WHHEATSRCCH_ASHPX || wh_heatSrc==C_WHHEATSRCCH_ELRESX; }"
  *declare "int wh_CanHaveLoopReturn() const { return wh_IsHPWHModel(); }"
  *declare "int wh_CanHaveDHWLOOPHEATER() const { return wh_GetFunction()==whfcnPRIMARY && wh_IsHPWHModel(); }"
  *declare "int wh_IsInstUEFModel() const { return wh_type==C_WHTYPECH_INSTUEF; }"
  *declare "int wh_IsSubhrModel() const { return wh_IsHPWHModel() || wh_IsInstUEFModel(); }"
  *declare "int wh_UsesTSetpoint() const { return wh_IsHPWHModel(); }"
  *declare "float wh_CalcLDEF( float arl, int options=0);"
  *declare "RC wh_DoHour();"
  *declare "RC wh_DoSubhrStart();"
  *declare "RC wh_DoSubhrTick( struct DHWTICK& tk, float scaleWH);"
  *declare "RC wh_InstUEFInit();"
  *declare "RC wh_InstUEFDoSubhrTick( double draw, float tInletWH, float scaleWH, float tUse);"
  *declare "RC wh_DoSubhrEnd( bool bIsLH);"
  *declare "RC wh_DoEndPreRun();"
  *declare "RC wh_EndIvl( IVLCH ivl, float HARL, float wsMult);"
  *declare "static WStr wh_GetHPWHVersion();"
  *declare "int wh_ReportBalErrorsIf() const;"
  *declare "virtual void ReceiveRuntimeMessage( const char* msg);"
  *declare "RC wh_HPWHInit();"
  *declare "static void wh_DRMapValidate();"
  *declare "static int wh_DRMapSigToDRStatus( DHWDRSIG drSig);"
  
  *r FLOAT_GEZ wh_mult;			// count of identical water heaters (default 1)
								//   models as if repeated identical input
								//   non-integral values allowed re sizing methods
  *i WHHEATSRCCH wh_heatSrc;	// heat source
  								//   C_WHHEATSRCCH_ELRES: electric resistance
								//     _FUEL: fuel-fired burner
								//     _ASHP: air source heat pump (T24DHW.DLL model)
								//     _ASHPX: air source heat pump (Ecotope HPWH)
								//     _ELRESX: electric resistance (Ecotope HPWH)
  *i WHTYPECH wh_type;			// heater type
  								//    C_WHTYPECH_STRGSML, _STRGLRG, _INSTSML, _INSTLRG,
								//    _INSTUEF, _BUILTUP
  *i ANAME wh_desc;				// probe-able description text
  *declare "virtual const char* GetDescription( int options=0) { options; return wh_desc; }"
  *r INT wh_fcn;				// function of this DHWHEATER per whfcnXXX enum
  *declare "enum { whfcnUNKNOWN=0, whfcnPRIMARY, whfcnLOOPHEATER, whfcnCOUNT=whfcnLOOPHEATER, whfcnLASTHEATER=0x100 };"
  *declare "int wh_GetFunction() const { return wh_fcn & 0xff; }"
  *declare "int wh_SetFunction();"
  *declare "bool wh_IsLastHeater() const { return (wh_fcn & whfcnLASTHEATER) != 0; }"
  *i WHASHPTYCH wh_ashpTy;		// air source heat pump (HPWH) type, required iff wh_heatSrc=ASHPX, else ignored
								//	  C_WHASHPTYCH_xxx, etc
  *i WHRESTYCH wh_resTy;		// resistance heater type, used iff wh_heatSrc=_ELRESX, else ignored
								//	  C_WHRESTYCH_xxx, etc
                                //    documentation only (9-2021)
  *i TI wh_znTi;				// DHWHEATER location zone re tank loss
								//    0 iff wh_tEx being used
								//	  heat losses go to half to zone air / half radiant
  *declare "ZNR* wh_pZn;"		// pointer to location zone, use wh_tEx if NULL
  *s FLOAT wh_tEx;				// surrounding temperature, F for tank loss
								//    when wh_tEx set
								//    - wh_znTi ignored
								//    - heat loss discarded
  *i TI wh_ashpSrcZnTi;			// ASHP source zone
								//    0 iff wh_ashpTSrc being used
								//    input heat removed from zone air
  *declare "ZNR* wh_pAshpSrcZn;"// pointer to ASHP heat source zone, use wh_ashpTSrc if NULL
  *s FLOAT wh_ashpTSrc;			// ASHP source temperature, F
								//    when wh_ashpTSrc set
								//    - wh_ashpSrcZnTi ignored
								//    - heat transfer ignored
  *i FLOAT_GZ wh_ashpResUse;	// resistance heat parameter for
								//   Ecotope HPWH model iff C_WHASHPTYCH_GENERIC
								//    default = 7.22, units / meaning unknown
  *r FLOAT_GZ wh_tankCount		// # of storage tanks per DHWHEATER, re built-up whType=Builtup (default=1)
								//	  note does *not* reflect wh_mult (wh_mult=2, wh_tankCount=3 -> 6 tanks)
  *r FLOAT_GZ wh_heatingCap;    // Nominal heating capacity, Btuh
                                //    available only for limited HPWH types
  *r FLOAT_GEZ wh_vol;			// total storage vol, gal (actual, not rated; not per tank)
								//    HPWH types: sets vol (default from preset)
								//    other types: documentation only (default 50)
  *i FLOAT_GZ wh_volRunning;    // running storage volume = vol above aquastat, gal
                                //    HPWH compressor types: determines reqd total volume based on
                                //    aquastat position; see HPWHLINK::hw_DeriveVolFromVolRunning()
  *r FLOAT_GEZ wh_UA;			// HPWH-type total UA, Btuh/F (not per tank)
								//    default from HPWH preset
  *r FLOAT_GZ wh_insulR;		// HPWH-type tank insulation resistance, hr-F/Btuh
								//    default from preset or wh_UA and wh_vol
  *i FRAC wh_inHtSupply;		// fractional tank height of supply inlet (0=bottom, 1=top)
								//    default 0, HPWH models only
  *i FRAC wh_inHtLoopRet;		// fractional tank height of loop return inlet(s) (0=bottom, 1=top)
								//    default 0, HPWH models only
  *i FLOAT_GZ wh_EF;			// rated energy factor
  *i FLOAT_GZ wh_LDEF;			// load-dependent energy factor
  *i FLOAT_GZ wh_UEF;			// rated uniform energy factor
								//    re C_WHTYPECH_INSTUEF
  *i FLOAT_GZ wh_ratedFlow;		// max rated flow per UEF test, gpm
  *i FLOAT_GEZ wh_annualFuel;	// annual fuel use per UEF method, therms/yr
  *i FLOAT_GEZ wh_annualElec;	// annual electricity use per UEF method, kWh/yr

  *r FLOAT wh_cycLossFuel;		// derived startup fuel use (=cyclic loss) for INSTUEF, Btu/cycle
  *r FLOAT wh_cycLossElec;		// derived startup electricity use (=cyclic loss) for INSTUEF, Btu/cycle
								//   unused in revised model, 5-25-2017
  *r FLOAT wh_maxFlowX;			// derived max flow for INSTUEF, gal-F/tick
  *r FLOAT wh_maxInpX;			// input at max flow, Btu/tick

  *i FLOAT_GZ wh_eff;			// efficiency (aka recovery efficiency)
  *i FLOAT_GEZ wh_SBL;			// standby loss, Btuh
  *h FLOAT_GEZ wh_pilotPwr;		// pilot light power, Btuh
								//   included in wh_inFuel
  *h FLOAT_GEZ wh_parElec;		// parasitic electric use, W
  *h FLOAT wh_tHWOut;			// average hot water temp, F (at water heater)
								//   HPWH: as delivered by model (subhr average of tick calls)
								//   other: DHWSYS.ws_tUse
  *s INT wh_stbyTicks;			// time since last draw, for HPWH and INSTUEF, ticks
								//   re startup (cyclic) loss model

  *i FLOAT_GEZ wh_loadCFwdF;	// load carry-forward allowed (user input frac of capacity)
								// = approx # of hours DHWHEATER is allowed to meet
								//       load that is unmet on 1 min basis
								// default = 1; only for C_WHTYPECH_INSTUEF
  *i DBL wh_loadCFwdMax;		// max load carry-forward energy (from wh_loadCFwdF), Btu
								//   any excess load met via wh_qXBU
  *s DBL wh_loadCFwd;			// current load carry forward, Btu
								//   see wh_InstUEFDoSubhr()
  *s *e FLOAT wh_nTickFullLoad;	// INSTUEF: current subhour equiv full load ticks (fractional)
  *s DBL wh_nColdStarts;		// INSTUEF: current subhour # of cold startups 

  *s *e FLOAT wh_effSh;			// current subhour efficiency, used to support former hourly
								//   models within tick calcs
								//   unset (= 0) for full tick models (HPWH and INSTUEF)


  *r FLOAT wh_operElec;			// electrical power during operation at rating conditions, Btuh
								//   never input, derived for INSTUEF
  *r FLOAT_GEZ wh_stbyElec;		// electrical power during standby, W
								//   default=4, used for INSTUEF

  *i FLOAT_GEZ wh_resHtPwr;		// upper element resistance heating power, W
								//   used for some models only
								//   default = 4500
  *i FLOAT_GEZ wh_resHtPwr2;	// lower element resistance heating power, W
								//   default = wh_resHtPwr

  *s *e *nest HPWHLINK wh_HPWH;		// interface to Ecotope HPWH detailed heat pump model
									//    also used for resistance electric heaters

  *s *e FLOAT wh_qXBU;				// current step HPWH add'l backup resistance heat, Btu
									//   output water heated to ws_tUse iff HPWH output temp < ws_tUse
  *s *e DBL wh_qEnv;				// current step heat removed by HPWH from environment, kWh
									//   + = to water heater; for 1 DHWHEATER (no wh_mult)
  *s *e DBL wh_qLoss;				// current step HPWH standby losses, kWh.  + = to surround 
									//   for 1 DHWHEATER (no wh_mult)
  *s *e float wh_qHW;				// current step hot water heating, kWh.  always >= 0
									//   for 1 DHWHEATER (no wh_mult)
									//   includes heat to DHWLOOP, does not include wh_qXBU
  *s *e INT wh_nzDrawCount;			// current substep # of draws > 0

  *h *e INT wh_bWriteCSV;			// write HPWH debugging CSV iff nz
  *declare "FILE* wh_pFCSV;"		// file for debugging CSV (opened on 1st use)

  

  *h *e DBL wh_totHARL;		// cumulative (year to date) recovery load at heater, Btu
							//   = SUM( HARL) (includes losses, solar etc)
							//   for single heater (wh_mult not applied)
  *h *e INT wh_hrCount;		// # of hourly values included in wh_totHARL
							//   re calc of avg
  *h *e DBL wh_totOut;		// cumulative (year to date) total heat delivered to hot water, Btu
							//   includes wh_qXBU


							// energy inputs for current subhour, Btu
							//   subhour results accumulated here
							// for single WH (wh_mult / ws_mult not applied)
  *s *e FLOAT wh_inElecSh;		//    primary electricity (including wh_parElec) (note not kWh)
								//		 for HPWH, includes compressor + misc (not resistance)
  *s *e FLOAT wh_inElecBUSh;	//    backup electricity (>0 only for HPWH resistance heat)
								//       (does not include wh_inElecXBUSh)
  *s *e FLOAT wh_inElecXBUSh;	//    XBU "extra" backup (reheating to maintain ws_tUse)
  *s *e FLOAT wh_inFuelSh;		//	  fuel (including wh_pilotPwr)
    

							// energy inputs for current hour, Btu
							//   set from analogous subhour values
								// for single WH (wh_mult / ws_mult not applied)
  *h *e FLOAT wh_inElec;		//    primary electricity (including wh_parElec) (note not kWh)
								//		 for HPWH, includes compressor + misc (not resistance)
  *h *e FLOAT wh_inElecBU;		//    backup electricity (>0 only for HPWH resistance heat)
								//       (does not include wh_inElecXBU)
  *h *e FLOAT wh_inElecXBU;		//    XBU "extra" backup (reheating to maintain ws_tUse)
  *h *e FLOAT wh_inFuel;		//	  fuel (including wh_pilotPwr)

							// annual total energy inputs, Btu (check figures)
  *r *e DBL wh_inElecTot;	//    annual total electricity, Btu
  *r *e DBL wh_inFuelTot;	//    annual total fuel, Btu

  *i TI wh_elecMtri			// meter for system electricity use (default = parent ws_elecMtri)
  *i TI wh_fuelMtri			// meter for system fuel use (default = parent ws_fuelMtri)
  *i ENDUSECH wh_xBUEndUse;	// wh_elecMtri end use for separate accounting of wh_HPWHxBU
							//   default = none (include wh_HPWHxBU in end use dhwBU)
  *declare "MTR* wh_pMtrElec; MTR* wh_pMtrFuel;"
							// runtime pointers to meters, NULL if not accum'ing
  *declare "DHWSYSRES_IVL* wh_pResSh;"	// pointer to DHWSYSRES subhour record
										//   re heat output accounting

  *h *e INT wh_unMetSh;				// count of subhrs in this hour
									//   when wh_tHWOut < wh_tUse
									//   HPWH only?
  *y *e INT wh_unMetHrs;			// annual count of hrs having any wh_unMetSh
									//   HPWH only?
  *s *e INT wh_balErrCount;			// annual count of energy balance errors
									//   HPWH only?

  *h *e FLOAT wh_tInlet				// hour avg inlet temp, F
									//   reflects solar, DWHR, mixdown, ...
  *h *e FLOAT wh_draw				// hour total draw seen by this DHWHEATER, gal
									//   check figure


*END	// DHWHEATER
//=============================================================================
RECORD DHWHEATREC "DHWHeatRec" *RAT	// input / runtime drain water heat recovery (DWHR)
  *prefix wr_

  *exdes	// *declare "~DHWHEATREC"
  // *declare "virtual RC RunDup( const record* pSrc, int options=0);"
  *declare "RC wr_CkF();"
  *declare "RC wr_Init();"
  *declare "void wr_InitTicks();"
  *declare "DHWSYS* wr_GetDHWSYS() const { return (DHWSYS *)getOwner(); }"
  *declare "float wr_EffAdjusted( float vp, float tpI, float vd, float tdI);"
  *declare "void wr_EffAdjustedTest();"
  *declare "bool wr_IsEffFlowIndependent() const { return wr_type == C_DWHRTYCH_SETEF || wr_effRated < .00001f; }"
  *declare "int wr_IsEquiv( const DHWHEATREC& wr) const;"
  *declare "float wr_CalcTick( DHWSYS* pWS, struct DHWHRTICK& wrtk, float vOther, float& whUseNoHR, float& fxUseMix, float& qR, float& qRWH);"
  *declare "inline float wr_HX( float vp, float tpI, float vd, float td) const"
  *declare "{ if (vp<=0.f) return tpI; float f=wr_eff*min(vp, vd)/vp; return f*td+(1.f-f)*tpI;}"
  *declare "RC wr_SetFXConnections( DHWSYS* pWS, int& iFx);"

  *declare "struct DHWHRTICK* wr_ticks;" // runtime tick info for this DHWHEATREC for current hour
										//   all draws allocated by tick so total flows are known

  *i SI_GEZ wr_mult;		// multiplier
							//   modeled as wr_mult identical heat recovery devices
  *i DHWEUCH wr_hwEndUse	// end use source for this device
							//   as of 12-18, only supports C_DHWEUCH_SHOWER
  *i DWHRTYCH wr_type		// type: C_DWHRTYCH_
							//    _HORIZ or _VERT: effectiveness adjusted per CASE regressions
							//          depending on flows and temps, same model for both
							//    _SETEF: wr_effRated used w/o modification (testing aid)
  *i SI_GEZ wr_nFXDrain		// number of fixtures (of type wr_whEndUse) draining
							//    via this DHWHEATREC
  *i SI_GEZ wr_nFXCold		// number of fixtures (of type wr_whEndUse) draining
							//    via this DHWHEATREC with cold source = this DHWHEATREC
							//    default = wr_nFXDrain
							//    if < wr_nFXDrain, remainder have cold source = mains
							//    Note: wr_feedsWH = No and wr_nFXCold=0 is illegal
  *i NOYESCH wr_feedsWH		// iff C_NOYESCH_YES, potable output is plumbed to water heater
							//    cold water inlet

  *declare "bool wr_FeedsFX() const { return wr_nFXCold > 0; }"
  *declare "bool wr_FeedsWH() const { return wr_feedsWH==C_NOYESCH_YES; }"

  *h FRAC wr_effRated			// rated effectiveness (generally CSA rating value)

  *h FLOAT_GEZ wr_tdInDiff		// drain-side inlet water temp drop from fixture mixed temp, F
								//    tdIn = tFxMix - tdInDiff;  default = 4.6 F

  *h FLOAT_GEZ wr_tdInWarmup	// drain-side inlet temp during warmup portion of draw
								//    default = 65.

  *s *e FLOAT wr_eff			// effectiveness under current conditions
  *s *e FLOAT wr_tpO			// most recent potable-side output temp, F
  *s *e FLOAT wr_vp				// most recent potable-side flow, gpm

*END
//=============================================================================
RECORD DHWTANK "DHWTank" *RAT	// input / runtime unfired DHW tank
  *prefix wt_

  *declare "virtual RC RunDup( const record* pSrc, int options=0);"
  *declare "RC wt_CkF();"
  *declare "DHWSYS* wt_GetDHWSYS() const { return (DHWSYS*)getOwner();}"
  *declare "RC wt_Init();"
  *declare "RC wt_DoHour();"
  *declare "RC wt_DoSubhr( float tUse);"

  *declare "static FLOAT TankSurfArea_CEC(float vol);"

  *i SI wt_mult;				// count of identical DHW tanks (default 1)
								//   models as if repeated identical input
  *i FLOAT_GEZ wt_UA;			// tank water-to-air UA, Btuh/F
								//   default: derived from wt_vol and wt_insulR
  *i FLOAT_GEZ wt_vol;			// tank volume, gal
  *i FLOAT_GZ wt_insulR;		// total tank insulation resistance, hr-F/Btuh
								//   = built-in + exterior wrap
  *h FLOAT wt_tTank;			// assumed tank water temperature, F
								//   default = DHWSYS ws_tUse
  *i TI wt_znTi;				// DHWTANK location zone re tank loss
								//    0 iff wt_tEx being used
								//	  heat losses go to half to zone air / half radiant
  *declare "ZNR* wt_pZn;"		// pointer to location zone, use wt_tEx if NULL
  *h FLOAT wt_tEx;				// surrounding temperature, F for tank loss
								//    when wt_tEx set
								//    - wt_znTi ignored
								//    - heat loss discarded
  *h FLOAT wt_xLoss;			// other tank temp-independent losses, Btuh
								//   for e.g. T24 fitting losses
  *s *e FLOAT wt_qLossSh;		// current subhr loss rate, Btuh
  *h *e FLOAT wt_qLoss;			// current hour's total loss, Btu
								//   for 1 tank (no wt_mult)
*END
//=============================================================================
RECORD DHWPUMP "DHWPump" *RAT	// input / runtime DHW pump
  *prefix wp_

  *declare "RC wp_CkF();"
  *declare "virtual RC RunDup( const record* pSrc, int options=0);"
  *declare "DHWSYS* wp_GetDHWSYS() const { return (DHWSYS*)getOwner(); }"
  *declare "float wp_DoHour( int mult, float runF=1.f);"
  *i SI wp_mult;				// count of identical DHW pumps (default 1)
								//   models as if repeated identical input

  *i TI wp_elecMtri				// meter for pump electricity use (default = parent ws_elecMtri)
  *declare "MTR* wp_pMtrElec;"	// runtime pointers to meter, NULL if not accum'ing

  *h FLOAT_GEZ wp_pwr;			// pump power, W
  *h FRAC wp_liqHeatF;			// fraction of wp_pwr added to liquid stream
								//   remainder is discarded
								//   used only for DHWLOOPPUMP

  								// energy inputs for current hour, Btu
  *h *e FLOAT wp_inElec;		//    electricity (note not kWh)
								//      for 1 pump (no wp_mult)

*END		// DHWPUMP
//=============================================================================
RECORD DHWLOOP "DHWLoop" *RAT // input / runtime DHW recirc loop
// child of DHWSYS
  *prefix wl_

  *declare "RC wl_CkF();"
  *declare "virtual RC RunDup( const record* pSrc, int options=0);"
  *declare "RC wl_Init();"
  *declare "DHWSYS* wl_GetDHWSYS() const { return(DHWSYS*)getOwner(); }"
  *declare "RC wl_DoHour( int wsMult);"

  *i SI wl_mult			// multiplier: number of identical loops
  *r SI wl_wlpCount		// total # of child DHWLOOPPUMPs
  *h FLOAT_GEZ wl_flow	// current loop recirculation max flow, gpm
  *h FLOAT_GEZ wl_runF	// current hour recirculation operation fraction
  *h FLOAT_GZ wl_tIn1	// entering temperature at 1st DHWLOOPSEG
  *i FLOAT_GZ wl_fUA	// UA adjustment factor for child DHWLOOPSEGs
						//    fudge factor re imperfect insulation
  *h FLOAT_GEZ wl_lossMakeupPwr	// loss makeup heating (electrical) power, W
								//    represents heater that makes up for HRLL losses
								//    re central HPWH systems
  *h FLOAT_GZ wl_lossMakeupEff	// loss makeup heating efficiency
  *i TI wl_elecMtri;			// meter for loop electricity use (default = parent ws_elecMtri)
								//   loss makeup DHWLOOPPUMP electricity accumulated to end use dhwMFL
  *declare "MTR* wl_pMtrElec;"	// runtime pointers to meter, NULL if not accum'ing
  *r *nest SEGTOTS wl_segTotals;	// Aggregated totals for all child DHWLOOPSEGs
									//   count, len, vol, exArea, UA
									//   values DO NOT reflect wl_mult
  *r *nest SEGTOTS wl_branchTotals;	// Aggregated totals for all child DHWLOOPBRANCHs
									//   count, len, vol, exArea, UA
									//   values DO NOT reflect wl_mult
  *h *e FLOAT wl_volRL; // current hour volume returned to water heater, gal
						//    (reflects wl_mult)
						//    reduced by loss makeup
  *h *e FLOAT wl_qLiqLP; // heat added to liquid by DHWLOOPPUMP(s), Btu
  *h *e FLOAT wl_HRLL;	// current hour loop seg pipe losses, Btu
						//    (reflects wl_mult and reduction by wl_lossMakeupPwr)
  *h *e FLOAT wl_HRLLnet; // wl_HRLL adjusted for pump by pump heat and
						//   wl_lossMakeUp, Btu (reflects wl_mult)
  *h *e FLOAT wl_HRBL;	// current hour branch pipe loss, Btu
						//    (reflects wl_mult)
  *h *e FLOAT wl_t24WL;	// current hour branch waste loss volume, gal
						//    per T24DHW model; reflects wl_mult
						//    info only: associated energy is included in wl_HRBL
  *h *e FLOAT wl_tRL;	// current hour average return temp, F
						//    derived from flow, loss, and wl_qLiqLP
						//    can be > wl_tIn1
						//    may not be same as ps_tOut of last segment
  
*END	// DWHLOOP

//============================================================================
RECORD PBC "PBC" *SUBSTRUCT *BASECLASS SBCBASE	// pipe boundary condition
*prefix sb_
*declare "void sb_Init( PIPESEG* pPS);"
*declare "virtual int sb_Class() const;"
*declare "virtual double sb_AreaNet() const;"
*declare "virtual const char* sb_ParentName() const;"
#if 0
*declare "void sb_SetRunConstants( ZNR* zpx);"
*declare "void sb_SetCoeffs( ZNR* zpx);"
#endif

*i PIPESEGP sb_pPS			// pointer to parent PIPESEG

*END // PBC
//=============================================================================
RECORD PIPERUN "PipeRun" *SUBSTRUCT	// simple pipe run (TODO: make into PIPESEG mixin)
*prefix pr_
*excon

#if 0
*declare "virtual double sb_AreaNet() const;"
*declare "virtual const char* sb_ParentName() const;"
*declare "void sb_SetRunConstants( ZNR* zpx);"
*declare "void sb_SetCoeffs( ZNR* zpx);"
#endif
    *declare "float pr_DeriveSizeFromFlow( float flow, float desVel);"
	*declare "float pr_GetOD( int bInsul) const;"
	*declare "float pr_CalcUA( float fUA=1.f);"
	*declare "float pr_SetBeta( float mCp, float fUA=1.f);"
	*declare "float pr_TempOutlet( float tIn, float tEx) const { return pr_beta*tIn + (1.f-pr_beta)*tEx;}"
	*declare "void pr_CalcGeom();"
	*declare "float pr_CalcTOut( float tIn, float flow) const;"

	*i FLOAT_GEZ pr_len			// segment length, ft
	*i FLOAT_GZ pr_size			// nominal pipe size (diameter), in
								//   pipe actual OD = ps_size + 0.125
	*i FLOAT_GZ pr_insulK		// insulation conductivity, Btuh-ft/ft2-F
	*i FLOAT_GEZ pr_insulThk	// insulation thickness, in
	*i FLOAT_GZ pr_exH			// combined exterior surface coefficient, Btuh/ft2-F
	*r *noname *nest SEGTOTS pr_totals;	// run totals (re st_Accum() to parents)
										//   also retains vol, UA, exArea used in calcs

	*s FLOAT pr_beta			// temperature loss (1 - approach-to-surround) factor
*END // PIPERUN
//=============================================================================
RECORD PIPESEG "PipeSeg" *RAT	// pipe segement (for DHWLOOPSEG, DHWLOOPBRANCH, ...)
    *prefix ps_
	*excon
	*declare "float ps_CalcUA( float fUA=1.f);"
	*declare "float ps_CalcTOut( float tIn, float flow) const;"
	*declare "void ps_CalcGeom();"
	*declare "float ps_GetOD( int bInsul) const;"

	*i FLOAT_GEZ ps_len			// segment length, ft
	*i FLOAT_GZ ps_size			// nominal pipe size (diameter), in
								//   pipe actual OD = ps_size + 0.125
	*i FLOAT_GZ ps_insulK		// insulation conductivity, Btuh-ft/ft2-F
	*i FLOAT_GEZ ps_insulThk	// insulation thickness, in
	*i FLOAT_GZ ps_exH			// combined exterior surface coefficient, Btuh/ft2-F

	*s *noname *nest PBC ps_sbcO // (outside) surface boundary conditions
								//   represents coupling(s) between pipe exterior
								//   surface and adjacent zone or ambient
	*i EXCNDCH ps_exCnd			// adjacent cond: adiabatic/ambient/specT/adjZn.
	*h FLOAT ps_exT				// surround temperature, F

	*r *nest SEGTOTS ps_totals;	// segment totals (re st_Accum() to parents)
								//   also retains vol, UA, exArea used in calcs
	*r FLOAT_GZ ps_fRhoCpX;		// fluid volumetric heat flow factor, Btuh/gpm-F
								//    initialized for water, code otherwise general
	*h *e FLOAT ps_fvf;			// fluid volumetric flow rate, gpm (note: not ft3/hr)
	*h *e FLOAT ps_tIn			// current hour inlet fluid temp, F
	*h *e FLOAT ps_tOut			// current hour outlet fluid temp, F
	*h *e FLOAT ps_PLWF			// current hour heat loss when flowing, Btu
	*h *e FLOAT ps_PLCD			// current hour standing (noflow) heat loss, Btu
	*h *e FLOAT ps_PL			// ps_PLWF + ps_PLCD

*END	// PipeSeg
//=============================================================================
RECORD DHWLOOPSEG "DHWLoopSeg" *RAT *BASECLASS PIPESEG // input / runtime DHW recirc loop segment
// child of DHWLOOP
  *prefix wg_

  *declare "RC wg_CkF();"
  *declare "virtual RC RunDup( const record* pSrc, int options=0);"
  *declare "RC wg_Init();"
  *declare "DHWLOOPSEG* wg_GetInputDHWLOOPSEG() const;"
  *declare "DHWLOOP* wg_GetDHWLOOP() const { return (DHWLOOP*)getOwner(); }"
  *declare "DHWSYS* wg_GetDHWSYS() const;"
  *declare "float wg_CalcUA();"
  *declare "RC wg_DoHour( float tIn);"

  *i DHWLSEGTYCH wg_ty		// type: C_DHWLSEGTYCH_SUP / _RET
  *r FLOAT wg_wbCount		// total # of child DHWLOOPBRANCHs
							//   note: may be non-integer
  *h FLOAT wg_fNoDraw		// fraction of hour when there is no draw
  *h *e FLOAT wg_LL			// current hour loop loss, Btu
							//   = ps_PL - loss attributed to draw flow
							
  *h *e FLOAT wg_BL			// current hour child DHWLOOPBRANCH losses, Btu
  *h *e FLOAT wg_t24WL		// current hour child DHWLOOPBRANCH waste loss volume, gal
							//    associated energy is in wg_BL
 *END		// DHWLOOPSEG
//=============================================================================
RECORD DHWLOOPBRANCH "DHWLoopBranch" *RAT *BASECLASS PIPESEG // input / runtime DHW branch
// child of DHWLOOPSEG
  *prefix wb_

  *declare "RC wb_CkF();"
  *declare "virtual RC RunDup( const record* pSrc, int options=0);"
  *declare "RC wb_Init();"
  *declare "DHWLOOPSEG* wb_GetDHWLOOPSEG() const { return (DHWLOOPSEG *)getOwner();}"
  *declare "DHWLOOP* wb_GetDHWLOOP() const;"
  *declare "DHWSYS* wb_GetDHWSYS() const;"
  *declare "float wb_CalcUA();"
  *declare "RC wb_DoHour( float tIn);"

  *i FLOAT wb_mult;		// # of identical branches
						//  (note non-integral values allowed)
  *i FLOAT_GEZ wb_fUA	// UA adjustment factor for this branch
						//    fudge factor re imperfect insulation
  *h FLOAT_GEZ wb_fWaste	// waste fraction
  *h FLOAT_GEZ wb_flow	// assumed flow during use, gpm
						// current hour losses, Btu for one branch (no wb_mult)
  *h *e FLOAT wb_HBUL	//  ... when water in use
  *h *e FLOAT wb_HBWL	//  ... waste loss
  *h *e FLOAT wb_t24WL	//  ... waste loss volume, gal

 *END		// DHWLOOPBRANCH
//=============================================================================
RECORD DHWLOOPPUMP "DHWLoopPump" *RAT *BASECLASS DHWPUMP // input / runtime DHW loop pump
  *prefix wlp_

  *declare "RC wlp_CkF();"
  *declare "virtual RC RunDup( const record* pSrc, int options=0);"
  *declare "DHWLOOP* wlp_GetDHWLOOP() const { return (DHWLOOP*)getOwner(); }"
  *declare "DHWSYS* wlp_GetDHWSYS() const;"

  *i *hide SI wlp_dummy		// RCDEF objects to RECORD with no members
*END		// DHWLOOPPUMP
//=============================================================================
RECORD DHWDAYUSE "DHWDayUse" *RAT	// input / runtime DHW daily draw schedule
  *prefix wdu_

  // *declare "virtual RC RunDup( const record* pSrc, int options=0);"
  *declare "RC wdu_CkF();"
  *declare "RC wdu_Init( int pass);"
  // Note: DHWSYS linkage handled *only* via wdu_DoHour() args
  //       A given DHWDayUse can be ref'd by multiple DHWSYSs
  *declare "RC wdu_DoHour( DHWSYS* pWS) const;"

  *h FLOAT_GEZ wdu_mult		// multiplier applied to all child DHWUSE wuFlows
							//   note FLOAT (not integer)

						// runtime (see wdu_RunInit()): range of ss values
						//    for DHWUSEs belonging to this DHWDAYUSE
						//    Typically all DHWUSEs in range will be
						//    children of this DHWDAYUSE, but not guaranteed.
						//    ownership should be checked within loops.
  *r SI wdu_wuSsBeg;	//	initial ss
  *r SI wdu_wuSsEnd;	//  last ss+1
  *r INT wdu_wuCount;	// count of child DHWUSEs
*END		// DHWDAYUSE
//=============================================================================
RECORD DHWUSE "DHWUse" *RAT	// input / runtime DHW single draw
  *prefix wu_

  // *declare "virtual RC RunDup( const record* pSrc, int options=0);"
  *declare "RC wu_CkF();"
  *declare "DHWDAYUSE* wu_GetDHWDAYUSE() const { return (DHWDAYUSE*)getOwner();}"
  *declare "RC wu_DoHour( DHWSYS* pWS, float mult, int iH);"
  *declare "RC wu_DoHour1( DHWSYS* pWS, float mult, int iH, double begM, double begMHot, double endM);"
  *declare "RC wu_CalcHotF( float tHot, float tCold, float& hotF) const;"

  *i DHWEUCH wu_hwEndUse // hot water end use
							//   0 = unknown
							//	 C_DHWEUCH_FAUCET, _SHOWER, _BATH, _CWASHR, _DWASHR
  *i SI_GEZ wu_eventID		// user-defined index that identifies DHWUSEs belonging to a single
							//   event (e.g. all DHWUSEs of a clotheswasher cycle).
							//   Used re allocation of DHWUSEs to multiple water heaters.
							// Input values are *at fixture*
  *h FLOAT_GEZ wu_start		//   draw starting hour of day, 0 - 23.999
  *h FLOAT_GEZ wu_dur		//   flow duration, min
  *h FLOAT_GEZ wu_flow		//   mixed flow rate, gpm
  *h FRAC wu_hotF			//   fraction hot water, default = 1
							//       input value used iff wu_temp NOT given
  *h FLOAT_GZ wu_temp		//   use temperature, F.  If given,
							//      hot water draw is calculated assuming
							//		   cold water mixing (mains or from heat rec)
  *h FLOAT_GEZ wu_heatRecEF	//   heat recovery effectiveness
							//      re local drain water heat exchange
							//      Must be 0 for C_DHWEUCH_SHOWER if DHWSYS has DHWHEATREC.
							//      Checked at runtime only since DHWDAYUSE use by DHWSYS
							//        can change daily.
  *r INT wu_drawSeqN		// sequence number of draw by ws_hwEndUse
							//    assigned at runtime, see wdu_RunInit()
							//    used re random assignment of draws to DHWHEATRECs
*END	// DHWUSE
//=============================================================================
RECORD DHWSOLARSYS "DHWSolarSys" *RAT	// input / runtime DHW solar system
  *prefix sw_

  *declare "virtual void ReceiveRuntimeMessage(const char* msg);"
  *declare "RC sw_CkF();"
  *declare "RC sw_Init();"
  *declare "RC sw_DoHour();"
  *declare "RC sw_EndIvl( IVLCH ivl);"
  *declare "RC sw_DoSubhrStart( int iTk0);"
  *declare "RC sw_DoSubhrEnd();"
  *declare "void sw_TickStart();"
  *declare "RC sw_TickAccumDraw( DHWSYS* pWS, float vol, float tInlet);"
  *declare "RC sw_TickCalc( int iTk);"
  *declare "RC sw_DoSubhrTick(double vol, float tInlet, TI ws_ss, TI wh_ss, float& tOutlet);"
  *declare "FLOAT sw_GetAvailableTemp();"
  *declare "int sw_ReportBalErrorsIf() const;"
  
  *i TI sw_elecMtri;		// meter for pump and parasitic electricity use
  *i ENDUSECH sw_endUse		// end use of pump energy. defaults to "DHW"
  *declare "MTR* sw_pMtrElec;"	// runtime pointers to meter, NULL if not accum'ing
  *h FLOAT_GEZ sw_parElec;		// parasitic electricity use, W

  *r INT sw_wsCount				// # of DHWSYSs supplied by this DHWSOLARSYS
								//   (re detection of orphan DHWSOLARSYSs)

  *r FLOAT sw_scAreaTot;		// total of child DHWSOLARCOLLECTORS, ft2
  *r FLOAT sw_scCount;			// # of child DHWSOLARCOLLECTORS (not necessarily # of panels)
								//   = SUM( sc_mult)

  // Tank
  *s *e *nest HPWHLINK sw_tank;	// interface to Ecotope HPWH model (used as tank)
  *r FLOAT_GZ sw_tankVol;		// tank volume, gal
								//   default: 1.5 gal/ft2 collector area
  *r FLOAT_GEZ sw_tankUA;		// tank water-to-air UA, Btuh/F
								//   default: derived from sw_tankVol and sw_tankInsulR
  *r FLOAT_GZ sw_tankInsulR;	// total tank insulation resistance, hr-F/Btuh
								//   = built-in + exterior wrap
  *i TI sw_tankZnTi;			// Tank location zone re tank loss
								//    0 iff sw_tankTEx being used
								//	  heat losses go to half to zone air / half radiant
  *declare "ZNR* sw_tankpZn;"	// pointer to tank zone location, use sw_tankTEx if NULL
  *h FLOAT sw_tankTEx;			// surrounding temperature, F for tank loss
								//    when sw_tankTEx set
								//    - sw_tankZnTi ignored
								//    - heat loss discarded
  *h *e FLOAT sw_tankTAvg;		// hour average tank temp, F (check figure)
  *h *e FLOAT sw_tankQLoss;		// current hour's total tank loss, Btu
								//   for 1 tank (sw_mult)
  *h FRAC sw_tankHXEff;			// tank heat exchanger effectiveness
  *i FLOAT_GZ sw_tankTHxLimit	// tank temp limit, F; collector heat
								//   discarded when sw_tankTHx > sw_tankTHxLimit
								//   default = 180 F
  *h *e INT sw_overHeatTkCount	// # of ticks in this hour when collector did not run
								//   due to swtankTHx > sw_tankTHxLimit 

  *s *e FLOAT sw_tickVol;		// current tick draw to DHWSYSs, gal
  *s *e FLOAT sw_tickVolT;		// current tick (vol * inlet temp), gal-F
  *s *e FLOAT sw_tickTankTOutlet	// current tick tank outlet temp

  *h *e FLOAT sw_drawVol;		// current hour total draw, gal
  *h *e FLOAT sw_tankQGain;		// current hour total gain from solar HX (all collectors), Btu
  *y *e DBL   sw_tankQGainTot;	// sw_tankQGain annual total, Btu
  *h *e FLOAT sw_tankTInlet		// tank inlet temperature, F
  *h *e FLOAT sw_tankTOutlet	// current hour average tank outlet temperature, F
  *h *e FLOAT sw_tankTHx		// nominal tank heat exchange temp, F
								//   = avg of bottom several tank node temps
								//   used re heat exchange from collector loop
  *h *e FLOAT sw_totOut			// current hour total DHWSOLARSYS output, Btu
								//   = heat delivered to primary heater

  // Collector Fluid
  *i FLOAT_GZ sw_scFluidSpHt	// collector working fluid specific heat, Btu/lbm-F
  *i FLOAT_GZ sw_scFluidDens	// collector working fluid density, lb/ft3
  *r FLOAT_GZ sw_scFluidVHC		// collector working fluid volumetric heat capacity, Btu/gal-F
								//    derived from sw_scFluidSpHt and scFluidDens
  *h *e FLOAT sw_scTInlet		// mixed collector inlet temperature, F
  *h *e FLOAT sw_scTOutlet		// mixed collector outlet temperature, F

  // annual results
  *y *e SI sw_overHeatHrCount	// number of hours during which collector did not
								//   run (for 1 tick or more)
								//   due to swtankTHx > sw_tankTHxLimit
  *y *e FLOAT sw_SSFAnnual		// annual solar savings fraction
								//   derived from all DHWSYSs served

*END		// DHWSOLARSYS
//=============================================================================
RECORD DHWSOLARCOLLECTOR "DHWSolarCollector" *RAT		// input / runtime DHW solar collector
  *prefix sc_
  *exdes // *declare "~DHWSOLARCOLLECTOR""
  *declare "RC sc_CkF();"
  *declare "RC sc_Init();"
  *declare "static float sc_Deriveb0( float ktaX, float incA);"
  *declare "RC sc_InitIAM();"
  *declare "float sc_Kta( float incA) const;"
  *declare "float sc_FlowCorrection() const;"
  *declare "RC sc_InitPiping();"
  *declare "float sc_MCpTest() const;"
  *declare "RC sc_DoHour();"
  *declare "RC sc_DoHourEnd();"
  *declare "float sc_TempOutlet( float tInlet, float& colEff) const;"
  *declare "RC sc_DoSubhrTick();"

  //*i *noname *nest SURFGEOM sc_g;	// array geometry (re shading)

  *i FLOAT_GZ sc_mult		// multiplier (for multiple panels). Default 1.
  *r *e FLOAT_GZ sc_multLR	// last run multiplier, re probing in chained runs

  // Collector
  *i FLOAT_GZ sc_area		// SRCC collector area, ft2
  *i ANGLE sc_tilt			// Array tilt, radians (input as degrees)
  *i ANGLE sc_azm			// Array azimuth, radians (input as degrees)
  *i FLOAT sc_testFRUL		// SRCC test (rated) slope, Btuh/F-ft2
  *i FLOAT_GZ sc_testFRTA	// SRCC test (rated) intercept
  *i FLOAT_GZ sc_testMassFlow	// collector loop SRCC rating mass flow rate, lb/h-ft2
  *i FLOAT_GZ sc_oprMassFlow	// collector loop operating mass flow rate, lb/h-ft2
  *i FLOAT sc_kta60			// incidence angle modifier at 60 deg (from SRCC rating)
							//   default 0.72
							//   <= 0: IAM not applied

  *r *nest PIPERUN sc_piping	// collector piping info (length, insul, UA, ...)
  *h *e FLOAT sc_pipingTEx		// collector piping surround temp

  // derived constants
  *r FLOAT_GZ sc_areaTot	// total area, ft2 (=sc_area*sc_mult)
  *r FLOAT sc_flowCorrection	// flow correction factor
								//   sc_oprFRxx = sc_testFRxx * sc_flowCorrection
  *r FLOAT sc_oprFRUL		// operating (flow-corrected) collector slope, Btuh/F-ft2
  *r FLOAT_GZ sc_oprFRTA	// operating (flow-corrected) collector intercept
  *r FLOAT sc_oprMCp		// operating heat capacity flow rate, Btuh/F (not per ft2)
  *r FLOAT sc_oprVolFlow	// nominal collector loop volume flow rate, gpm (not gpm/ft2)
							//    derived from sc_oprMassFlow
  *r FLOAT sc_b0			// incidence angle modifier coefficient
							//   (derived from sc_Kta60)
  *r FLOAT sc_ktaDS			// tau-alpha modifier (kta) for sky diffuse radiation
							//    (constant, depends on sc_tilt only)
  *r FLOAT sc_ktaDG			// tau-alpha modifier (kta) ground-reflected diffuse radiation
							//    (constant, depends on sc_tilt only)

  // Calculated values
  *h *e FLOAT sc_incA		// beam angle of incidence, radians (PI/2 if no beam)
  *h *e FLOAT sc_ktaDB		// tau-alpha modifier (kta) for beam (varies by hour)

								// plane of array irradiance, Btu/ft2
								// adjusted by sc_ktaXX if incidence angle modifier (IAM) active
  *h *e FLOAT sc_poaRadDB			//   beam
  *h *e FLOAT sc_poaRadDS			//   diffuse from sky
  *h *e FLOAT sc_poaRadDG			//   diffuse from ground
  *h *e FLOAT sc_poaRadTot			//   total
  *h *e FLOAT sc_poaRadIAM			//   component-weighted IAM factor
									//    = sc_poaRadTot / radTot_unadjusted

  // Pump
  *r FLOAT_GEZ sc_pumpPwr;	// pump power, W
  *r FLOAT sc_tickPumpQ		// pump input energy per tick, Btu 
  *r FRAC sc_pumpLiqHeatF;	// fraction of sc_pumpPwr added to liquid stream
							//   remainder is discarded
  *r FLOAT sc_pumpDT		// fluid temp increase due to pump, F
  *r FLOAT sc_pumpOnDeltaT		// temperature difference between the 
								// tank and collector outlet where pump
								// turns on, F
  *r FLOAT sc_pumpOffDeltaT		// temperature difference between the 
								// tank and collector outlet where pump
								// turns off, F

							// this hour linear coefficients
							//   tOutlet = sc_tOutletM*tSup + sc_tOutletB
							//   eff = sc_effM*tSup + sc_effB
  *h *e FLOAT sc_tOutletM
  *h *e FLOAT sc_tOutletB
  *h *e FLOAT sc_effM
  *h *e FLOAT sc_effB

  *s *e FLOAT sc_tInlet			// tick inlet temp, F (at tank / before to-collector piping)
  *h *e FRAC sc_eff				// fraction of incident heat added to the fluid
  *s *e FLOAT sc_tickQFluid		// tick heat added to the fluid, Btu
  *h *e FLOAT sc_hrQFluid		// hour total heat added to fluid, Btu
  *y *e DBL sc_totQFluid		// run total sc_qFluid total, Btu
  *h *e FLOAT sc_tOutletP		// tick potential outlet temp, F
								//    used to determine if collector should run
  *h *e FLOAT sc_tOutlet		// tick outlet temp, F (at tank / after from-collector piping)
  
  *s *e FLOAT sc_tickVol		// volume moved during this tick, gal
  *s *e INT sc_tickOp			// nz iff pump is operating during prior tick

  *h *e FLOAT sc_pumpInElec;	// actual electricity use (note not kWh)

*END		// DHWSOLARCOLLECTOR
//=============================================================================
RECORD PVARRAY "PVArray" *RAT		// input / runtime photovoltaics array
  *prefix pv_
  *excon
  *ovrcopy
  *declare "virtual PVARRAY& CopyFrom( const record* src, int copyName=1, int dupPtrs=0);"
  *declare "void FixUp();"	// virtual fixup after basAnc reAl
  *declare "RC Validate( int options=0);"
  *declare "RC pv_CkF();"
  *declare "virtual RC RunDup( const record* pSrc, int options=0);"
  *declare "int pv_HasPenumbraShading() const;"
  *declare "int pv_AxisCount() const;"
  *declare "RC pv_SetupShading( int& nS, const class CT3D* MT, int options=0) { return pv_g.gx_SetupShading( nS, MT, options);}"
  *declare "void pv_ClearShading() { pv_g.gx_ClearShading(); }"
  *declare "int pv_CalcBeamShading( float& cosi, float& fBeam) { return pv_g.gx_CalcBeamShading( cosi, fBeam);}"
  *declare "RC pv_Init();"
  *declare "RC pv_DoHour();"
  *declare "RC pv_CalcPOA();"
  *declare "RC pv_CalcCellTemp();"
  *declare "RC pv_CalcNOCT();"
  *declare "float pv_CalcConv(float tCell, float tAir, float vWind);"
  *declare "RC pv_CalcRefr(float n1, float n2, float theta1, float& theta2, float& tau);"
  *declare "float pv_CalcSkyTemp(float tAir);"
  *declare "void pv_SetMTRPtrs();"
  *declare "MTR* pv_pMtrElec;"
  *declare "void* pv_ssc_data;"

  *i *noname *nest SURFGEOM pv_g;	// array geometry (re shading)
  *i TI pv_elecMtri;		// meter for system electricity production
  *i ENDUSECH pv_endUse		// end use of energy. defaults to "PV"
  *i FLOAT_GEZ pv_dcCap		// system capacity/size (DC nameplate), kW
  *i PVMODCH pv_moduleType	// type of module (Standard, Premium, ThinFilm)
  *i FLOAT pv_tempCoeff		// temperature coefficient, 1/F
  *i FLOAT_GE1 pv_covRefrInd  // refraction index for coating applied to cover
  *i PVARRCH pv_arrayType	// type of array (Fixed, FixedRoof, 1Axis, Backtracked, 2Axis)
  *h ANGLE pv_tilt			// Array tilt, radians (input as degrees)
  *h ANGLE pv_azm			// Array azimuth, radians (input as degrees)
  *h FRAC pv_grndRefl		// ground reflectance
  *i FRAC pv_gcr			// ground coverage ratio (what fraction of the ground is covered by the array). 1.0 implies no spacing.
  *i FLOAT_GZ pv_dcacRat	// DC to AC ratio
  *h FLOAT_GE1 pv_sif		// Shading Impact Factor
  *i FRAC pv_invEff			// inverter efficiency at rated power
  *h FRAC pv_sysLoss		// system losses
  *h *e FLOAT pv_tCell		// cell temperature, F
  *h *e FLOAT pv_aoi		// angle of incidence (radians)
  *h *e ANGLE pv_panelTilt	// tilt of pv panel (different from array tilt for tracking systems), radians
  *h *e ANGLE pv_panelAzm	// azimuth of pv panel (different from array tilt for tracking systems), radians
  *h *e ANGLE pv_panelRot	// rotation of pv panel for 1-axis tracking systems, radians clockwise from vertical
  *h *e FLOAT pv_poa		// plane of array incidence (before shading), Btu/h-ft2
  *h *e FLOAT pv_poaBeam	// plane of array beam incidence (before shading), Btu/h-ft2
  *h *e FLOAT pv_radIBeam	// beam radiation incident on array, Btu/h-ft2
  *h *e FLOAT pv_radIBeamEff	// effective beam radiation incident on array (accounts for shading impact factor), Btu/h-ft2
  *h *e FLOAT pv_radI		// total radiation incident on array, Btu/h-ft2
  *h *e FLOAT pv_radIEff	// effective total radiation incident on array (accounts for shading impact factor), Btu/h-ft2
  *h *e FLOAT pv_radTrans	// transmitted radiation (after accounting for shading impact), Btu/h-ft2
  *h *e FLOAT pv_dcOut		// DC power output, Btu
  *h *e FLOAT pv_acOut		// AC power output, Btu

  *r FRAC pv_tauNorm		// transmittance at normal incidence
  *r TEMP pv_inoct			// installed nominal operating cell temperature, F
  *r FLOAT pv_convRatio		// ratio of back convection to front convection
  *r FLOAT pv_tGrndRatio	// ratio of ground-cell temperature diff. to air-cell temperature diff.
  *r *hide FLOAT_GEZ pv_thermCap  // thermal capacitance of the array, J/kg-m2
  *h *e FLOAT pv_radILs		// last step (curently hour) total radiation incident on array, Btu/h-ft2
  *h *e FLOAT pv_tCellLs	// last step (curently hour) cell temperature, F
  *r *hide SI pv_modMap		// map to PVWatts module type input
  *r *hide SI pv_arrMap		// map to PVWatts array type input

*END		// PVARRAY
//=============================================================================
RECORD BATTERY "Battery" *RAT		// input / runtime battery
  *prefix bt_

  *declare "RC bt_CkF();"
  *declare "virtual RC RunDup( const record* pSrc, int options=0);"
  *declare "RC bt_Init();"
  *declare "RC bt_DoHour( int stage);"
  *declare "float bt_CalcAdjLoad(const MTR& m) const;"
  *declare "float bt_ChgReqTDVPeakSave();"

  *i TI bt_meter;				// meter for system electricity production
  *f ENDUSECH bt_endUse			// end use of energy. defaults to "BT"
  *r NOYESCH bt_useUsrChg		// YES: user specifies charge request;
								// NO (default): calculate charge request via
								//               default strategy
  *h BATCTRLALGVC bt_controlAlg	// control algorithm choice
								//    _DEFAULT: per bt_chgReq
								//    _TDVPEAKSAVE: strive to reduce demand during peak TDV hours
  *r FLOAT_GEZ bt_maxCap		// maximum (usable) battery capacity in kWh
  *r FRAC bt_initSOE			// initial state of energy (0 <= SOE <= 1)
  *r FLOAT_GEZ bt_initCycles	// initial number of cycles on battery (>= 0)
  *h FRAC_GZ bt_chgEff			// battery efficiency while charging
  *h FRAC_GZ bt_dschgEff		// battery efficiency while discharging (Fraction)
  *h FLOAT_GEZ bt_maxChgPwr		// maximum allowable charging power (kW)
  *h FLOAT_GEZ bt_maxDschgPwr	// maximum discharge power (kW)
  *h *e FLOAT bt_chgReq			// battery charge request (kW) +=charge;-=discharge
  *h FRAC bt_soeBegIvl			// battery SOE at beginning of interval
  *h *e FLOAT bt_loadSeen		// the adjusted load seen by the battery for current hour (kW)
								//   = net power from bt_meter (including PV)
								//   0 if bt_meter not specified
  *h *p FRAC bt_soe				// battery state of energy (SOE) (0 <= SOE <= 1)
								// represents the end of interval SOE.
  *h FLOAT bt_soelh;			// battery state of energy (SOE) at end of prior hour
  *h *p FLOAT_GEZ bt_cycles		// accumulated battery cycles
  *h FLOAT_GEZ bt_cycleslh		// accumulated battery cycles, end of prior hour
  *h *p FLOAT_GEZ bt_energy		// current amount of energy in battery (kWh)
  *h FLOAT_GEZ bt_energylh		// amount of energy in battery (kWh)
								// at end of prior hour
*END		// BATTERY
//=============================================================================
RECORD GAIN "gain" *RAT   	// (zone internal) Gain input and runtime
   *prefix gn_
   *declare "virtual RC RunDup( const record* pSrc, int options=0);"
   *declare "RC gn_CkF( int options);"
   *declare "RC gn_DoHour() const;"

  // input.		.ownTI (base class) is zone subscript.
    *h POWER gnPower		// amount of gain (demand -- b4 reduction by gnDlFrPow), Btuh, hourly expression
							//   if linked to DHWSYS, units are Btuh/gal
    *i TI mtri  			// meter to which gain is charged
    *f ENDUSECH gnEndUse	// end use of energy: cooling, heating, receptacles, etc. reqd if gnMeter != none, else disallowed.
    *h FRAC gnFrLat			// fraction of gain which is latent (0 - 1, hourly expression)
    *h FRAC gnFrRad			// fraction of gain which is radiant, added 11-95
							// next 3 must sum to <= 1
    *h FRAC gnFrZn			//   fraction of gain going to zone (0 - 1, hourly expression)
    *h FRAC gnFrPl			//   fraction of gain going to plenum (0 - 1, hourly expression)
    *h FRAC gnFrRtn			//   fraction of gain going to return (0 - 1, hourly expression)
    *h FRAC gnDlFrPow		// fraction power on for daylighting, 0-1, default 1.0, hourly expression
	*i TI gn_dhwsysi		// controlling DHWSYS, 0 if none ()
							//   allows gains that track water use (re e.g. dishwashers, clotheswashers,)
    *i TI gn_dhwmtri		// controlling DHWMETER, 0 if none
							//   allows gains that track water use (re e.g. dishwashers, clotheswashers,)
    *i DHWEUXCH gn_dhwEndUse;	// with gn_dhwsysi, specifies controlling HW end use
								//   note includes _TOTAL and _UNKNOWN
*END			// GAIN
//=============================================================================
RECORD MTR_IVL_SUB "meter interval sub" *SUBSTRUCT  // substruct for one meter for one interval for entire building
 // use results

	// accum functions; see CAUTION below
 	*declare "void mtr_Accum( ENDUSECH eu, float v) { if (eu) (&clg)[ eu-1] += v; }"
	*declare "void mtr_Accum1( const MTR_IVL_SUB* mtrSub1, IVLCH ivl, int options=0);"
	*declare "double mtr_NetBldgLoad() const;"
	*declare "RC mtr_Validate( const MTR* mtr, IVLCH ivl) const;"

    *p float tot		// total of following specific end uses.  Code assumes precedes them.
						//  = allEU + bt + pv
    // Use by purpose (end use), energy used in Btu:
    // CAUTION: order of members MATCHES DTENDUSECH choices (cndtypes.def)
    //    for subscripting (in cnguts,cgresult.cpp) by end use -1:
    *e float clg		// space cooling.  code assumes 1st member.
    *e float htg		// space heating incl heat pump compressor
    *e float hpBU		// heat pump resistance heating (backup and defrost)
    *e float dhw		// domestic (service) hot water heating
						//   HPWH: compressor+misc energy
	*e float dhwBU		// domestic (service) hot water backup
						//   HPWH: resistance heating energy
						//   others: virtual backup to maintain ws_tUse
	*e float dhwMFL		// domestic (service) multi-family loop energy
						//   = DHWLOOP pump electricity + loss makeup
    *e float fanC		// fans - cooling and cooling ventilation
    *e float fanH		// fans - heating
    *e float fanV		// fans - IAQ ventilation
    *e float fan		// fans - other
    *e float aux		// HVAC auxiliaries and parasitics, not including fans
    *e float proc		// process energy
    *e float lit		// lighting
    *e float rcp		// receptacles
    *e float ext		// external -- outdoor lights, etc
    *e float refr		// refrigeration
    *e float dish		// dish washing
    *e float dry		// clothes drying
    *e float wash		// clothes washing
    *e float cook		// cooking
    *e float usr1		// user-defined end use 1
    *e float usr2		// user-defined end use 2
	*p float bt			// battery output (negative)
    *e float pv			// photovoltaic array output (negative)
	*e float allEU		// subtotal, clg .. usr2 (= load w/o bt and pv)
 // cost results. for now (11-93), must report with probes. Code (cnguts) may assume in this order, after uses.
    *p float cost		// accumulated  tot*rate
    *p float dmdCost	// largest dmd*dmdRate to month level, then accumulates (cnguts.cpp:mtrAccum)
 //demand results. related code: cnguts.cpp:mtrAccum. for now, must be reported with probes. rob 11-93.
    *p float dmd	 	// peak use in interval; hourly value same as .tot.
    *p SHOY  dmdShoy	// peak time as subhour of year, subhr unused: 4*(hr+24*jDay).
*END		// MTR_IVL_SUB
//=============================================================================
RECORD MTR "meter" *RAT 	// Meter input/runtime: energy use by meter, interval, endUse for entire building 1-92
 //inputs: rates
    *i float rate			// cost per Btu of use
    *i float dmdRate			// dmdCost per Btu of demand, for a month

	*declare "void mtr_HrInit();"

 //results: accumulated useage and cost for this meter (record subscript),
 //     for each interval (member here), usage by end use (substruct member):
 //CAUTION: ordered for subscripting by IVLCH-1.
    *y *e *nest MTR_IVL_SUB Y   	// run (aka year or annual) energy use
    *m *e *nest MTR_IVL_SUB M   	// month's use
    *d *e *nest MTR_IVL_SUB D   	// day's use
    *h *e *nest MTR_IVL_SUB H   	// hour's use
*END		// MTR
//=============================================================================
RECORD HDAY "holiday" *RAT	// describes one holiday for HdayiB/HdayB RAT. several default records are supplied.

    // valid input is: hDateTrue; or hDateTrue + hDateObs or hdOnMonday; or hdCase + hdDow + hdMon.
    *i DOY hdDateTrue		// true date of Holiday, 1-365
    *i DOY hdDateObs		// day holiday is observed, 1-365
    *i NOYESCH hdOnMonday	// YES if holiday that falls on weekend is observed on Monday
    // next three together specify rule for determining date of holiday on "1st Monday in Sep", "4th Thu in Nov", etc
    *i HDAYCASECH hdCase	// case: C_HOLICASECH_FIRST, _SECOND, _THIRD, _FOURTH, _LAST
    *i DOWCH hdDow		// day of week, Sun=1.  SUBTRACT 1 BEFORE USING.
    *i MONCH hdMon		// month 1-12
*END			// HDAY

//========================================================================================================
RECORD COIL "coil sub" *SUBSTRUCT	// COIL SUB RECORD
// Uses are: base class for COOLCOIL (airhandler cooling coil),
// 	         base class for HEATCOIL (terminal heat coil, base class for AHHEATCOIL (ah heating coil)) */

    *prefix co_

    *declare "RC setup( COILAPPCH app, record *r, SI coilFn, BOO rqd, BOO prohib);"	// cncult5.cpp

// COIL subrecord inputtable members

     // former .app member is now an argument to COIL::setup.

    *r COILTYCH  coilTy	// coil type choice according to application, as follows.  constant.
    			//  air handler cool coil: NONE (default), ELEC, DX, CHW, ...
    			//  air handler heat coil: NONE (default), ELEC, HW, GAS, OIL, AHP, ...
    			//     terminal heat coil: NONE (default if no local heat), ELEC (dflt if local heat), HW,  GAS,OIL??...
			// "ELEC COOL COIL" is a testing aid that cools with 100% efficiency & capacity at any temp.

    *h OFFAVAILVC sched	// AVAIL when coil available, OFF when disabled, hourly, default AVAIL.

    			// sensible cap'y: see COOLCOIL.capsRat.
    *s *e 			// *s *e for probes, cuz autoSize changes it. hourly for input purposes.
       POWER_NZ captRat 	// total rated cap'y (Btuh), RQD except AHP, ?CHW, hrly vbl for furnaces, const for DX coil.
    *f POWER captRat_As		// captRat determined by autoSizing, w less vbly for easier use in probes in main sim. 6-95.
    *f POWER captRat_AsNov	// raw captRat determined by autoSizing, before overSize added, for reports/probes. 7-95
    // cnausz.cpp code ASSUMES x, x_As, x_AsNov together for access thru one ptr. cuprobe.cpp's name search also requires together.
    *s *e POWER bCaptRat	// start-subHr captRat, to undo size increases not in use as converged at end subhr (ahhc,ahcc).

    *h FLOAT eirRat	// rated load energy input ratio===heat input ratio===input/output===1/efficiency for DX,GAS,OIL at least.
    			// hrly vbl for GAS,OIL; constant for DX, .   effRat: see HEATCOIL.

    *i TI mtri			// MTR to which to charge coil main energy use, if not through a plant.

    *h POWER_GEZ aux		// additional input energy used by auxiliary controls and devices.
    *i TI auxMtri		    // Meter for auxiliary energy

// coil setup time members
    //(none)

// coil runtime members
    *s *e POWER q		// average (not fan-on) output power level for subhour
    *s *e POWER qPr		// output at which coil's plant last computed, for call-flagging plant. set: cnhp.cpp. used: cncoil.cpp
    *s *e POWER p		// input power level this subhour, from plant or to charge to meter (*subhrDur!).
				        // p = input from plant tentative 9-92; implemented for HW coils.
    *s *e FRAC  co_plr  // current fan-on (or furnace-on) relative load (part load ratio)
    *s *e FRAC  co_plrAv  // current average relative load (plr * frFanOn)
    *s *e FLOAT eir		// energy input ratio: current input/output, fan on===average. Rob's addition, for probes, 5-92.
    *s *e POWER co_capMax  // maximum capacity this subhour, used to calculate tPossH/C.
    *s *e POWER pAux   	// aux power this subhour
    *s *e *hide BOO notDone	// coil model may set TRUE to tell iter4Fs to not stop iteration, 7-23-95
*END			// COIL
//=============================================================================
RECORD COOLCOIL "coolCoil sub" *SUBSTRUCT *BASECLASS COIL	/* COOLing COIL SUBRECORD
			Use is: air handler cool coil. */

    *declare "RC setup( COILAPPCH app, record *r, SI coilFn, BOO rqd, BOO prohib);"	// init'l input check/setup, cncult5.cpp
    *declare "RC reSetup( AH *ah);"						// ausz size change (captRat), app\cncoil.cpp
    *declare "RC setup(AH *ah);"					// set derived members common code, app\cncoil.cpp, 7-95
    *declare "RC chwSetup(AH *ah);"					// app\cncoil.cpp 7-95
    *declare "RC dxSetup(AH *ah);"					// app\cncoil.cpp

    // contains all members of base class COIL, plus the following:

// additional inputtable members for cooling coil
				// CAUTION: cncult5:COOLCOIL::setup code used to assume .cppapsRat was 1st derived class member 5-92.
				// total rated capacity: see COIL::captRat. Not used for CHW.
    *s *e POWER_NZ capsRat	// dx: sensible rated capacity <= CaptRat Btu/hr, const for input, *s cuz varies during autoSize.
    *f POWER capsRat_As		// AutoSized ditto for naming consistency. 6-95.
    *f POWER capsRat_AsNov	// Raw autoSized ditto, b4 oversize added, for report & probing. 7-95.
    *f FRAC_GZ SHRRat		// sensible heat ratio (caps/capt) for cooling coil
    // cnausz.cpp code ASSUMES x, x_As, x_AsNov together for access thru one ptr. cuprobe.cpp's name search also requires together.
    *f TEMP_GZ minTEvap		// dx: min evaporator (effective surface) temp (below which compressor cuts out), default 35F. (40F til 8-95)
    *f FLOAT_LZ k1		/* dx, chw: power of relative air flow to which outside number of transfer units is proportional.
				   Used in formula of form: ntuO = ntuoDs*(relCfm)^k1. Default dx: -.3, chw: -.2. Niles k1.*/

  // (dx,chw) coil rating (design) conditions. otta make names consistent: change vfR to vfDs?
    *f TEMP_GZ dsTDbCnd		// design (rating) (dx) condenser temp (outdoor temp pending water option), default = ARI = 95F.
    *f TEMP_GZ dsTDbEn		// design (rating) (dx,chw) entering air dry bulb temp, default = ARI = 80F.
    *f TEMP_GZ dsTWbEn		// design (rating) (dx) entering air wet bulb temp, default = ARI = 67F.  replaces Taylor's dsEAWB.
    *r AFLOW_GZ vfR		// rating (dx,chw) air flow (cfm). default: DX: per vfRperTon. CHW: sfan.vfDs.
    *r FLOAT vfRperTon		// DX default vfR per ton (12000 Btuh) of captRat. default: 400.

  // re dx cool coil compressor cycling and energy consumption
    *f FRAC  minUnldPlr   	// part load ratio (fraction of full load) at/above which "compressor unloading" is used. dfl 1.
    *f FRAC  minFsldPlr		// plr above which "false loading" is used (up to minUnldPlr). dfl minUnldPlr: no false loading.
           //eirMinUnldPlr	below: pydxEirUl(minUnldPlr) precomputed at setup.
    //*h FLOAT eirRAT		// rated load energy input ratio: is a COIL member

  // inputtable coefficients for dx polynomial correcting fcns. Defaulted to DOE2 "PTAC" values (or as changed) by cncult5 code.
  // enter comma-separated list of coefficients in order:
  //  PYCUBIC:  cubic(x):         constant, coeff x, coeff x^2, coeff x^3.
  //  PYBIQUAD: biquadratic(x,y): constant, coeff x, coeff x^2, coeff y, coeff y^2, coeff x*y.
					// corrects...
    *f *nest PYBIQUAD  pydxCaptT	//  dx capt for (off-rated) tWbEn and tDbCnd (entering wetBulb, condenser dryBulb temps)
    *f *nest PYCUBIC   pydxCaptF	//  dx capt (off-rated) relative flow; arg is plrVf
    *f FLOAT pydxCaptFLim		//   upper limit for value of pydxCaptF, 8-28-95
    *f *nest PYBIQUAD  pydxEirT 	//  dx energy input for tWbEn and tDbCnd
    *f *nest PYCUBIC   pydxEirUl	//  dx energy in for part load in dx compr-unloading range (minUnldPlr <= plr <= 1).
    					//  (Adjusts full-load input (eirRat*capt): I claim eir in name is misnomer, rob 5-92).
	    				//     note for minFsldPlr < plr < minUnldPlr, input remains at minUnldPlr's;
    					//          for plr <= minUnldPlr, input does straight line to 0.

  // inputtable COOLCOIL members for CHW coil, 10-92. all const.
    *i TI cpi				// subscript of COOLPLANT serving CHW coil, RQD for chw.
    *f H2OFLOW_GZ gpmDs  		// design (i.e. maximum) chilled water flow, gpm, RQD for chw. Niles mwd[g].
    *f FLOAT_GZ ntuoDs   		// outside number of transfer units at design air flow (vfR), default 2. Niles ntuOd.
    *f FLOAT_GZ ntuiDs   		// inside number of transfer units at design water flow (gpmDs), default 2. Niles ntuId.
    // also used, above: vfR, dsTDbEn, k1.  Not used for chw: captRat, capsRat, .
    // note Niles k2 not used as not simulating flow/exit temp.

// COOLCOIL setup time: dx:
    *r DBL wsatMinTEvap			// hum ratio of saturated air at minTEvap (minimum evaporator temp)
    *r DBL hsatMinTEvap			// enthalpy of saturated air at minTEvap
    *r DBL efecOR			// (outside) effectiveness at rated conditions (in record for probing only)
    *r DBL ntuR				// number of trasfer units (like time constants) at rated conditions
    *r DBL eirMinUnldPlr		// pydxEirUl(minUnldPlr): precomputed dx input correction for falseLoading; prorate for cycling.
 //dx and chw:
    *r DBL menR				/* chw/dx coil rating air flow (lb/hr) (for chw, Niles 'mad')
					   vfR * air density @ dsTDbEn, @ sea level 1-95 */
 //chw setup time:
    *r TI nxAh4cp			// 0 or subscr of next AH with CHW coil served by same COOLPLANT. 1st is COOLPLANT.ah1.
    *r DBL /*MFLOW*/ mwDs		// design (max) chilled water flow: .gpmDs converted to lb/hr.

// COOLCOIL runtime members
    *s *e BOO wantQflag			// nz if cooling desired (texWant < ten) regardless of sched, etc. doCoils-->cpEstimate.
 //chw:
    *s *e DBL /*TEMP*/  tewd		// chw internal: full-water-flow effective temp: prior value used next time called.
    *s *e DBL /*POWER*/ chwQ		// heat taken from primary loop water, negative: chw load, to COOLPLANT (same as ahcc.q).
    *s *e DBL /*TEMP*/  tr		// water return temp to coolplant
    *s *e TEMP cpTsPr    		// cp ts for which coil last computed, re compute-flagging coil from plant
    *s *e TEMP trPr			// coil tr at last coil compute, re call-flagging cp from coil model
    *s *e BOO fullLoadWet		/* true if CHW coil wet @ full load,
    					   with hysterisis cuz CHW coil model has output discontinuity 10-92.*/
 //dx mainly...
    *s *e DBL frCprOn			// dx: output to crankcase heater (via coilsEndSubhr): fraction of time compressor on.
    //Move to COIL or AH if additional applicabilities found:
    *s *e DBL /*TEMP*/ tWbEn    	// dx coil entering air wetBulb temp: doDxCoil to coilsEndSubhr.
    *s *e DBL /*ENTHALPY*/ hen		// dx,chw coil entering air enthalpy / is member for probeing
    *s *e DBL /*TEMP*/ tDbCnd		// dx system condenser temp: Top.tDbO or (future) water temp)
 //dx... following are members for probe-ability where local variable might [would] otherwise suffice:
    //review for unused ones and delete:
    *s *e DBL /*FRAC*/  efecO     	// current (dx coil) effectiveness
    *s *e DBL /*POWER*/ capt		// current (dx or any cool coil) total capacity
    *s *e DBL /*POWER*/ caps		// current (dx coil) sensible capacity
    *s *e DBL /*FRAC*/  plrVf		// current (dx coil) fan-on relative flow (part fan load ratio, cfm, Niles' plrCfm).
    *s *e DBL /*FRAC*/  plrSens 	// current (dx coil) fan-on relative sensible load (part load ratio)
    *s *e DBL /*POWER*/ qs		// current (dx coil) sensible load
    *s *e DBL /*POWER*/ ql		// current (dx coil) latent load
 //general
    //*s *e POWER q		COIL member above: current total load: q = qs + ql
    //*s *e POWER p		COIL member above: current (electrical or ?plant) input power
    //*s *e FRAC  plr		COIL member above: current fan-on relative load (part load ratio)
    //*s *e FLOAT eir		COIL member above: current (dx,elec) energy input ratio: eir = p / q
    //*s *e POWER qPr		COIL member; currently 10-92 not used for coolcoil
    //*s *e TEMP  tsPr		plant supply temp at which coil last computed, for compute-flagging coil: COIL member
#if 1 // 10-96
    *s *e ENERGY xLGain		// condensation heat added to air (const enthalpy) to fix supersaturated wen, this subhr.
    *s *e ENERGY xLGainYr	// .. cumulative over run, for message at end run.
    *s *e LI nSubhrsLX		// number of subhours in which supersaturated entering air fixed
#endif
 //flags for messages at end autoSize (or run, future?)
    *s *e BOO minTLtd		// output limited by minTEvap b4 reaching ahTsMn (DX, 7-95)
    *s *e BOO cfm2Few		// too little flow to permit sizing coil to meet load at min temp (DX, 7-95)
*END			// COOLCOIL
//=============================================================================
RECORD HEATCOIL "heatCoil sub" *SUBSTRUCT *BASECLASS COIL	/* HEATing COIL SUBRECORD
			Use is: terminal coil, base class for AHHEATCOIL (next) */

    *declare "RC setup( COILAPPCH app, record *r, SI coilFn, BOO rqd, BOO prohib, BOO isAhh=FALSE);"

    // has all members of base class COIL, and...
    // heat coil additional input members
	//  CAUTION: HEATCOIL::setup code used to assume .effRat was 1st derived class member, 7-92.
   // for GAS or OIL furnace "coil" in ah
    *f FRAC_GZ effRat		// efficiency @ rated load: alternate eir input, converted into eirRat in setup.
    *f *nest PYCUBIC pyEi	/* cubic polynomial coefficients to correct full-load energy input for part load ratio
    				   for GAS or OIL heat coil.  Default (per DOE2): .01861, 1.094209, -.112819, 0. */
    *h FRAC stackEffect  	/* fraction of unused capacity that must be used (increasing plr) to make up for increased
    				   infiltration due to hot stack when (indoor) furnace runs but not continuously.  Default 0.
    				   Expect function of Top.tDbO. */
   // for HW coil
    *i TI hpi			// subscript of HEATPLANT serving HW coil
// heat coil setup time members
   //for HW coil
    *r TI nxTu4hp		// TuB subscr of next TU with HW coil on same HEATPLANT. 1st is HEATPLANT.tu1.
    *r TI nxAh4hp		// AhB subscr of next AH with HW coil on same HEATPLANT. 1st is HEATPLANT.ah1.
// heat coil runtime members
   //for GAS or OIL furnace "coil" in ah
    *s *e POWER flueLoss	// part-load flue loss this subhour, GAS and OIL only
   //for HW or AHP coil
    *s *e POWER qWant		// HW:  desired output===input, doHWCoil to hpCompute, used in determining capF.
    				        // AHP: desired output, doAhpHeatCoil to doAhpHeat
    //*s *e POWER q		    // current output power: is a COIL member.
    //*s *e POWER qPr		// output at which coil's plant last computed, for change-flagged plant: COIL member
*END		// HEATCOIL
//=============================================================================
RECORD AHHEATCOIL "ahHeatCoil sub" *SUBSTRUCT *BASECLASS HEATCOIL	/* AH HEATing COIL SUBRECORD with AHP members
										   Use is: air handler heat coil. */
    *declare "RC setup( COILAPPCH app, record *r, SI coilFn, BOO rqd, BOO prohib);"	// init'l input check/setup, cncult5.cpp
    *declare "RC reSetup( AH *ah);"						// autosize cap'y change (captRat), app\cncoil.cpp
    *declare "RC setup( AH *ah);"						// derived mbrs setup common code, app\cncoil.cpp
    *declare "DBL cprCapCon( FLOAT tout);"					// app\cncoil.cpp
    *declare "void doAhpHeat( BOO &coilLimited, AH *ah);"     			// app\cncoil.cpp

    // has all members of base class HEATCOIL and its base class COIL, and additional members for AHP's.

//AHHEATCOIL input members for AHP

  //AHP steady state heating capacity
    *f POWER_GZ cap17		// ARI steady state rated cap @ 17 out, 70 indoor (return) air, Btuh, RQD for AHP, Niles pCapSs17.
    *r FRAC_GZ capRat1747	// cap17 / cap47 ratio (re autosizing)
    *r FLOAT_GZ capRat9547   // total net cap95 (cooling) / net cap47 (heating)
                            //   re consistent htg/clg size iff both autosized
                            //   (else inconsistency ignored)
                            //   default=correlation per A. Conant
                            //   see ashpCap95FromCap47() and ashpCap47FromCap95()
    *r POWER_GZ cap35		/* ARI steady state rated cap @ 35F outdoor, Btuh, default per fd35Df, Niles pCapSs35.
				   Reflects frost buildup and defrost degradation but no cycling. Unlikely to be known;
				   defaults to fd35Df (next) times a value linearly interpolated between cap17 & cap47.
				   If given, error if greater than value linearly interpolated between cap17 & cap47. */
    *f FRAC fd35Df    		/* Default frost/defrost degradation factor at 35 F, default .85, Niles fdf35dft.
				   Reduction of output at unchanged input, due to defrosting and due to frost on outdoor coil.
				   Used in determining default value for cap35 (preceding); not used if cap35 is given. */
    *f FRAC capIa    		/* Capacity correction factor for indoor (return) air temperature, default .004, Niles iacCap.
				   Expressed as a fraction reduction in capacity per degree above 70F. */
    *f FLOAT_GEZ capSupHeat    	// Output of supplemental coil, Btu/h.
    *h FLOAT_GZ effSupHeat		// Supplemental heat efficiency
    *i TI supHeatMtri			// meter for supplemental heat energy use
    *declare "MTR* pMtrSupHeat;" // runtime pointer to supplemental heat meter
  //inputs for AHP frost builtup, defrosting and their effect on capacity
    *f TEMP tFrMn    		// lowest  temp for frost buildup & defrost effects, default 17F, Niles tFrstMn.
    *f TEMP tFrMx    		// highest temp for frost buildup & defrost effects, default 47F, Niles tFrstMx.
    *f TEMP tFrPk    		/* temp for peak frost buildup & defrost effects, default 42F, Niles tFrstPk.
				   Frost buildup & defrost capacity reduction comes from frost buildup on outdoor coil,
				   plus time spent doing reverse cycle defrosting (heating outdoor coil: cools indoor coil).
				   Error if not tFrMn < tFrPk < tFrMx. */
    *f FRAC dfrFMn   		// min frac time in reverse cycle cooling, default .0222 (2/90 min), Niles tmFrcDefMn.
    *f FRAC dfrFMx   		/* max frac time in reverse cycle cooling, default .0889 (8/90 min), Niles tmFrcDefMx.
				   Error if dfrFMx <= dfrFMn.
				   Fraction of time defrosting is min is at/below tFrMn and at (not above) tFrMx.
				   Max used at tFrPk. Linear interp between. 0 time defrosting above tfrMx.
				   During defrosting time, cold output (see dfrCap) not heat is delivered to load,
				   addl heater (see dfrRh) is operated. */
    *r POWER_NZ dfrCap   	/* cooling capacity (to ah supply air) during defrosting, default 2 * cap17, Niles pDefCool.
				   Should include any effects of switchover transient; program will compute lost heating cap.
				   Negative internally. (future) should check or default somehow vs ahp cooling inputs if given? */
  //  *f KW_GZ dfrRh    		/* input (& output) power of addl reheat coil run during defrost, default 5kW, Niles pDefRh.
  //  				   entered as kW, converted to Btuh internally by units stuff. */
  //AHHEATCOIL inputs for AHP low temperature cutout
    *f TEMP tOff     		// low temp cutout setpoint, default 5 F, Niles tOff.
    *f TEMP tOn      		// low temp cut-back-in setpoint, default 12 F, Niles tOn. tOn==tOff ok, error if <.
  //AHHEATCOIL AHP (air source heat pump) heating power input inputs
    *f FLOAT_GZ COP17     		// COP input @ 17 outdoor, 70 indoor (return). RQD for AHP. Niles pInSs17.
    *f FLOAT_GZ COP47     		// COP input @ 47 outdoor, 70 indoor (return). RQD for AHP. Niles pInSs47.
    *f FRAC inIa     		/* indoor (return) air temp power input correction factor, default .004, Niles iacIn.
    				   Fraction decrease in steady-state input per degree above 70F. */
    *f FRAC cd       		/* ARI cycling degradation coefficient, default .25, Niles cd.
    				   Ratio of fraction drop in system COP (incl cch, defrost) to fraction drop in capacity
    				   when cycling, from steady-state values, in ARI 47 F cycling performance tests.
    				   A value of .25 means that if the heat pump is cycled to drop its output to
    				   20% of full capacity (i.e. by the fraction .8), its COP will drop by .8 * .25 = .2. */
    // meter: COIL.mtri is used; compr input power to category htg, and suppl heater input to catagory hp.
  //AHP non-inputtable contants
    *declare "#define tmCycOn  (.1)		// time on  (hours) in ARI cycling performance test"	// #define in rccn.h
    *declare "#define tmCycOff (.4)		// time off (hours) in ARI cycling performance test"	// #define in rccn.h
    *declare "#define tmCycPer (tmCycOn + tmCycOff)	// total cycle time of ARI cycling test"	// ditto

//AHHEATCOIL AHP setup time members
    *r KW_GZ in17     		// steady state power @ 17 outdoor, 70 indoor (return). RQD for AHP. Niles pInSs17.
    *r KW_GZ in47     		/* steady state power @ 47 outdoor, 70 indoor (return). RQD for AHP. Niles pInSs47.
				   These reflect full power, no cycling, include compr & crankcase heater.
				   Program removes cch input energy. Externally kW, internally Btuh. */
    *r POWER in17c		// compressor input power @ 17 degrees out, 70 in: in17 with cch power removed. Niles pInSs17.
    *r POWER in47c		// ditto 47 degrees.  Niles pInSs47.
    *r FLOAT cdm		// modified cd: cycling degradation coefficient adjusted to remove cch. Niles cdm.

//AHHEATCOIL AHP runtime input members
    *s *e TEMP  tIa		// indoor air temp: copy of tmix or whatever ah variable is chosen
    //qWant			desired output: HEATCOIL member used.
    *s *e FLOAT qSupLim 	/* caller-set heat output limit for when suppl heat in use: kludge when fan cycling
    				   to prevent raising ts and dropping fanFrOn to where suppl heat cuts out --> ah oscillation */
    *s *e DBL frFanOn		// fraction of time fan runs, 1.0 if not cycling, copy of AH.frFanOn.
//AHHEATCOIL AHP runtime internal members
    *s *e BOO  loTLockout	// TRUE if compressor locked out due to low outdoor temp (see tOff, tOn)
    *s *e BOO supOn		    // TRUE if supplementary heat enabled (frFanOn is ~1.0, with hysterisis to keep ah stable).
    *s *e POWER capCon		// continuous cpr capac incl frost/defrost @ actual indoor temp, excl def & reg rh. Niles pCapMx.
    *s *e POWER qDfrhCon  	// continuous avg heat ouput to defrost heater @ outdoor temp (not cycling). Niles pDefRhMx.
    //made local, only set in cases needed:
    // *s *e FRAC hlf		// heating load factor: hp compr heat used/capCon. Excludes reg & dfr rh. frCprOn may be larger.
    // *s *e FRAC plf		// part load factor, by which COP falls due to cycling.
    // *s *e FRAC frTmDfr 	// fraction of time defrosting, this subhour. Niles tmFrDef.
//AHHEATCOIL AHP runtime output members
    //q: coil member: heat delivered, by heat pump incl suppl heaters (qSh). Niles pDel.
    *s *e FRAC  frCprOn		// fraction of time compressor runs, this subhour. May be used by cch code. Niles tmFrRun.
    *s *e POWER pCpr		// power input to compressor (Niles pInComp): copy to .p in coilsEndSubhr.
    *s *e POWER qSh		// output of reg (not defrost) supplemental heaters. Included in q of coil.
    *s *e POWER pSh		// input of reg & dfr supplemental resistance heaters.
    //crankcase heater input power: see CCH.p. Niles pCch.
*END		// AHHEATCOIL

//=============================================================================
RECORD CCH "cch sub" *SUBSTRUCT	// Crankcase Heater subRecord for AIRHANDLER

    *declare "RC setup( AH *ah, SI cchFn);"		// cncult.cpp
    *declare "void endSubhr();"				// cncoil.cpp

//CCH inputs
    *r CCHCM cchCM	/* crankcase heater presence and control method choice. Niles cchCtlMtd.
			   Default: PTC_CLO if ahhc.coilTy is AHP, else NONE.
			NONE 	  no crankcase heater present
			CONSTANT  crankcase heater input always pMx.
			PTC	  control per oil temp when compr doesn't run (see tMx,tMn,dt); pMn if runs at all in subhour.
			TSTAT	  control per outdoor temp when compr is off; 0 if compr runs at all in subhour. See tOn,tOff.
			CONSTANT_CLO,PTC_CLO: same as corres choices above except 0 input during fraction of time
				  compr is on. TSTAT_CLO omitted: moot. */
   //for all cchCM's:
    *f KW_GZ pMx	// Crankcase resistance heater input power; maximum power if cchCM is PTC or PTC_CLO.
			// default .4kW. entered in kW, internally in Btuh.  Niles pCchMx.
   //for PTC & PTC_CLO:
    *f KW_GZ pMn	// min cch input power. default .04kW. entered in kW, internally in Btuh.  Niles pCchMn.
    *f TEMP tMx   	// low temp (max power) setpoint...                            Default 0 F.   Niles tCchPtcMx.
    *f TEMP tMn   	/* high temp (min power) setpoint for cchCM = PTC or PTC_CLO.  Default 150 F. Niles tCchPtcMn.
			   For PTC or PTC_CLO, when compr does not run, cch input is pMx if oil temp below tMx, pMn above tMn,
			   proportional between. If compr runs at all in subhr, input is pMn. See dt, next.
			   tMn must be >= tMn. == allowed. */
    *f TEMPDIFF dt	/* how much warmer than outdoor temp crankcase oil is assumed to be, in subhrs when compr does not run.
     			   Default 20 F. Niles tCchDelta. */
   //for cchCM = TSTAT:
    *f TEMP tOn		// outdoor temp cch turn-on setpoint ...                                 Default 72 F. Niles tCchTstOn.
    *r TEMP tOff	/* outdoor temp cch turn-off setpoint for hours when compr does not run. Default tOn.  Niles tCchTstOff.
    			   Give tOff > tOn to simulate thermostat differential. == allowed. < yeilds error message.
			   If compr runs at all in subhour, crankcase heater is off for entire subhour. */
   //for all cchCM's:
    *i TI mtri		// subscript of meter to which cch energy use is to be recorded, default none.

//CCH setup time
    //Rob used p not Niles' e for next 2, 10-92:
     //*r ENERGY e47Off	// energy input during off part of one cycle of ARI 47 degree cycling test, kWh. Niles eCchOffCyc47.
     //*r ENERGY e47On	// .. on ..  Niles eCchOnCyc47.
    *r POWER p47Off	// power input during off part of one cycle of ARI 47 degree cycling test, kWh.
    //*r POWER p47On	// .. on ..  restore if need found.
    *r POWER p17	// power input to crankcase heater in ARI 17 degree continuous operation test, kW. Niles pCch17.
    *r POWER p47	/* ditto 47 degree test. Niles pCch47. p17 and p47 always the same; p47 may be used in code as
    			   crankcase heater input in any test. ??clarify while coding. */

//CCH runtime
    *s *e FRAC frCprOn	/* fraction of time compressor ran this subhour, input to power determination.
			   copy of ahhc.frCprOn for AHP, frCOn * frFanOn for DX, etc. */
    *s *e BOO tState	// thermostat state for cchCM = TSTAT: must remember to implement hysteresis
    *s *e POWER p	// cch input===output power this subhour

*END		// CCH

//=============================================================================
RECORD AH "airHandler" *RAT
// Each AH record describes one AIR HANDLER (Niles' terminology; formerly a "generic subsystem"), including
// supply and return fans, outside air control, economizer, heat and cool coils, supply temperature regulation,
//         and (probably deferred) warmup, optimum start, and setback/setup control.
// Member names begin with ah-, py-, sfan-, rfan-, and oa- (or have ah_ prefix)
    *prefix ah_

    *declare "RC setup();"
    *declare "void fazInit( int isAusz);"
    *declare "RC rddInit( int isAusz);"
    *declare "RC ah_pass1AtoB();"
    *declare "RC ah_begP1b();"
    *declare "void rddiInit();"
    *declare "RC ah_SetupSizes();"
    *declare "void ah_p2Init();"
    *declare "void endP2Dsd();"
    *declare "RC ah_p2EndTest();"
    *declare "RC ah_endAutosize();"
    *declare "void ah_auszFinal();"
    *declare "RC begSubhr();"
    *declare "RC endSubhr();"
    *declare "RC ah_AfterSubhr();"
    *declare "RC begHour();"
    *declare "RC ahEstimate();"
    *declare "RC ahCompute();"
    *declare "BOO iter4Fs( BOO &cvgFail);"
    *declare "void pute4Fs();"
    *declare "void setFrFanOn( DBL _leakCOn);"
    *declare "BOO incrFanF();"
    *declare "BOO decrFanF();"
    *declare "BOO fanXtrap( SI whichway);"
    *declare "BOO ceeClip( BOO canClip);"
    *declare "BOO converger();"
    *declare "BOO binClip();"
    *declare "void getTsXtrapBounds(DBL d);"
    *declare "BOO humXtrap();"
    *declare "BOO humXtrap2();"
    *declare "BOO humXtrapI( DBL r, char x);"
    *declare "void doOa();"
    *declare "AIRFLOW ah_doHR();"
    *declare "void doEco();"
    *declare "DBL getTsMnFo( BOO outsideCall);"
    *declare "DBL getTsMxFo( BOO outsideCall);"
    *declare "DBL tsFo( float approach,  BOO outsideCall);"
    //only 1 of next 2 used... both decls ok? 6-97.
     *declare "DBL tsfo( DBL _tr, DBL _cr);"
     *declare "BOO tsPoss( DBL _tr, DBL _wr, DBL _cr, int want, DBL & _ts);"
    *declare "BOO resizeFansIf( float _cMx, float vfDsWas);"
    *declare "RC ah_SetMode();"
    *declare "BOO setTsSp1( BOO est, DBL &tsOut);"
    *declare "void wzczSp( BOO est, BOO cooling, BOO maxIt, DBL llim, DBL ulim, TU *ctu, DBL &tTsSp, FLOAT &cznC);"
    *declare "void zRat();"
    *declare "void antRatTs();"
    *declare "void puteRa();"
    *declare "BOO flagTusIf();"
    *declare "void flagChanges();"
    *declare "void upCouple( DBL _ts, DBL tsWas, DBL _ws, DBL wsWas);"
    *declare "void upPriors();"
    *declare "void ahVshNLims( DBL _ts, DBL &cIncr, DBL &cDecr);"
    *declare "void flagTus();"
    *declare "BOO nxTu(TU *&tu);"
    *declare "BOO nxZhx( ZHX *&x);"
    *declare "BOO nxZn( ZNR *&zp);"
    *declare "BOO nxTsCzn( ZNR *&z);"
    *declare "BOO resizeHeatCoilIf( float capt, float captWas);"
    *declare "BOO resizeCoolCoilIf( float capt, float captWas);"
    *declare "BOO estCoils( DBL _ten, DBL _wen, DBL _cen, DBL _frFanOn, BOO _coilLockout, int cooling, DBL &_tex, DBL &_wex);"
    *declare "BOO doCoils( DBL texWant, DBL &lLim, DBL &uLim);"
    *declare "float coolCapThing( float captWant);"
    *declare "BOO doHWCoil( DBL texWant, DBL &llLim, DBL &uLim );"
    *declare "BOO doElecHeatCoil( DBL texWant, DBL &llLim, DBL &uLim );"
    *declare "BOO doGasOrOilFurn( DBL texWant, DBL &llLim, DBL &uLim );"
    *declare "BOO doAhpHeatCoil(  DBL texWant, DBL &llLim, DBL &uLim );"
    *declare "float heatCapThing( float captWant);"
    *declare "BOO doElecCoolCoil( DBL texWant1, DBL texWant, DBL &llLim, DBL &uLim );"
    *declare "BOO doChwCoil( DBL texWant1, DBL texWant, DBL &lLim, DBL &uLim);"
    *declare "BOO doDxCoil( DBL texWant1, DBL texWant, DBL &llLim, DBL &uLim );"
    *declare "void coilsEndSubhr();"


// AUTOSIZING members for air handler 6-95. Later distribute below?

    //input -- in addition to AUTOSIZE ahhcCaptRat, ahccCaptRat, sfanVfDs, rfanVfDs: these set FsAS field status bit.
    *h TEMP ahTsDsH		// heating design supply temperature, for sizing coil vs fan. defaulted hourly to ahTsMx.
    *h TEMP ahTsDsC		// cooling design supply temperature, for sizing coil vs fan. defaulted hourly to ahTsMn.
    *f FLOAT_GZ ah_fxCapH  	// capacity factor for autoSized heat coils (default 1.1 = 10% oversized)
    *f FLOAT_GZ ah_fxCapC  	// capacity factor for autoSized cool coils (default 1.1 = 10% oversized)
    *f FLOAT_GZ ah_fxVfFan  // volume flow factor for autoSized fan(s) (default 1.1 = 10% oversized)
    //setup
    *r BOO asRfan		// TRUE to autoSize return/relief fan (to same capacity as supply fan)
    *r BOO asFlow		/* true if autoSizing supply fan and/or flow of any connected terminal:
				   change to const supply temp model in part A. */
    //runtime
    *nest AUSZ hcAs		// autoSizing working data members re heat coil
    *nest AUSZ ccAs		//  .. re cool coil (total only. sens cap: see .SHRRat. sens load: see .qcs)
    *nest AUSZ fanAs	//  .. re fan(s) -- autosized rfan slaves to sfan.
    // values saved at entry to hvacIterSubhr for conditional backtracking during autoSizing.
     *s *e AFLOW_GEZ bVfDs	// sfan.vfDs. see COIL::bCaptRat for ahhc and ahcc.
    // results: see ahhc.captRat_As, ahcc.captRat_As, ahcc.capsRat_As, sfan.vfDs_As, rfan.vfDs_As, ditto _AsNov's.
    // values at time of cool coil peak load in main run or des day, for loads reports and input to -PkAs mbrs below
      *s *e POWER qcPkS 	// sensible load @ peak total load
      *s *e POWER qcPkL 	// latent cool coil load ditto
      *s *e SI qcPkH		// hour 1-24 of peak total cool coil load
      *s *e SI qcPkD		// day of month 1-31 of peak load, not used for autoSizing
      *s *e SI qcPkM		// month 1-12 of peak load, or 0 for Heat design month
      *s *e TEMP  qcPkTDbO	// outdoor temp at time of peak load
      *s *e HUMRAT qcPkWO 	// outdoor hum rat at time of peak load. w's must follow t's for reports.
      *s *e TEMP   qcPkTen	// entering air temp
      *s *e HUMRAT qcPkWen	//  hum rat
      *s *e TEMP   qcPkTex	// exiting air temp (b4 remix w bypass air)
      *s *e HUMRAT qcPkWex	//  hum rat (b4 remix w bypass air)
    // above for autoSize pass 2 cvg'd des day with largest peak cool coil load, saved for size rpts in input rec thru main run.
      *s *e POWER qcPkSAs	// sensible load @ peak total load
      *s *e POWER qcPkLAs	// latent cool coil load ditto
      *s *e SI qcPkHAs		// hour 1-24 of peak total cool coil load
      *s *e SI qcPkDAs		// day of month 1-31 of peak load, not used for autoSizing
      *s *e SI qcPkMAs		// month 1-12 of peak load, or 0 for Heat design month
      *s *e TEMP  qcPkTDbOAs	// outdoor temp at time of peak load
      *s *e HUMRAT qcPkWOAs	// outdoor hum rat at time of peak load. w's must follow t's for reports.
      *s *e TEMP   qcPkTenAs	// entering air temp
      *s *e HUMRAT qcPkWenAs	//  hum rat
      *s *e TEMP   qcPkTexAs	// exiting air temp (b4 remix w bypass air)
      *s *e HUMRAT qcPkWexAs 	//  hum rat (b4 remix w bypass air)

// SUPPLY AIR TEMP CONTROLLER user inputs for air handler

    *h TEMP_TSCM ahTsSp	// supply temperature setpoint or control method: RA, WZ, CZ, ZN, ZN2, or number, hourly,
  			//     RQD if ah has economizer or coil, else disallowed.
			// NUMBER: a number or numeric expression can express functions of time, outdoor temp, etc.
			// RA: controlled by return air temp.  raMn, raMx, tsMn, tsMx must be input.
    			// WZ/CZ: Warmest Zone/Coolest Zone: set ts to meet load of control zone
    			//     requiring the lowest/highest ts with its VAV damper 90-100% open.
			// ZN: choose WZ or CZ per whether terminal ahCtu's t'stat is calling for heat or cold, else ah off.
			//     defaults ahFanCycles YES. intended for single zone systems, RESYS, PTAC.
			// ZN2: choose WZ or CZ per whether terminal ahCtu's t'stat is calling for heat or cold, else fan only.
			//     intended for single zone const vol systems, PSZ.
			//  ZN, ZN2 are the ONLY methods where demand determines whether zones are being heated or cooled;
			//  in other cases, if system can heat or cool zone, supply temp must be scheduled, reset by
			//  outside temp, etc.  Optional separate setpoint inputs for setback/setup operation are below.

    *h NOYESVC ahFanCycles	// YES if fan (and coil) cycles with zone thermostat; hourly;
    				// default: YES when ahTsSp==ZN (not ZN2), else NO (defaulted dynamicaly in AH::begHour).
    				// see BOO fcc for runtime testing.  6-15-92.

   	// min and max supply temps, always allowed, RQD when ahTsSp==RA (runtime ck), or (5-95) when ahTsSP==ZN && ahFanCyles==YES.
    *h TEMP_GZ ahTsMn 		// hourly, default 40.
    *h TEMP_GZ ahTsMx 		// hourly, default 250.

   	// RQD when ahTsSp is RA, else ignored;
     *h TEMP_GZ ahTsRaMn	// return air temp at which tsSp is at ahTsMx. hourly.
     *h TEMP_GZ ahTsRaMx	//  .. ahTsMn. hourly.  If return air moves outside this range, tsSp does not change further.

    *r TI ahCtu			// terminal for determining whether to heat or cool under ZN, ZN2 tsu sp control.
				// defaults to served terminal if only one, else RQD when ahTsSp is ZN or ZN2.

    *f *array 16 TI ahWzCzns	// zone names monitored for warmest zone and coolest zone Ts Sp control, respectively.
    *f *array 16 TI ahCzCzns	// Each input may be ALL, ALL_BUT, and/or zone names, comma-separated.  default ALL.
				// internally: TI_ALL; or TI_ALLBUT + zone subsrs; or zone subscrs; max 15, 0-terminated.

    // Optional supply temp setpoint control variables for SETBACK/WARMUP HEATING.
    // descriptions above apply; each defaults to corresponding variable above (but beware of heating with cooling sp!).
    // (can somebody suggest a simple way to 'encapsulate' a setpoint description
    //  in a single variable, function call, or record reference?)
    //*h TEMP_TSCM ahsbTsSp
    //*h TEMP_GZ ahsbTsMn   			poss future
    //*h TEMP_GZ ahsbTsMx
    //*h TEMP_GZ ahsbTsRaMn
    //*h TEMP_GZ ahsbTsRaMx
    //control zones: regular ones (above) used insofar as pertinent

    // Optional supply temp setpoint control variables for SETUP COOLING, likewise
    //		(can somebody suggest a simple way to 'encapsulate' a setpoint description
    //		in a single variable, function call, or record reference?)
    //*h TEMP_TSCM ahsuTsSp
    //*h TEMP_GZ ahsuTsMn   			poss future
    //*h TEMP_GZ ahsuTsMx
    //*h TEMP_GZ ahsuTsRaMn
    //*h TEMP_GZ ahsuTsRaMx

// SETBACK/SETUP/WARMUP/OPTIMUM START INPUTS for air handler.
//    *h TEMP_GZ ahsbTH	// setback zones setpoint, 1 to 80 F, hourly, omit for no setback operation.
//    *h TEMP_GZ ahsuTC	// setup zones setpoint, 1 to 100 F, hourly, omit for no setup operation.
//			// Be sure to also specify an appropriate supply temp setpoints.
//			// System runs for subhour if any monitored zone already is (or would otherwise go ???)
//			//  under/over sp ??? problems remain re modelling entire system CYCLING.
//    *h TEMP_GZ ahosTH  	// optimum start target temp for coldest zone: used to estimate when to start.
//    *f *array 16 TI ahssCzns	// zone names monitored for setback/setup, optimum start.
//    				// input may be up to 15 zone names (not necessarily on same system), comma separated,
//    				// or ALL, or ALL_BUT and up to 14 zone names.  Default ALL.
//    *f OSCTLCH ahssCtrl	// what setback/setup and warmup/os control: choice of LOCAL_HEAT, CENTRAL_FAN, BOTH (default).
//    				// For central fan to be useful, central coil must be scheduled AVAIL.
//    				// LOCAL_HEAT (Taylor ZONE HEAT) means turn on the heaters in the terminals.

// OUTSIDE AIR and ECONOMIZER INPUTS for air handler.

    // minimun oa flow is regulated to a given cfm (VOLUME) or a fraction of the current flow (FRACTION),
    //  in either case multiplied by a schedulable fraction (eg to shut off vent air during warmup).
    // if oaMnCm is VOL:   min_oa_flow = oaMnFrac * oaVfDsMn
    //              FRAC:  min_oa_flow = oaMnFrac * oaVfDsMn * curr_flow / supply_fan_design_cap
    *f OAMNCH oaMnCm	   	// min OA flow Control Method, choice of VOL or FRAC, default VOL, constant.

    *h FRAC  oaMnFrac		// fraction 0-1 of minimum OA to use now, hourly, default 1.0. eg to shut off oa during warmup.

    *r AFLOW_GEZ oaVfDsMn   // design minimum outside air flow (cfm actual air), constant,  dfl .15 * area.
    						// for FRACTION control, this is multiplied by  curr_flow/supply_fan_design_cap.

    *f ECOTYCH oaEcoTy  	// choice of NONE, NONINTEGRATED, TWO_STAGE, INTEGRATED.  constant. default NONE.
				// NONE means OA flow is the minimum, above.
				// INTEGRATED means economizer and coil do their respective things, independently.
				// NONINTEGRATED means coil does not run when economizer is enabled
				//		 (per oaLimT, oaLimE, oaMxFrac, right?)
				// TWO_STAGE: not needed for compliance, defer implementation til I understand coils:
				//            economizer off when coil cycles on ("requires calculating % coil runtime
				//            in subhour using minimum unloading step as capacity").

    // following 2 variables disallowed if economizer type is NONE
     //*declare "#define oaMxFrac (1.0)"	// maximum outdoor air as a fraction of current flow: hard-code to 1.0, 10-25-92.
     *h TEMP_RA oaLimT		// economizer oa temp hi limit: number -50 to 999, or RA for current return air temp,
     						// hourly, dfl RA.  oa flow reduced to minimum when oa temp > oaLimT.
     *h ENTH_RA oaLimE		// economizer oa enthalpy hi limit: number or RA, constant, dfl 999 (enth limit disabled).

    //economizer/oa DAMPER LEAKAGES. These are fixed quantities: fractions of max flow, not current flow.
    // Defaults??: Taylor's "standard damper" defaults shown; or could use "low leakage" (.05/.03) or 0.
    // expect to defer implementation of these till air handler and program flow including coil/fan overloads works well.

    *f FRAC oaOaLeak	// outside air damper leakage to mixed air, fraction of supply fan design cfm if have economizer,
    				    // else fraction of oaVfDsMn.  Const, default .05 if return fan, .10 if relief fan or no r/r fan.
    				    // Puts a floor on oa flow and thus a ceiling on ra flow, to mixed air.

    *f FRAC oaRaLeak	// return air damper leakage to mixed air, fraction supply fan design cfm,
     				    // constant, default .05 if relief fan or no r/r fan, .10 if return fan.
				        //  (note I took out proposed default 0 if no economizer 3-6-92 **)
     				    // Puts a floor on ra flow and thus a ceiling on oa flow, to mixed air.

    *h FRAC oaZoneLeakF // assumed zone leakage fraction; for zone airnet ONLY
                        //   retFlow = supFlow * (1. - oaZoneLeakF * po)
                        // default: 0 if return/relief fan else .5

    //heat recovery
    *r *nest HEATEXCHANGER ah_oaHx  // outdoor air heat recovery HEATEXCHANGER substruct

// Air handler LEAKAGES AND LOSSES INPUTS.  Leaks are const cfm cuz system is const pressure

    *f FRAC ahSOLeak		// Supply duct leakage to outdoors, 0-.1 of sfanVfDs, default .01.  use 0 if duct indoors.
    *f FRAC ahROLeak		// Return duct leakage from outdoors, 0-.1, of sfanVfDs, default .01, use 0 if duct indoors.
    *f FRAC ahSOLoss		// Supply duct loss/gain to outdoors, 0-.1, default .02? (Taylor 0.5F), use 0 if duct indoors.
    *f FRAC ahROLoss		// Return duct heat loss/gain to outdoors, 0-.1, default .02? (ditto), use 0 if duct indoors.


// AIR HANDLER FANS INPUTS: supply fan, return/relief (rr) fan.

    *h AHSCHVC ahSch	// supply fan and thus air handler schedule: choice of ON or OFF, hourly variable; default ON.
			// ON: fan runs at varying volume (except under ahFanCyles, when fan cycles on and off at full flow).
			// OFF: Taylor setback/setup control in effect, if specified, when/if implemented.
			// WARMUP, OPTIMUM_START: we may add these here later when implemented.
			// see also heat and cool coil schedules.

    *f *nest FAN sfan	// supply fan FAN substruct (as declared above)
		// following supply fan inputs are stored in FAN subrecord sfan:
    // FANTYCH sfanType		// supply fan type/position: choice of DRAWTHRU (default) or BLOWTHRU.  constant.
    // AFLOW_GZ sfanVfDs    	// design volume flow (cfm actual air), constant, RQD.
    // FLOAT  sfanVfMxF     	// factor by which fan will exceed vfDs (at reduced pressure). default 1.3. constant.
    // PRESAIR_GZ sfanPress  	// design pressure, "H2O, constant, default 3.
    // //At most one of the next 2 may be given:
    //  FRAC sfanFanEff		// Fan efficiency at vfDs and press, constant, default .65 or from power if given.
    //  BHP_GZ sfanShaftBhp  	// Fan shaft brake horsepower at vfDs and press, constant, default from eff.
    // FRAC sfanMotEff		// motor/drive efficiency, constant, default .9.
    // MOTPOSCH sfanMotPos 	// motor/drive position: choice of INFLO (default), INRETURN, or EXTERNAL.
				// INRETURN will be deferred/omitted if difficult (chip per taylor 3-4-92).
    // [FANPLCH sfanPlCtrl	// part-load control method, choice of VARSPEED (default), CYCLE, etc as above.]
    // PYCUBIC2 sfanCurvePy	// part-load energy consumption curve coefficients 6-92, default linear.
    // MTR sfanMtri		// MTR to which energy use is charged 4-11-92

    *f *nest FAN rfan	// return/relief (rr) fan subsruct (decl above)
			// if rfan.fanType is NONE, other rr fan members are disallowed.
		// following rr fan inputs are stored in FAN subrecord rfan:
    // RFANTYCH rfanType   	// return fan type/position: choice of NONE (default), RETURN, or RELIEF. constant.
    // AFLOW_GZ rfanVfDs   	// design volume flow, constant, default sfanVfDs. [ less min outside air -- undone 7-95 ]
    // FLOAT  rfanVfMxF     	// factor by which fan will exceed vfDs (at reduced pressure). dfl 1.3. constant.
    // PRESAIR_GZ rfanPress  	// design pressure, "H2O, constant, default .75.
    // //At most one of the next 2 may be given:
    //  FRAC rfanFanEff		// Fan efficiency at vfDs and press, constant, default .65 or from power if given.
    //  BHP_GZ rfanShaftBhp   	// Fan shaft brake horsepower at vfDs and press, constant, default from eff.
    // FRAC rfanMotEff		// motor/drive efficiency, constant, default .9.
    // MOTPOSCH rfanMotPos 	// motor/drive position: choice of INFLO (default) or EXTERNAL.
    // [FANPLCH rfanPlCtrl	// part-load control method, choice of VARSPEED, CYCLE, etc. default: same as supply fan.]
    // PYCUBIC2 rfanCurvePy	// part-load energy consumption curve coefficients 6-92. default: same as supply fan.
    // MTR rfanMtri		// MTR to which energy use is charged 4-11-92


// AIR HANDLER COILS INPUTS: crankcase heater, heat coil, cool coil

    *f *nest CCH cch		// crankcase heater subrecord 10-92 for AHP's, perhaps DX, must be common to heat and cool.

    *f *nest AHHEATCOIL ahhc	// ah heat coil subrecord.  If ahhc.coilType is NONE, other hc inputs are disallowed.
		// following ah heat coil inputs are stored in ahhc, + many additions:
    // HCOILTYCH ahhcType  	// choice of NONE (default), ELEC, HW (hot water, GAS, OIL, AHP, ... constant.
    // OFFAVAILVC ahhcSch	// OFF or AVAIL, hourly, default AVAIL.
    // POWER_GZ ahhcCaptRat  	// total rated capacity (Btu/hr), constant, RQD.
    // TI ahhcMtr		// MTR to which to charge energy use for non-plant coil types.
    //many more now (7-92), update

    *f FRAC_GZ ahccBypass	// fraction of air flow which bypasses cool coil (for better humidity control), constant, dfl 0.
     				// Bypass is fixed at given fraction; no damper control is modelled.

    *f *nest COOLCOIL ahcc	// cool coil subrecord.  If ahcc.coilType is NONE, other cc inputs are disallowed.
		// following cool coil inputs are stored in ahcc:
    // CCOILTYCH ahccType  	// choice of NONE (default), ELEC, DX, CHW, ... .  constant.
    // OFFAVAILVC ahccSch	// OFF or AVAIL, hourly, default AVAIL.
    // POWER_GZ ahccCaptRat  	// total rated capacity (Btu/hr), constant, RQD.
    // POWER_GZ ahccCapsRat  	// sensible rated capacity 1-CaptRat Btu/hr, constant.  Can it default to a % of CaptRat?
    // FRAC_GZ ahccSHRRat	    // sensible heat ratio (caps/capt) for cooling coil
    // TI ahccMtr		// MTR to which to charge energy use for non-plant-supported coil types.
    // many more now -- should update this, 5-92.

    /* CAUTION! subrecords arranged so COOLCOIL runtime members can exceed the limit of 255 on inputtable field numbers.
       Don't put inputtable members after COOLCOIL. COOLCOIL is subrecord with the most trailing runtime members. 10-25-92. */


// SETUP TIME VARIABLES FOR AIR HANDLER

    *r TI tu1		// chain head: TuB ss of 1st terminal for air handler.  Next is TU.nxTu4a.
    *r TI zhx1		// chain head of ah's ZHX's (Zone Hvac Xfers): 0 or ZhxB subscript of first. next: ZHX.nxZhx4a.


// RUNTIME VARIABLES FOR AIR HANDLER

  // ah runtime, terminals interactions:
    *s *e *hide BOO ahRun		// TRUE if ah has been run this subHr; if FALSE, ts is old or an estimage. 7-95.
    *s *e *hide SI timesReEst	// # times ah re-Estimated this subhr: to prevent inf loops.  set/tested in cnztu.cpp.
    *s *e AHMODE ahMode			// what ah is doing: set to: ahOFF/ahFAN/ahHEATING/ahCOOLING/ahON(normal).
    					        //  test: & ahFAN, & ahHEATBIT, & ahCOOLBIT for fan, heatcoil, coolcoil enabled.
    *s *e DBL /*TEMP*/ ah_tSup	// supply temp FOR TERMINALS, F.  Set from working copy aTs at ahCompute exit.
    					        // Differs from tsSp1 by duct loss and leakage (as well as coil limitations).
    *s *e DBL /*HUMRAT*/ ah_wSup	// supply air humidity ratio for TERMINALS, set from working copy aWs at ah exit
    *s    DBL /*HUMRAT*/ ah_wSupLs	// end prior subhr ah_wSup (=ah_wSup in 1st iteration), AH:ah_AfterSubhr to ZNR::ztuMdSets
    *s *e DBL /*HC_VOL*/ airxTs // Btuh/cfm-F volumetric flow heat capacity of air at ts (airVsh, * 60 min/hour).
    *s *e DBL /*TEMP*/ tsMnFo	// ctu min flow, coil-off supply temp, calc'd & ret'd by getTsMnFo. See tsMnFoOk.
    *s *e BOO tsMnFoOk			// TRUE if tsMnFo has been calc'd since last ahEstimate/ahCompute. set/used in getTsMnFo().
    *s *e DBL /*TEMP*/ tsMxFo	// ctu max flow, coil-off supply temp, calc'd & ret'd by getTsMxFo. See tsMxFoOk.
    *s *e BOO tsMxFoOk			// TRUE if tsMxFo has been calc'd since last ahEstimate/ahCompute. set/used in getTsMxFo().

//---- ah run internal: temp, w, flow, delta-T at various points in air handler ----

  // --- tr...tr2 are CURRENT ah inputs. See trNx...tr2Nx below for corress next iteration inputs resulting from current output.

   //input used for this iteration: return air as it left (future) plenum, b4 return duct: weighted average zones
    *s *e DBL /*TEMP*/ tr		// return air temp (wtd avg zones, adj for (future) plenum)
    *s *e DBL /*HUMRAT*/ wr		// return air humidity ratio
    *s *e DBL /*CFLOW*/ cr      	// return air flow (heat cap units); same as total supply air to zones
    *s *e DBL /*CFLOW*/ cMxfcc     	// max flow used re deterimining frFanOn (member for probes / dbg aid).
    *s *e DBL /*FRAC*/ frFanOn     	// if fcc, fraction of time coil/fan are on (cr/max poss c), else 1.0 (fan always on).
    *s *e DBL /*CFLOW*/ leakCOn    	// fan-on rtn duct leak in === sup duct leak out (6-92). mbr for probes / dbg aid.
   //at entry to air handler, this iteration -- see Nx's below.
    *s *e DBL /*TEMP*/ tr1		// return air temp after return duct loss and leakage
    *s *e DBL /*HUMRAT*/ wr1     	// hum rat after return duct leakage
    *s *e DBL /*CFLOW*/ cr1		// flow ditto, heat cap units (Btuh/F)
   //after return fan, if any, this iteration; at entry to economizer.  w: use wr1.  c: use cr1.
    *s *e DBL /*TEMP*/ tr2		// temp after rfan, b4 eco, for next iteration: copied to tr3 after conditional exit.
    *s *e POWER rfanQ			// return fan power copied at commitment to this iteration (rfan.q is next iter)

   //after economizer, before supply fan and coil(s).
    *s *e DBL /*TEMP*/ tmix  		// temp after outside air/economizer
    *s *e DBL /*HUMRAT*/ wen		// hum after outside air/economizer, and at coil entry
    *s *e DBL /*CFLOW*/ cmix		// flow after outside air/eco, thru supply fan, and at supply duct (but not in cool coil)
   //at coil entrance: after blowthru supply fan if any; excludes flow that bypasses coil
    *s *e DBL /*TEMPDIFF*/ dtMixEn	// eco to coil entry temp diff: supply fan heat if blowthru, else 0
    *s *e DBL /*TEMP*/ ten  		// coil entry temp: poss fan heat added.  wen: is just above.
    *s *e DBL /*CFLOW*/ cen			// flow into coil: cmix less any bypassing air, heat cap units (Btuh/F)
    *s *e DBL /*MFLOW*/ men			// same flow in mass units (lb/hr).
    //tWbEn: see COOLCOIL.
    //hen:   see COOLCOIL.
   //at coil exit
    *s *e DBL /*TEMP*/ tex   		// coil exit temp: coil Q added.
    *s *e DBL /*HUMRAT*/ wex		// coil exit humidity ratio
   //after coil flow mixed with bypassing air
    *s *e DBL /*TEMP*/ tex1			// add fan heat to get tSen.
    //wex1: use aWs (below), later copied to ws (above).
    //flow: cmix again.
   //at ts sensor: after drawthru supply fan if any: ie at air handler exit, before supply duct.  c: is cmix.  w: use aWs.
    *s *e DBL /*TEMPDIFF*/dtExSen	// coil exit to ts sensor temp difference: drawthru fan heat, else 0
    *s *e DBL /*TEMP*/ tSen			// temp at supply temp sensor (before supply duct). ahTsSp1 is setpoint for tSen.
   // at delivery to individual terminal supply ducts, after shared supply duct leakage and loss if any
    //w: use aWs. c: is cr, or sum of terminal c's.
    *s *e DBL /*TEMPDIFF*/ dtSenS	// supply duct temp diff, due to ahSOLeak and ahSOLoss
    *s *e DBL /*TEMP*/ aTs			// supply temp (air handler output).  aTs is ah working copy used so last value used
    								// for ztuCompute (ts, above) remains avail thru AH::ahCompute. Elsewhere, same as ts.
    *s *e DBL /*HUMRAT*/ aWs		// hum rat of supply air, working copy, used to set ws at ah exit.
    //CFLOW cs: expect to need when return flow != supply.

  // --- temps etc...  trNx...tr2Nx are values for use as inputs to NEXT iteration, resulting from current ah outputs.
  					// they are copied to tr...tr2 above at use (commitment to another iteration) by pute4Fs.
   //next-iteration return air as it leaves (future) plenum, before return duct: weighted average zones
    *s *e DBL /*TEMP*/ trNx		// return air temp (wtd avg zones, adj for (future) plenum)
    *s *e DBL /*HUMRAT*/ wrNx		// return air humidity ratio
    *s *e DBL /*CFLOW*/ crNx  		// return air flow (heat cap units); same as total supply air to zones
    *s *e DBL /*CFLOW*/ cMxnx		// flow for frFanOnNx = 1.0: min( crNx, sfan.cMx-leak).  Member just for probes/dbg aid.
    *s *e DBL /*FRAC*/ frFanOnNx	// if fcc, fraction of time coil/fan are on (crNx/max poss flow), else 1.0 (fan always on).
    *s *e DBL /*CFLOW*/ leakCOnNx	/* fan-on leak into return duct === leak out of supply duct at present 6-92.
    					   member for probes/debug aid; cd remove setFrFanOn arg. */
   //at entry to air handler, next iteration
    *s *e DBL /*TEMP*/ tr1Nx		// return air temp after return duct loss and leakage
    *s *e DBL /*HUMRAT*/ wr1Nx		// hum rat ditto
    *s *e DBL /*CFLOW*/ cr1Nx		// flow ditto [formerly named cAh]; heat cap units (Btuh/F)
   //after return fan, if any; at entry to economizer; next iteration.  w: use wr1Nx.  c: use cr1Nx.
    *s *e DBL /*TEMP*/ tr2Nx		// temp after rfan, b4 eco, for next iteration: copied to tr3 after conditional exit.

  // ah run, internal, general/miscellaneous
    *s *e TCUSE uUseAr     	// 'or' of tu.useAr's at refine() entry, for detecting pegged terminals, set in zRat, tentative.
    *h *e BOO fcc		    // TRUE if fan cycles: fan runs only fraction of subhour requested by control terminal, else off.
    				        //                     when on, fan runs full flow and coil usually at a high power.
    				        // set hourly from ahFanCycles else ahTsSp==ZN by AH::begHour.
				            // when TRUE: frFanOn is fraction time on for fan (and usually coil).
				            //            flows and powers become average, divide by frFanOn for fan-on value.
				            //            ah Temps, w's, plr's, po remain fan-on values.
				            // when FALSE: fan runs all the time (normal VAV case), frFanOn is 1.0.
    *h *e BOO isZNorZN2			    // TRUE if ahTsSp is ZN or ZN2 this hour. 5-95.
    *s *e DBL /*TEMP*/ tsSp1    	// ahTsSp as number: WZ/CZ/ZN/ZN2 resolved to temp now needed, set by AH::setTsSp1.
    *s *e DBL /*TEMP*/ tsFullFlow	// heating ts for full flow, special re AHP suppl rh stability, usually not set,
                					// cnah2.cpp:setTsSp1 to cncoil.cpp:doAhpHeatCoil
    *s *e BOO ecoEnabled		// TRUE if economizer present and currently enabled
    *s *e BOO coilLockout		// TRUE if cooling coil disabled by full-open non-integrated economizer
    *s *e DBL po			    // current fraction outside air
    *s *e COILUSED coilUsed		// coil in use, doCoils to coilsEndSubhr: cuNONE, cuHEAT, or cuCOOL. 12-3-92.

  // ah run, internal, fan/coil overload handling
    *s *e DBL fanF		// "fan factor" used in determining current max flows. reduce when fan overloads.
    *s *e DBL fanFMax		// fanF value for full flow: max tu vfMx/vfDs, reflecting both vfMxH's & vfMxC's.
				// can change hourly, more often during autoSizing 7-95.
				// CAUTION: fanF below fanFMax won't NECESSARILY reduce flow for current useAr's.
    *s *e BOO fanLimited   	// TRUE if using full capacity of fan without getting desired flow
    *s *e BOO coilLimited	// TRUE if using full capacity of available coil without getting desired delta-T
    *s *e DBL /*TEMP*/ tPossH	// heating coil exit temp probably now possible, for ah estimating, doCoils to setTsSp1.
    *s *e DBL /*TEMP*/ tPossC	// cooling coil exit temp probably now possible, for ah estimating, doCoils to setTsSp1.

  // ah run... Pr's: prior values for change-detection
    *s *e *hide TEMP tsAhPr     	// last fully-computed ts: if ts (estimate) much different, force full recalc
    *s *e *hide TEMP_TSCM ahTsSpPr  	// ahTsSp for which ts fully computed, updated at end of AH calculation
    *s *e *hide DBL /*FRAC*/ fanFPr 	// fanF for which terminal limits computed, set/used in AH::ahVshNLims.
    *s *e *hide TEMP tr2NxPr		// last next return air temp for last computed ts, tested/set in AH::ahCompute.
    *s *e *hide CFLOW cr1NxPr		// return cap flow ditto
    *s *e *hide HUMRAT wr1NxPr		// return humidity ratio (after leak) ditto
    *s *e *hide OFFAVAILVC hcSchPr	// prior value of heat coil schedule ahhc.Sch
    *s *e *hide OFFAVAILVC ccSchPr	// prior value of coil coil schedule ahhc.Sch
    *s *e *hide TEMP ah_tDbOShPr		// prior calc subhour-end outdoor temp, F
    *s *e *hide HUMRAT ah_wOShPr		// prior calc subhour-end outdoor hum rat

  // ah run... These Pr's used by cnah2.cpp:AH::flagTusIf.
    *s *e *hide TEMP ah_tSupPr 		// last ah_tSup for which terminals computed, tested/updated by hvacIterSubhr NOT BY AH
    *s *e *hide TEMP ah_wSupPr 		// last ah_wSup for which ah's terminals computed, tested/updated by hvacIterSubhr NOT BY AH
    *s *e *hide TEMPDIFF ah_dtPr	// last delta-T (ah_tSup - tr) for which tu's computed, tested/updated by hvacIterSubhr NOT BY AH

  // changes flag (many ah change conditionals use a -Pr (prior) directly, without a flag)
    *s *e BOO ahClf		// call-flag: set nz if must call ahCompute so it can test tr,cr etc to see if computation needed.
    *s *e BOO ahPtf		/* compute-flag: set if must call ahCompute and it should unconditionally recompute this AH:
				   setters include: exman chaf's for ahTsSp, ahSch, ahhc.sched, ahcc.sched, etc;
				                    AH::estimate, ahCompute, ah_SetMode, ; ZNR::ztuMdSets, .
				   tested: hvacIterSubhr(), AH::ahCompute. cleared: AH::ahCompute. */
    *s *e BOO ahPtf2		/* secondary flag for compute only after zones computed again, for non-convergence.
				   set: AH::iter4Fs. tested: hvacIterSubhr(), AH::ahCompute. cleared: AH::ahCompute. */
*END				// AH

//========================================================================================================
RECORD AHRES_IVL_SUB "air handler interval results sub" *SUBSTRUCT	// ah result substruct for AHRES
    INT n			// number of intervals added together in this one (divisor for averages)
 //float members to average in results accumulation. cnguts.h defines assume tDbO is 1st, vf is last.
    //pairs consisting of temperature & humidity (wetbulb temp may be generated when printing)
    TEMP tDbO  HUMRAT wO	// outdoor temp (for convience for reporting; same for all ah) (Top.tDbO, .wO)
    TEMP tr    HUMRAT wr	// return air (AH.tr,.wr)
    TEMP tmix  HUMRAT wmix  	// mixed air (.tmix,.wmix)
    TEMP ts    HUMRAT ws    	// supply air (.ts, .ws)
    FRAC  po			// fraction outside air (.po)
    FRAC  frFanOn		// fraction of time fan on if ahFanCycles, else 1.0
    AFLOW vf			// flow (at supply fan) (.cmix)
 //float members to add: qh is first, hrsOn is last.  CAUTION: q's here are energy not power.
    ENERGY qh    ENERGY qc	// heat and total cool load (at coils)
    ENERGY qs    ENERGY ql	// cool sensible and latent loads (included in qc)
    ENERGY qO	 ENERGY qFan 	// net energy taken from outside air (possible future impl); fan heat energy
    ENERGY qLoss ENERGY qLoad	// leak/loss net energy; energy delivered to load.
    ENERGY qBal			// unbalance, should be near 0: qh+qc+qO+qFan+qLoss+qLoad.
    ENERGY ph    ENERGY pc   	// heat and cool coil input energy, from meter or (probably) from plant
    ENERGY pAuxH ENERGY pAuxC	// heat and cool aux energy
    ENERGY pFan			// fans input energy
    HOURS  hrsOn    		// time air handler on: accumulated Top.tp_subhrDur
 //long integer members to sum in accumulation.  cnguts.h defines assume nSubhr is 1st, nIterFan is last.
    LI nSubhr  			// subhour counter: for convenience / possibly making cluster-dependent
    LI nIter1			// iteration counter 1: # times called, including immediate exits
    LI nIter2			// iteration counter 2: # times executed
    LI nIter4			// iteration counter 4: # inner loops (calls to pute4Fs)
    LI nIterFan			// # fan adjustment iterations, counting both ups and downs
*END		// AHRES_IVL_SUB

//=============================================================================
RECORD AHRES "ahRes" *RAT		// holds air handler and all-ahs simulation results (later at subscript # ah + 1)
    // name: same as corresponding ah, or sum_of_ahs.
    //CAUTION: code assumes these are in order matching IVLCH, so can add IVLCH-1 to ptr to .Y to access M,D,S. eg in cgresult.cpp.
    *y *e *nest AHRES_IVL_SUB Y  	// ah run results, aka year or annual
    *m *e *nest AHRES_IVL_SUB M  	// month
    *d *e *nest AHRES_IVL_SUB D  	// day
    *h *e *nest AHRES_IVL_SUB H  	// hour.
    *s *e *nest AHRES_IVL_SUB S  	// subhour, aka subStep or sub-time-step
*END		// AHRES

//=============================================================================
RECORD TU "terminal" *RAT		// TERMINAL

// Each TERMINAL record describes one zone terminal unit, associated with a single given air handler.
// Each terminal can have local heat, air heat, and air cool capabilities.
// Multiple terminal units are allowed in a zone (two must be used for dual duct systems).

    *prefix tu_

    *declare "virtual RC RunDup( const record* pSrc, int options=0);"
    *declare "RC tu_Setup();"			// initial input check/setup, cncult5.cpp
    *declare "bool tu_IsAirTerminal() const {  return cmAr != cmNONE; }"
    *declare "void fazInit( int isAusz);"
    *declare "RC tu_pass1AtoB();"
    *declare "RC tu_begP1b();"
    *declare "void rddiInit();"
    *declare "RC tu_SetupSizes();"
    *declare "void tu_p2Init();"
    *declare "void endP2Dsd();"
    *declare "RC tu_p2EndTest();"
    *declare "RC tu_endAutosize();"
    *declare "void tu_auszFinal();"
    *declare "BOO resizeIf( DBL &cv, BOO isCooling, DBL cvLim, BOO decrOnly);"
    *declare "RC tu_BegHour();"
    *declare "RC tu_BegSubhr();"
    *declare "RC tu_EndSubhr();"
    *declare "RC tuEstimate();"
    // terminal compute and end-subhour operations are done by ZNR member functions.
   // following 8 return CFLOW: heat cap flow (Btuh/F):
     *declare "DBL tfanBackCMx()     { return tfanRunning ? 0. : tfanBkC; }"		// max backflow thru shut-off tfan
     *declare "DBL aTfanBackC()      { return tfanRunning ? 0. : min( aCv, tfanBkC); }"	// ah working backflow thru shut-off tfan @ curr flow
     *declare "DBL tfanBackC(DBL _cv) { return tfanRunning ? 0. : min( _cv, tfanBkC); }"// backflow thru shut-off tfan @ flow cv
     *declare "DBL aRLeakC()         { return (aCv - aTfanBackC()) * tuSRLeak; }"   	// ah working flow leakage to ret/plenum
     *declare "DBL aCz()             { return (aCv - aTfanBackC()) * (1.-tuSRLeak); }"	// ah working flow getting to zone
     *declare "DBL znC(DBL _cv)       { return (_cv - tfanBackC(_cv)) * (1.-tuSRLeak); }"// flow getting to zone given vav flow
     *declare "DBL vavC(DBL _cz)      { return (_cz + tfanBackCMx()) / (1.-tuSRLeak); }"// flow req'd at vav for flow cz to zone
  //restore if needed:
   //*declare "DBL tfanBackC()       { return tfanRunning ? 0. : min( cv, tfanBkC); }"	// backflow thru shut-off tfan @ curr flow
   //*declare "DBL rLeakC()          { return (cv - tfanBackC()) * tuSRLeak; }"		    // current flow leakage to return/plenum
     *declare "DBL rLeakC(DBL _cv)    { return (_cv - tfanBackC(_cv)) * tuSRLeak; }"    // flow leakage to return/plenum

    //.ownTi is terminal's zone.  name is optional.

#if 1//def(AUTOSIZE) //cnglob.h

// Terminal autosizing members 6-95. Later distribute below?

    //input, in addition to AUTOSIZE tuhcCaptRat, tuVfMxH, tuVfMxC, tuVfMn (these set FsAS field status flag)
    *f DIFFSAMECH tuVfMxHC	// autoSize tuVfMxH and -C SAME or (default) different.
    *f FLOAT_GZ tu_fxCapH  	// capacity factor for autoSized heat coil (default 1.1 = 10% oversized)
    *f FLOAT_GZ tu_fxVfHC   // air flow factor for autoSized air flow (default 1.1 = 10% oversized)

    //setup
    *r BOO asHcSame		// TRUE to autoSize tuVfMxH and -C the same -- specified with "tuVfMxHC = SAME"
    *r BOO asKVol		// TRUE to autoSize for constant volume -- specified with "AUTOSIZE tuVfMn" (implies asHcSame).
    //runtime
    *nest AUSZ hcAs			// autoSizing data members substruct re tuhc.captRat -- local heat heat coil capacity.
    *nest AUSZ vhAs			//  .. re tuVfMxH -- air heat max flow
    *nest AUSZ vcAs			//  .. re tuVfMxC -- air cool max flow
    *s *e POWER qhPk    *s *e POWER qcPk   	// peak values of qh and qc, for load reports and -PkAs's. qc negative.
    *s *e POWER qhPkAs  *s *e POWER qcPkAs 	// peak values for all autoSize converged design days, for size reports
    // tuVfMn, -MxH, -C saved at entry to hvacIterSubhr for conditional backtracking while autoSizing
    *s *e AFLOW_GEZ bVfMn   *s *e AFLOW_GEZ bVfMxH   *s *e AFLOW_GEZ bVfMxC
    // flags TRUE if dT too low for autoSizing tuVfMxH, C (supply temp too close to zone temp, eg due to weak ah coil)
    *s *e BOO dtLoHSh   *s *e BOO dtLoCSh	// .. this subhr, set in cnztu.cpp:ztuMode, cleared in ztuAbs.
    *s *e BOO aDtLoHSh  *s *e BOO aDtLoCSh	// .. this subhr, set at end of cnah1.cpp:ahCompute
    *s *e BOO aDtLoTem  					// cnah2:antRatTs to ahCompute temp flag re aDtLoHSh, CSh
    *s *e BOO dtLoH     *s *e BOO dtLoC  	// .. on this autoSizing design day iteration (or poss run)
    *d *e BOO dtLoHAs   *s *e BOO dtLoCAs	// .. on any converged pass 2 design day: invokes endAutosizing() message.
    //runtime: results: see COIL tuhc.captRat_As, tuVfMn/MxH/MxC_As, ditto _AsNov, below.
#endif

// Terminal LOCAL HEATING input variables

    //next 2: if neither given, no LH; if setpoint given, tstat-controlled; else if tuQMnLh given, constant power.
    *h TEMP_GZ   tuTLh  	// local heating set point for tstat control. hourly. default: no tstat control.
    *h POWER_GEZ tuQMnLh	// desired continuous output (Btuh) if no setpoint, or minimum if tuTLh given, hourly, default 0.
                            //  rest of LH variables disallowed if neither of above given (no LH)

    *h POWER_GEZ tuQMxLh	// max desired power, subject to plant limits, Btuh, hourly, RQD if tuTLh given, else disallowed.
    //*r POWER_GEZ tuQDsLh	//   was intended to apportion power upon plant overload; instead, using tuhcCaptRat, 9-92.
     				        //   dflt was max(tuQMnLh,tuQMxLh) or RQD if any of those vbl & tuTLh or tuQMnLh given.
    *f SI_GZ tuPriLh		// priority if setpoint equals another, low #'s used first, dfl 100, disallowed if tuTLh not given.
    *f NOYESCH tuLhNeedsFlow	// YES to disable lh when tu fan off and central fan off or VAV flow 0 (coil in terminal).
    				        // NO if can heat without flow (baseboard).  default: NO.

    *f *nest HEATCOIL tuhc	// subrecord for terminal coil, type ELECTRIC or HW.
		// following terminal local heat inputs are in tuhc, and now more!:
    //COILTYCH tuhcType  	// choice of ELEC, HW (hot water), ... . constant.
    //				// default NONE if no local heat, else ELEC.
    ////sched: no schedule input for terminal coil: always available, do scheduling with setpoints or min/max heat.
    //POWER_GZ tuhcCaptRat   	// rated capacity (Btu/hr), constant, RQD.
    //TI tuhcMtr		        // MTR to which to charge energy use for non-plant-supported coil types.

// Terminal AIR HEAT/COOL input variables

    //next 3 determine capability: heat setpoint given-->tstat ctrl'd heat cap;  cool setpoint given-->tstat ctrl'd cool cap;
    //				   neither sp given but min flow given-->continuous output at that flow regardless of zone temp.
    *h TEMP_GZ tuTH    		// air heating set point (F). hourly. default: no tstat-controlled air heating.
    *h TEMP_GZ tuTC    		// air cooling set point (F). hourly. default: no tstat-controlled air cooling.
    *s *e AFLOW_GEZ 
    tuVfMn	// min flow (cfm actual air); if no setpoints given, this is "specified output".  hourly, dlf 0.
    *f AFLOW_GEZ tuVfMn_As	// .. as autoSized (for constant volume), less variable, for probing.
    *f AFLOW_GEZ tuVfMn_AsNov	// .. raw autoSized value before oversize added, for possible probes.
    //cnausz.cpp code ASSUMES x, x_As, x_AsNov together for access thru one ptr. cuprobe.cpp's name search also requires together.
    //if none of tuTH/tuTC/tuVfMn given, rest of air heat/cool variables are disallowed.

    *i TI ai		// 0 or AH ss (subscript) for air handler serving tu (input as air handler name). RQD if sp or Mn given.

    *s *e			            // *s *e cuz autoSize changes it... inputtable hourly. 7-20-95.
       AFLOW_GEZ tuVfMxH	    // heating max flow (cfm actual air) b4 ah limits, hourly, RQD if TuTH given else disallowed
    *f AFLOW_GEZ tuVfMxH_As	    // .. as determined by autoSizing, less variable, for probing.
    *f AFLOW_GEZ tuVfMxH_AsNov	// .. raw autoSizing result before oversize added, for report/probes.
    //cnausz.cpp code ASSUMES x, x_As, x_AsNov together for access thru one ptr. cuprobe.cpp's name search also requires together.
    *s *e AFLOW_GEZ tuVfMxC	    // cooling max flow (cfm actual air) b4 ah limits, hourly, RQD if TuTC given else disallowed
    *f AFLOW_GEZ tuVfMxC_As	    // .. as determined by autoSizing, less variable, for probing.
    *f AFLOW_GEZ tuVfMxC_AsNov	// .. raw autoSizing result before oversize added, for report/probes.
    //cnausz.cpp code ASSUMES x, x_As, x_AsNov together for access thru one ptr. cuprobe.cpp's name search also requires together.

    *r AFLOW_GZ tuVfDs	// design flow (cfm actual air), constant, to apportion flow when ah fan overloads.
	     				// default larger of tuVfMxH, tuVfMxC, tuVfMn,
	     				//  or RQD if vbl expr given for any of those and tuTH, tuTC, or tuVfMn given.

    *f SI_GZ tuPriH		// heat setpoint priority: lowest # used first when equal setpoints in zone.  const. default: 1.
    *f SI_GZ tuPriC		// cool likewise.		... RQD if corress sp given, else disallowed.

  //Air heat/cool refinements to implement once program runs and convergence problems solved (Taylor):

    *f FRAC tuSRLeak	// leakage 0-.5 of supply air to return, increasing supply vol and return temp.  constant; dfl .05.
     			        // note this is fraction of current cfm, whereas ah leak (before VAV dampers) is fraction max cfm.
			            // add tfanOffLeak to this if terminal has fan that is not running.

    *r FRAC tuSRLoss	// supply air to return plenum heat loss as a fraction 0 - .5 of supply air to return air
     			        // temperature difference, constant, default .1.  Not allowed if return is ducted.

     //*f BOO plenumRet	is a ZONE member.

  //Terminal FAN.  Implementation deferred.  If tfanType is NONE other terminal fan members are disallowed.

    *r TFANSCHVC tfanSch  	// terminal fan schedule, choice of OFF, ON, HEATING, or VAV, hourly, RQD if tfanType not NONE.
				//  HEATING:  fan ON if local heat output is non-0
				//  VAV: fan ON if central fan ON or doing setback/setup heat and ssCtrl is ZONE_HEAT or BOTH.
				// series fan runs whenever ON.
				// parallel fan runs enough to keep terminal cfm at terminal minimum + fan cfm -- makes up
				//  any shortage in air thru damper.  Code as though variable speed (tho usually cycles).
				// example (rob's) of need for variability: central system cools in daytime but does setback
				//  heat at night: tfanSch might be HEATING in daytime and VAV at night.

    *r FRAC tfanOffLeak		// backdraft leakage when fan off, 0 to .25 of tfanVfDs, constant, dfl .1, or 0 if no fan.

    *nest FAN tfan		// terminal fan FAN subrecord.  If tfan.fanType is NONE, other tfan inputs disallowed.
    		            // the following terminal inputs are in tfan:
    //FANTYCH tfanType     	// NONE (default), SERIES, or PARALLEL.  constant.  Fan source is return air.
    // 				// parallel: fan runs when VAV flow low; tfan cfm is added to VAV cfm to get zone cfm.
    // 				// series always runs; if VAV cfm < tfan cfm, rest comes from RA.
    //AFLOW_GZ tfanVfDs		// terminal fan design flow (cfm actual air), RQD if fan present.
    //				// or default to terminal heat design flow? ??
    //PRESAIR_GZ tfanPress 	// tu fan external static pressure, .05 to 1.0 "H2O, constant, default .3.
    //FRAC tfanEff		// tu fan/motor/drive combinded efficiency, constant, default .08. .08!?
    //MTR tfanMtri		// MTR to which energy use is charged 4-11-92
    //PYCUBIC2 tfanCurvePy	// part-load energy consumption curve coefficients 6-92, default linear
    //// other fan subrecord members for terminal fan are internally set as follows:
    ////  vfMxF: 1.0;  motPos: INFLO;  shaftPwr: default from eff;
    ////  motEff: 1.0: needn't differentiate fan eff from motEff under INFLO.

// TERMINAL SETUP TIME variables
    *r TI nxTu4z	// chain: 0 or ss (subscript) of next TU in zone chain. head is ZNR.tu1.
    *r TI nxTu4a	// chain: 0 or ss (subscript) of next TU in air handler chain. head is AH.tu1.

    *r TI xiLh		// subscript of ZHX for terminal's local heat capability
    *r TI xiArH		// ss of ZHX for cmSo air heat/cool or cmStH air heat capability
    *r TI xiArC		// ss of ZHX for tu's cmStC air cool, if any

    // terminal capability existence / ctrl method flags, inferred from inputs:
     *r TCCM cmLh	// local heat: cmNONE=0; cmStxx: tstat-controlled (setpoint given); or cmSo (only output/flow given).
     *r TCCM cmAr	// air heat and cool: cmNONE=0,cmSo=1,cmStH=2,cmStC=4,cmStBOTH=6.

// TERMINAL RUNTIME variables for ZN/ZN2 control method interaction with air handler
    *r TI ctrlsAi	// ss of ah ctrl'd by this tu under ZN/ZN2 control method, this hour (setup time).
    			    // CAUTION: verify ah->ahTsSp==ZN or ZN2 -- may vary.
    *s *e AHMODE wantMd	// terminal request to ctrl'd ah: HEATING, COOLING, OFF.  set in TU::estimate, ztuCompute, AH::wzczxxxx.

// terminal runtime variables -- mostly inputs to terminal code
    *s *e DBL /*POWER*/ lhMn   	// min local Q this subhour: tuQMnLh, adjusted for plant capacity (reduced if overloaded) (Btuh)
    *s *e DBL /*POWER*/ lhMx   	// local heat maximum Q this subhour: tuQMxLh adjusted for plant capacity (Btuh)
    *s *e DBL /*POWER*/ lhMxMx	// max lhMx re autoSizing user input problem diagnosis in cnztu.cpp
    // cMn,cMxH,cMxC are tuVfMn,-MxH,-C conv'd to heat cap flow rate @ curr temp/press & adjusted for current ah capacity (fanF).
    *s *e DBL /*CFLOW*/ cMn   	// specified or min or autoSized air flow this subhour (Btuh/F)
    *s *e DBL /*CFLOW*/ cMxH   	// air heat (cmStH) max flow this subhour (Btuh/F)
    *s *e DBL /*CFLOW*/ cMxC   	// air cool (cmStC) max flow this subhour (Btuh/F)

// terminal runtime variables set within terminal code
    *s *e TCUSE useLh		    // local heat use this subhour: uNONE(0)/uSo/uMn/uStH/uMxH.
    *s *e TCUSE useAr		    // air cool/heat use this subhour, same plus uStC/uMxC.
    *s *e DBL /*POWER*/ qLhWant	// desired local heat: value > tuhc.q invokes plant off check in tuEndSubhr, 9-25-92.

// terminal runtime variables -- OUTPUTS of terminal module, and some AH working storage
    // actual local heat output (Btuh) (former .qLh, 9-92) is in tuhc.q, 0 if required plant off or flow not present.
    *s *e DBL /*CFLOW*/ cv     	// actual heat cap flow rate at vav damper, current subHr (Btuh/F), official ztuCompute copy.
    *s *e DBL /*CFLOW*/ cz	    // zone heat cap flow rate, current subHr (Btuh/F): cv less leaks.  for probing.
    *s *e DBL /*CFLOW*/ aCv	    // working copy of cv for air handlers to use/modify then possibly abandon
				                // ah working cz: is computed by function aCz() (above) as required

// terminal fan runtime variables
    *s *e BOO tfanRunning	// TRUE if terminal fan running this subhour (no backflow).
    				        // ztuCompute(?) must set when tfan implemented. NO CODE YET SETS THIS TRUE as of 5-92.
    *s *e DBL /*CFLOW*/ tfanBkC	// terminal fan backflow (supply air to return or plenum) when fan not running:
    				            // tfan.vfDs*tfanOffLeak, converted to heat cap units @ current supply temp.
    				            // 0 if no terminal fan; user must use 0 if tfanRunning.
    				            // set by AIR HANDLER in AH:ahVshNLims, 5-92.

// 'aq' and 'b' for this tu's zone EXCLUDING THIS TU, or b=0 if tz and c fixed elsewhere.
//    how AH uses: float mode:     tz = (aqO + c*ts)/(bO+c)
//                 setpoint mode:  if bO non-0:  c = (tz*bO - aqO)/(ts-tz)
//                                 bO==0:        c and tz fixed by some other terminal and ah, do not recompute.
//    set by ztuMode; may be updated by AH (for other AH's) when ts changes.
    *s *e *hide DBL aqO  	// a+q for loads and all tu's BUT THIS ONE if any: aqLdSh + lhQ's + sigma(c*ts)
    *s *e *hide DBL bO   	// b ditto: bLdSh + sigma(c), or 0 if zone at sp of some other tu.
    *s *e *hide DBL tzO  	// aqO/bO, or 0 if bO is 0: zone temp excluding this ah, re detecting load changes 6-92.

// zone humidity values excluding this tu, for use in air handler (with new this-tu values) and update by OTHER ah's
    *s *e *hide DBL /*CFLOW*/ wcO  	// sum of tu->cz*ah->ah_wSup to zone except this tu's: supply air part of aw less this tu
    *s *e *hide DBL /*CFLOW*/ cO  	// sum of tu->cz's to this zone except this tu's: supply air part of bw less this tu
    *s *e *hide DBL /*HUMRAT*/ wzO	// znW(wcO,cO): zone w excluding this ah, re detecting changes requiring ah redo, 6-92.

// Pr's: prior values, re input change detection

    //re setting ZNR.soCf/stCf in TU::begHour, updated in TU::tuSOs/tuMdStOcq.
       *s *e *hide POWER lhMnPr
       *s *e *hide POWER lhMxPr
    //// re setting ZNR.soCf and stCf in AH::ahVshNLims, updated in TU::tuSOs/tuMdStOcq
       //*s *e *hide CFLOW cMnPr	found unused 4-17-95
       //*s *e *hide CFLOW cMxHPr	found unused 4-17-95
       //*s *e *hide CFLOW cMxCPr	found unused 4-17-95

    //re setting AH::ahClf/ahPtf in ZNR.ztuMdSets, updated in AH::upPriors, 6-92
       *s *e *hide TEMP   tzPr		// prior zone aTz at ahCompute exit
       *s *e *hide HUMRAT wzPr		// prior zone aWz ..
       *s *e *hide CFLOW  czPr		// prior tu aCz ..
       *s *e *hide HUMRAT wzOPr		// prior tu wzO ..
*END			// TU

//=============================================================================
RECORD ZHX "zhx" *RAT		// zone hvac transfer
	// Run only.  Each record is info about HVAC of one zone by one terminal capability or (future) vent.
	// name is copied from terminal (thus not unique), or zone if (future) vent.
	// ownTi tentatively 3-92 set to zi despite ambiguity of multiple zhx's for same zone and terminal

    // MUCH REDUNDANCY... generally 3-19-92 trying to replace zhx use with tu use; later grep & gc unnec zhx members.
    //			  basic ZHX use to keep: is what to sort to establish mode sequence.

// setup time members
    *r ZHXTY zhxTy	// zhx type (cndtypes.def): LhSo, LhStH, ArSo, ArStH, ArStC, or (future) nv.
    			    // testable bits: So = set output, StH, StC, St = set temp (both),
    			    //                Lh = local heat (coil in terminal, or baseboard),
    			    //                Ar = heat/cool with air from air handler.

    *h TEMP sp    	// setpoint if heat xfer is tstat controlled (SETTMP), else unused (hourly variability)
    *r SI spPri   	// setpoint priority: low #'s used first if setpoints equal, so can eg peg air heat b4 using local heat.

    *r TI ui		// terminal TU subscript if a term cap type
    *r TI zi		// zone ZNR subscript always -- for term cap or vent zhx.  When stable, just use ownTi?
    *r TI ai		// 0 or AH ss (subscript) of air handler supplying Ar zhx (copied from tu).

    *r TI xiLh		// subscr of local heat ZHX for same terminal if any, else 0; not set for self.
    *r TI xiArH		// was xiHeat.  subscr of air heat or air set output ZHX for same terminal, if any, else 0
    *r TI xiArC		// xiCool.      subscr of air cool ZHX for same terminal, if any, else 0

    *r TI nxZhx4z	// chain: 0 or subscript of next terminal zhx for this zone; 0?? if vent; head ZNR.zhx1.
    *h TI nxZhxSt4z	// chain: 0 or ss of next SETTMP zhx for this zone; head ZNR.zhx1St; kept sorted on sp/pri at runtime.

    *r TI nxZhx4a	// chain: 0 or subscript of next terminal zhx for this air handler; head AH.zhx1.

// runtime members
    *h SI mda		// for SETTMP, mode (mdSeq[] subscr) in which this is active (ctrl'd by its sp) ZHX.
    			    // in lower modes, heat is max, cool min; vica versa in hier modes.
*END		// ZHX

//=============================================================================
RECORD PUMP "pump sub" *SUBSTRUCT	// pump subrecord for BOILER, CHILLER, TOWERPLANT, HPLOOP, .
    *declare "RC setup( record *r, SI pumpFn);"
    //*declare "RC PUMP::endSubhr();"
 //PUMP user inputs
    *r H2OFLOW_GZ gpm		// rated flow (gpm), delivered at HdLoss. required input. code defaults .gpm for blrp, chcp, chpp.
    *f PRESH2O_GEZ hdLoss 	// head (pressure), ft-H2O. Accept 0 for 0 pump heat. Default CHW: 65; CW:45; HW:35.
    *f FRAC_GZ motEff    	// motor efficiency, default .88
    *f FRAC_GZ hydEff    	// hydraulic eff, default .70. Only product of motEff * hydEff is used.
    *r FLOAT ovrunF		/* overrun factor for future use, now 9-92 set to constant 1.3.
    				   maximum deliverable flow at (assumed) reduced head, as multiple of Gpm. */
    *i TI mtri			// name of MTR to which electrical use is added
 //PUMP setup time variables
    *r DBL /*MFLOW*/ mw  	// rated flow, Gpm converted to lb/hr
    //*r DBL/*MFLOW*/ mwMx	rated flow times ovrun, lb/hr -- if needed
    *r DBL /*POWER*/ q   	// shaft power === heat to water, Btuh
    *r DBL /*POWER*/ p   	/* electrical input, whenever running, Btuh: flow in application always at least mw;
	    			   overruns at least to mwMx are assumed not to increase power (pressure drops). */
*END		// PUMP
//=============================================================================
RECORD HEATPLANT "heatPlant" *RAT	// heating plant: contains BOILERs, serves HW coils in AH's, HX's in HPLOOPs
						// basAncs: input HpiB; run HpB.
    *declare "RC setup();"
    *declare "BOO hpOn();"					// turn on AVAIL heatplant: load calls. cnhp.cpp.
    *declare "RC hpEstimate(BOO wantHeat=FALSE);"		// estimate a heatplant, cnhp.cpp
    *declare "RC hpCompute();"				// compute a heatplant, cnhp.cpp
    *declare "void adjCapF();				// adjust capF for overload/underload. cnhp.cpp"
    *declare "void fazInit(int isAusz);"  				// cnhp.cpp  6-95
    *declare "void rddiInit();"						// cnhp.cpp 6-95
    *declare "void endP2Dsd();"						// cnhp.cpp 6-95
    *declare "RC hp_endAutosize();"					// cnhp.cpp  6-95
    *declare "BOO nxTu( TU *&tu);"				// 1st/next tu with hw coil served by hp, cnhp.cpp
    *declare "BOO nxAh( AH *&ah);"				// 1st/next ah with hw coil served by hp, cnhp.cpp
    *declare "BOO nxBlr( BOILER *&blr);"			// 1st/next boiler in hp, cnhp.cpp
    *declare "BOO nxBlrStg( BOILER *&blr, SI _stgi = -1);"	// 1st/next boiler in given or current hp stage, cnhp.cpp
    // in base class: .name (required), .ownTi (unused), more.
 //heatplant user inputs
    *h OFFAVAILONVC hpSched	// hourly choice of OFF, AVAIL (default; plant runs on demand), or ON (at least 1st stage runs).
    *f FRAC hpPipeLossF 	// pipe loss, default .01, fraction of largest stage boiler capac whenever any boiler running
 //heatplant user inputs: staging: 7 arrays, each of up to 7 boiler subscripts, or TI_ALL, or TI_ALLBUT and up to 6 subscripts
    *declare "#define NHPSTAGES 7		//number of hpStages"			// put preprocessor definition into rccn.h
              #define NHPSTAGES 7							// this copy for use here MUST MATCH
    *declare "#define HPSTAGESZ 8		//number+1 of boilers in a stage"	// put preprocessor definition into rccn.h
              #define HPSTAGESZ 8							// this copy for use here MUST MATCH
    *f *array HPSTAGESZ TI hpStage1    *f *array HPSTAGESZ TI hpStage2    	// defaulted by code, if NO hpStage values entered:
    *f *array HPSTAGESZ TI hpStage3    *f *array HPSTAGESZ TI hpStage4		// ... stage 1: TI_ALL. stages 2-7: none (0).
    *f *array HPSTAGESZ TI hpStage5    *f *array HPSTAGESZ TI hpStage6
    *f *array HPSTAGESZ TI hpStage7
    //CAUTION: code may access stages by subscripting, assuming they follow hpStage1 in order.
    //CAUTION: code uses internal subscript values 0-6 to access variables named hpStage1-7.
 //heatplant setup time
    *r TI blr1			// subscript of 1st BOILER for this HEATPLANT. Next is BOILER.nxBlr4hp.
    *r TI tu1			// subscript of 1st TU with HW coil served by this HEATPLANT. Next is TU.tuhc.nxTu4hp.
    *r TI ah1			// subscript of 1st AH with HW coil served by this HEATPLANT. Next is AH.ahhc.nxAh4hp.
    *r TI hl1			// subscript of 1st HPLOOP with HX for this HEATPLANT
    *r DBL /*POWER*/ qPipeLoss			// pipe loss power: hpPipeLossF * capStg[stgMxQ]
    *r *array NHPSTAGES DBL /*POWER*/ stgCap	// max power output of stages 0-6: boiler caps + pump heats.
    *r *array NHPSTAGES DBL /*POWER*/ stgPQ	// pump heats of stages 0-6.
    *r SI stgN					// max+1 used stage subscript 1-7 (used stages need not be contiguous)
    *r SI stgMxQ   				// most powerful stage subscript 0-6
 //heatplant runtime
    *s *e BOO hpClf		// call-flag: set nz if must call hpCompute so it can test tr, etc to see if computation needed.
    *s *e BOO hpPtf		// compute-flag: set if must call hpCompute and it should unconditionally recompute this plant.
    *s *e OFFONCH hpMode	// mode this subhour: off or on: per hpSched; per demand for AVAIL. Set in hpEstimate, hpCompute.
    *s *e DBL /*FRAC*/ capF	// 1.0 or, when overloaded, derating fraction for capacity of each coil/hx.
    *s *e SI  stgi		// stage in use, 0-6 for hpStage1-7.
    // for heatplant loop temp is not simulated; plant output and coil load q are always same and same variable used.
    *s *e DBL /*POWER*/ qNx	// latest coil/hx load, copied to .q at decision to compute, else may remain slightly different.
    *s *e DBL /*POWER*/ q	// current output, total from boilers & boiler pumps === total load of connected coils & hx's.
    // autoSizing
    *s *e FLOAT qPk		// peak load re error autosizing overload message
    *s *e FLOAT qPkAs		// peak load on a converged autoSizing design day re error autosizing overload message
 //prior values for runtime change-detection
    *s *e OFFONCH hpModePr
    *s *e POWER qPr
    *s *e POWER capFPr
*END					// HEATPLANT
//=============================================================================
RECORD BOILER "boiler" *RAT		// boiler: subobject of HEATPLANT. basAncs: input BlriB; run BlrB.
    *declare "RC setup();"
    *declare "RC endSubhr();"
				// in base class: .name (required), .ownTi (subscript of owning HEATPLANT), more.
 //boiler user inputs
    *f POWER_GZ blrCap		// capacity (Btuh). required input.
    *f FRAC_GZ  blrEffR		// efficiency at steady-state full load, default .80.
    *f FLOAT    blrEirR		// Energy Input Ratio (1/eff): alternate input; used internally.
    *f *nest PYCUBIC blrPyEi	/* coefficients of cubic polynomial fcn of plr (part load ratio) to adjust full load energy input
    				   for part load operation. 4 floats for coeffs of plr^ 0, 1, 2, 3. */
    *i TI mtri			// subscript of MTR to which to charge boiler input power, default none
    *f *nest PUMP blrp		// boiler primary pump subrecord (defn above): input & setup members. Pump runs when boiler is on.
 //boiler auxiliaries user inputs, similar to those for a COIL.
    *h POWER_GEZ auxOn		// addl input energy used in proportion to plr when on, default 0, hourly vbl for future flexblty.
    *i TI auxOnMtri		// MTR to which to charge "auxOn"
    *h POWER_GEZ auxOff 	// addl input energy when off for part or all of subhr (proportional to 1-plr), for unforseen uses.
    *i TI auxOffMtri		// MTR for "auxOff"
    *h POWER_GEZ auxOnAtall	// addl input energy used in toto when blr on for any part of subhour, for unforseen uses.
    *i TI auxOnAtallMtri	// MTR for "auzOnAtall"
    *h POWER_GEZ auxFullOff  	// additional input energy when off FOR ENTIRE SUBHOUR (as opposed to in proportion to 1-plr).
    *i TI auxFullOffMtri	// MTR to which auxFullOff is charged, default c.mtri.
 //boiler setup time
    *r TI nxBlr4hp		// 0 or subscript of next boiler for same heatplant. 1st is HEATPLANT.blr1.
    *r BOO used		// during input checking (cncult6.cpp), TRUE if a stage uses this boiler
 //boiler runtine
    *s *e OFFONCH blrMode	// mode this subhour: off or on. Can be on with 0 q if in HEATPLANT's 1st stage.
    *s *e FRAC  plr		// part load ratio
    *s *e POWER q		// current output power level (excluding pump heat), share of total of connected coils & hx's
    *s *e POWER p		// current input power
    *s *e POWER pAuxOn   	// blr-on proporotinal aux power this subhour
    *s *e POWER pAuxOff  	// blr-off proportional aux power this subhour
    *s *e POWER pAuxOnAtall	// blr on-at-all aux power this subhour
    *s *e POWER pAuxFullOff	// auxFullOff power this subhour
*END		// BOILER

//=============================================================================
RECORD COOLPLANT "coolPlant" *RAT	// coolplant: Top object, contains chillers, supports CHW coils in AH's. CpiB, CpB.

    *declare "RC setup();"
    *declare "BOO cpOn();"
    *declare "RC cpEstimate(BOO wantCool=FALSE);"
    *declare "RC cpCompute();"
    *declare "DBL/*POWER*/ capStg();"
    *declare "BOO nxAh( AH *&ah);"
    *declare "BOO nxCh( CHILLER *&ch);"
    *declare "BOO nxChStg( CHILLER *&ch, int _stgi=-1);"

    // in base class: .name, .ownTi, more. Name required, for reference from coil.

//COOLPLANT user inputs
    *h OFFAVAILONVC cpSched	// schedule, hourly choice of OFF, AVAIL (default), ON.
    *h TEMP cpTsSp		// supply temp cooling setpoint, hourly variable, default 44.
    *f FRAC cpPipeLossF 	/* pipe "loss": heat gain equal to this fraction of largest stage <-- CHANGE **
    				   capacity will be used in any subhour when any chiller runs. default .01. */
    *i TI cpTowi		// subscript of TOWERPLANT supporting this COOLPLANT. Input as name "cpTowerplant". RQD.
//COOLPLANT stages: 7 arrays, each input as list of up to 7 chiller names, or ALL_BUT, comma, and up to 6 names, or ALL.
//Internally, subscripts, TI_ALLBUT, and TI_ALL are stored, with 0 after and of lists (poss garbage after TI_ALL).
    *declare "#define NCPSTAGES 7		//number of cpStages"			// put preprocessor definition into rccn.h
              #define NCPSTAGES 7							// this copy for use here MUST MATCH
    *declare "#define CPSTAGESZ 8		//number+1 of chillers in a stage"	// put preprocessor definition into rccn.h
              #define CPSTAGESZ 8							// this copy for use here MUST MATCH
    *f *ARRAY CPSTAGESZ TI cpStage1    *f *ARRAY CPSTAGESZ TI cpStage2    	// defaulted by code, if NO cpStage values entered:
    *f *ARRAY CPSTAGESZ TI cpStage3    *f *ARRAY CPSTAGESZ TI cpStage4		// ... stage 1: TI_ALL. stages 2-7: none(0).
    *f *ARRAY CPSTAGESZ TI cpStage5    *f *ARRAY CPSTAGESZ TI cpStage6
    *f *ARRAY CPSTAGESZ TI cpStage7
    //CAUTION: code may access stages by subscripting, assuming they follow cpStage1 in order.
    //CAUTION: code may use internal subscript 0-6 to access variables named cpStage1-7. Potentially confusing!

//COOLPLANT setup time
    *r TI ch1				// subscript of 1st CHILLER in this COOLPLANT. Next is CHILLER.nxCh4cp.
    *r TI ah1				// subscript of 1st AH with CHW coil served by this COOLPLANT. Next is AH.ahcc.nxAh4cp.
    *r TI nxCp4tp			// subscript of next COOLPLANT using same TOWERPLANT. 1st is TOWERPLANT.c1.
    *r DBL /*MFLOW*/ mwDsCoils		// sum of dsgn flows of connected CHW coils, accum by COOLCOIL::setup, for check vs pumps.
    *r *array NCPSTAGES FLOAT /*POWER*/ stgPPQ	// primary pump heats of stages 0-6.
    *r *array NCPSTAGES FLOAT /*POWER*/ stgCPQ	// condenser pump heats of stages 0-6.
    *r *array NCPSTAGES FLOAT /*MFLOW*/ stgPMw 	// primary pump flows of stages 0-6.
    *r *array NCPSTAGES FLOAT /*MFLOW*/ stgCMw	// condenser (heat rejection) pump flows of stages 0-6, lb/hr
    // note there is no array of capacities cuz depend on ts and tCnd, must recompute as needed.
    *r SI stgN					// max+1 used stage subscript 1-7 (used stages need not be contiguous)
    *r SI stgMxCap   				// subscript 0-6 of stage with most design power
    *r DBL /*POWER*/ mxCapDs			// design power of most powerful stage (negative)
    *r DBL /*MFLOW*/ mxPMw			// largest primary pump flow, for computing minimum delta-t at runtime
    *r DBL /*MFLOW*/ mxPMwOv			// primary pump flow w/ overrun of stage with most design power, for check vs coils
    *r DBL /*POWER*/ mxCondQ			// max design rejected heat (positive), re defaulting TOWERPLANT capacity
    *r DBL /*MFLOW*/ mxCondGpm			// condenser pump flow of same stage (not verified largest), gpm: input value
    *r DBL /*POWER*/ qPipeLoss			// pipe "loss" power: cpPipeLossF * mxCapDs. Negative.

//COOLPLANT runtime: outputs to other objects
    *s *e DBL /*TEMP*/  cpTs	// primary water supply temp to coils. cp- to not confuse with AH::ts when used re coil.
    *s *e DBL /*POWER*/ q	// current primary output power to coils, for results
    *s *e DBL /*POWER*/ qTow	// heat added to condenser water, incl pump heat, Btuh.
    *s *e DBL /*TEMP*/  tTow	// temp of water returned from chiller condensers, avail to towerplant (not used 10-92).
    *s *e DBL /*MFLOW*/ mwTow	// condenser water flow to towerplant, lb/hr. stgCMw[stgi].
    //power consumption: occurs in chillers, is posted directy to meters.
//COOLPLANT runtime: input from other objects
    *s *e DBL /*TEMP*/ tCnd	// heat rejection: water temp entering chiller condensers, last used TOWERPLANT.tpTs.
				// also used as this cp's prior tpTs for change detection.
//COOLPLANT runtime: internal
    *s *e BOO cpClf		// call-flag: set nz if must call cpCompute so it can test tr, etc to see if computation needed.
    *s *e BOO cpPtf		// compute-flag: set if must call cpCompute and it should unconditionally recompute this plant
    *s *e OFFONCH cpMode	// mode this subhour: off or on: per cpSched; per demand for AVAIL. Set in cpEstimate, cpCompute.
    //cpCompute next input(s), calculated at entry to tpCompute before commitment to new calculation:
     *s *e DBL /*POWER*/ qLoadNx	// heat added to water by loads. Negative. Believe need in rec only for debug/reporting.
    //cpCompute current input(s), as used for current cpTs. -Nx('s) copied, after decision to calculate anew.
     *s *e DBL /*POWER*/ qLoad	// load: sum of coil Btuh's, pipe loss. Negative. May be used in cpEstimate.
    *s *e DBL /*TEMP*/  tr	// load: return water temp from coils, incl pipe loss, assuming no mw overrun.
    *s *e SI  stgi		// stage in use, 0-6 for cpStage1-7.
    *s *e DBL /*POWER*/ qNeed	// power needed from coolPlant to deliver water at setpoint: (cpTsSp - tr) * mw[stg]. negative.
    *s *e DBL /*POWER*/ cap	// curr capac of stgi chillers @ ts & tCnd, Btuh, incl pump heat, set by capStg().
    *s *e DBL /*FRAC*/ plr  	// part load ratio
    *s *e DBL /*TEMP*/ puteTs	// cpCompute's supply temp: cpTs, but not overwritten by cpEstimate, for debug aid/probes/reports.
//runtime internal: Pr's: prior values for runtime change-detection
    *s *e TEMP  cpTsSpPr  	// for cpEstimate
    *s *e TEMP  cpTsEstPr	// for cpEstimate
    *s *e OFFONCH cpModePr	// for cpCompute
    *s *e TEMP  trMxPr		// for cpCompute: tr-assuming-max-flow when last computed
    *s *e POWER qLoadPr 	// for cpCompute
    *s *e MFLOW mwTowPr  	// for cpCompute, set by tpCompute
    *s *e POWER tTowPr  	// for cpCompute, set by tpCompute
*END				// COOLPLANT

//=============================================================================
RECORD CHILLER "chiller" *RAT	// chiller. subobject of COOLPLANT. ChiB, ChB.

    *declare "RC setup();"
    //chiller compute code is in coolplant.
    *declare "RC endSubhr();"

    // in base class: .name, .ownTi, more.
    // .name required, for reference in coolplant staging commands.
    // .ownTi is owning coolplant subscript

//CHILLER Capacity user inputs. Capacity at various temp conditions is cap = chCapDs*chPyCapT(ts,tcnd).
    // Note Niles chlrType deleted per Taylor (via Bruce), defaults hard-coded to HERM_CENT case.
    *f POWER_NZ chCapDs		// capacity at chDsTs,chDsTcnd, Btuh. Required. Negative internally. Niles capDsn.
//    verify defaults 44 and 85 should be described as ARI in doct'n. *****
    *f TEMP_GZ  chTsDs		// temp leaving chiller at which chCapDs applies, default 44. Niles twSuDsn.
    *f TEMP_GZ  chTcndDs	// temp entering condenser (twoDel value) for chCapDs, default 85. Niles twCndDsn.
    *r *nest PYBIQUAD chPyCapT 	/* biquad poly (6 float coeffs entered) of (chTs, chTcnd) to adjust capacity to off-design temps.
    				   Niles capNrCr. Normalized @ chTsDs/chTcndDs; Niles' capRat not used.
    				   Defaults: -1.742040,.029292,-.000067,.048054,-.000291,-.000106 or as changed, cncult6.cpp. */
//CHILLER Full-load energy Input Inputs. Full-load power input at various temp conditions is eiFL = cap*chEirDs*chPyEirT(ts,tcnd).
    *f FLOAT_GZ chCop		/* Full-load Coefficient of performance (output Btu/input Btu) @ chTsDs/chTcndDs, reflecting
				   motor and chiller efficiency. No such Niles input. Converted to chEirDs for internal use.
				   Default: current minimum erriciency, Bruce to look up ??, meanwhile can use 3 for testing. */
    *r FLOAT_GZ chEirDs		/* Full-load eir (energy input ratio) @ chTsDs/chTcndDs, relecting motor and chiller efficiency.
    				   Alternate input for chCop; used internally; replaces Niles' eirR (eir at ARI conditions). */
    *r *nest PYBIQUAD chPyEirT 	/* biquad poly (6 float coeffs input) of (chTs, chTcnd) to adjust full-load energy input to
    				   off-rated temperature conditions, Niles eirNrCr. 1.0 @ chTsDs/chTcndDs.
    				   Defaults: 3.117600,-.109236,.001389,.003750,.000150,-.000375 (or as changed, cncult6.cpp). */
/*CHILLER part-load energy Input Inputs. Part-load energy input (ei) is full-load-energy-input (eiFL, above) corrected as follows:
  In unloading region,  1 >= plr > chMinUnldPlr, ei is curve given by polynomial
        ei = eiFl * chPyEirUl(plr);
  In false loading region, chMinUnldPlr >= plr >= chMinFsldPlr, energy input is constant.
        ei = eiFl * chPyEirUl(chMinUnldPlr);                  nb no plr dependence
  In cycling region, chMinFsldPlr > plr >= 0, ei is prorated (eir remains constant).
        ei = eiFl * chPyEirUl(chMinUnldPlr)*plr/chMinUnldPlr.
  The value "chPyEirUl(chMinUnldPlr)" is constant and will be precomputed at setup time.
  Niles name "eirPlrCr" for the above 3-case part load correction factor is not used in record. */
    *r *nest PYCUBIC chPyEirUl	/* cubic poly (4 floats input for coeff) of plr to correct eir for plr in unloading range
    				   (1 >= plr > chMinUnldPlr). Niles eirUnldCr. Defaults:.222903,.313387,.463710,0. (cncult6.cpp). */
    *f FRAC chMinUnldPlr  	// min unloading loading part load ratio, default 0.1. Niles minUnLdPlr.
    *f FRAC chMinFsldPlr  	// min false loading part load ratio, default 0.1. Niles minFsLdPlr. must be <= chMinUnldPlr.
//CHILLER user inputs...
    *f FRAC_GZ chMotEff		/* motor efficiency (poorly named), default 1.0, Niles motorEff, used only to determine
    				   portion of input energy computed as above that goes to the air rather than the condenser.
    				   1.0 simulates hermetic compressor where all motor waste heat goes to condenser;
    				   use smaller values for open systems. */
    *i TI mtri			/* METER name ("chMtr") for accumulating compressor energy used by chiller,
				   under category AUX. Default: not recorded. Note pumps have their own meters. */
    *f *nest PUMP chpp  	/* chiller primary pump: pumps water through primary loop to which the load (CHW coils)
     				   is connected. Flow is unsimulated, but assumed to be at least chppGpm=chpp.mw whenever
     				   chiller is on (any excess over coil flows goes thru an assumed bypass valve); if flow
     				   overruns this amount, it is assumed that the (unsimulated) pressure drops such that the
     				   pump electrical input and heat do not change. Subrecord inputs include: */
    //chppGpm	 gpm > 0	Primary pump flow. Default chCapDs/5000.  Niles mwPrmPmp.
    //chppHdlos	 ft H2O	>= 0	Head loss in primary chilled water loop. default 65. Niles hdLosPrmLp.
    //chppMotEff frac > 0	Primary pump motor efficiency, default .88.  Niles mtrEfPrmPmp.
    //chppHydEff frac > 0	Hydraulic efficiency of primary pump, default .70 . Niles hydEfPrmPmp.
    /*chppOvrunF factor	> 1	Maximum multiple of chppMw that pump can deliver at (assumed) pressure reduction,
				and at same electrical input. default 1.3. CSE currently does not simulate primary flow
				at run time, but will issue a warning if the sum of the flows of the connected CHW coils
				exceeds the sum of the COOLPLANT's most powerful stage's chppGpm*chppOvrunF products. */
				//Drop this input if not checking coil capacity vs pumping capacity 10-92.
    //chppMtr .mtri  name of a METER	for recording electricity used by pump, category AUX.
    *f *nest PUMP chcp		/* chiller heat rejection (condenser) pump: pumps water through chiller's condenser and
    				   the chiller's coolplant's towerplant's cooling towers. Flow is chcpGpm=chcp.mw
    				   whenever chiller is on. Subrecord inputs include the following: */
    //chcpGpm	gpm > 0		Condenser pump flow, default chCapDs/4000, Niles mwCndPmp.
    //chcpHdlos	ft H2O >= 0	Head loss in condenser chilled water loop, default 45', Niles hdLosCndLp.
    //chcpMotEff frac > 0	Condenser pump motor efficiency, default .88, Niles mtrEfCndPmp.
    //chcpHydEff frac > 0	Hydraulic efficiency of condenser pump, default .70, Niles hydEfCndPmp.
    //chcpMtr	.mtri  name of a METER	for recording electricity used by pump, category AUX.
//CHILLER auxiliaries user inputs, similar to those for a BOILER or a COIL.
    *h POWER_GEZ auxOn		// addl input energy used in proportion to plr when on, default 0, hourly vbl for future flexblty.
    *i TI auxOnMtri		// MTR to which to charge "auxOn"
    *h POWER_GEZ auxOff 	// addl input energy when off for part or all of subhr (proportional to 1-plr), for unforseen uses.
    *i TI auxOffMtri		// MTR for "auxOff"
    *h POWER_GEZ auxOnAtall	// addl input energy used in toto when chiller on for any part of subhour, for unforseen uses.
    *i TI auxOnAtallMtri	// MTR for "auxOnAtall"
    *h POWER_GEZ auxFullOff  	// additional input energy when off FOR ENTIRE SUBHOUR (as opposed to in proportion to 1-plr).
    *i TI auxFullOffMtri	// MTR to which auxFullOff is charged, default c.mtri.

//CHILLER setup time variables
    *r TI nxCh4cp		// 0 or subscript of next CHILLER in same COOLPLANT. 1st is COOLPLANT.ch1.
    *r BOO used		// non-0 if a COOLPLANT uses this chiller -- else warning
    *r DBL eirMinUnldPlr	// chPyEirUl(minUnldPlr): precomputed energy input corr for false loading, prorate for cycling

//CHILLER runtime internal variables
    *s *e OFFONCH chMode	// C_OFFONCH_OFF or _ON: whether this chiller is running, set by staging code.
    *s *e DBL /*POWER*/ cap	// capacity @ current cpTs and tCnd, set only if running
//CHILLER runtime outputs. Pri water ts, towerplant water q & temp, etc. are computed directly into COOLPLANT members.
    *s *e POWER q 		// this chiller's current primary output power to pri loop
    *s *e POWER p 		// compressor power input. also see chpp.p, chcp.p. (Niles cndPmpPwrIn, prmPmpPwrIn, totPwrIn)
    *s *e POWER pAuxOn   	// chiller-on proporotinal aux power this subhour
    *s *e POWER pAuxOff  	// chiller-off proportional aux power this subhour
    *s *e POWER pAuxOnAtall	// chiller on-at-all aux power this subhour
    *s *e POWER pAuxFullOff	// auxFullOff power this subhour
*END		// CHILLER

//=============================================================================
RECORD TOWERPLANT "towerPlant" *RAT	// cooling tower(s) plant: supports COOLPLANTs, HPLOOP hx's. TpiB, TpB.

    *prefix twr_

    // in base class: .name, .ownTi, more.
    // Name required, for reference in COOLPLANTs and/or HPLOOPs

    *declare "RC   setup();"			// cncult6.cpp
    *declare "RC   setupNtuADs();"			// cncult6.cpp
    *declare "RC   setupNtuAOd();"			// cncult6.cpp
    *declare "RC   tpEstimate();"			// cntow.cpp
    *declare "RC   tpCompute();"			// cntow.cpp
    *declare "RC   endSubhr();"			// cntow.cpp
    *declare "RC   findSpeed( DBL _q);"					// cntow.cpp
    *declare "RC   varSpeedF( DBL qWant, DBL &_f, DBL &_q, FLOAT &guess);"	// cntow.cpp
    *declare "RC   towModel( DBL _f, DBL &_q, FLOAT &guess);"			// cntow.cpp
    *declare "BOO  nxCp( COOLPLANT *&cp);"					// cntow.cpp
#if 0 // when HPLOOP defined, 10-92
*    *declare "BOO TOWERPLANT::nxHl( HPLOOP *&hl);"					// cntow.cpp.
#endif

//towerplant user inputs
    *f SI_GZ ctN		// Number of towers. Niles' ctNo.  default 1.
    *f TPSTGCH tpStg		/* staging choice, default TOGETHER. Niles' stgOp.
				   TOGETHER  Towers are identical and all towers will operate at once
					     at the same load (fan speed or cycling fan duty cycle).
				   LEAD      A "lead tower" will modulate, and as many additional one-speed
					     tower fans as necessary to meet the load will run at full power.
 					     The water will continue to flow through the towers whose fans are off. */
    *h TEMP_GZ tpTsSp    	// Towers delivered water setpoint temperature (Niles' twoSp).  degrees F, hourly, default 85F.
    *i TI tpMtr   		/* subscript of METER object to which tower fan energy input will be posted,
    				   category "Aux" (Per Bruce, 8-92).  Cooling towers as modelled have no pumps
    				   and use no energy except to drive their fans. default none. */
 //If towStg is LEAD, the following two apply only to the lead tower; any additional towers are assumed to have ONESPEED fans.
    *f CTTYCH ctTy		// Cooling tower fan control type choice: ONESPEED (default), TWOSPEED, or VARIABLE.
    *f FRAC_GZ ctLoSpd     	// Low speed for a TWOSPEED fan, as a fraction of full cfm. default 0.5.
/*The rest of the TOWERPLANT input variables apply to each tower in the group;
  the towers are assumed identical except for the single-speed fan on non-lead towers. */
/*The following two inputs permit computation of the tower fan electrical energy
  consumption (we only need bhp/eff, but Bruce/Steve say use two inputs): */
    *f BHP_GZ ctShaftPwr  	/* Shaft power of one tower fan motor. RQD.  User name 'shaftBhp'.
    				   Btuh internally, brake horsepower entered, units stuff converts. */
    *f FRAC_GZ ctMotEff  	// Motor (and drive, if any) efficiency, default 0.88
/* TOWERPLANT fan curve coefficients. Constant-speed (cycling) fan consumption is linear fcn of
   avg speed (===frac of time on for one-speed); constant represents start-stop overhead. */
    *r *nest PYLINEAR ctFcOne	// ONESPEED tower fan curve coefficients, also for nonLead towers if ctStg = LEAD.  default 0, 1
    *r *nest PYLINEAR ctFcLo	// TWOSPEED low speed fan curve coeffs, default 0, ctLoSpd^2
    *r *nest PYLINEAR ctFcHi	// TWOSPEED high speed fan curve coeffs, default -ctLoSpd*(ctLoSpd+1), ctLoSpd^2+ctLoSpd+1
    *r *nest PYCUBIC  ctFcVar	// VARIABLE speed fan cubic curve coefficients, default 0,0,0,1
/* The next 6 TOWERPLANT members specify one-tower performance under a one set of conditions (the "design conditions").
   The conditions should be chosen to be representative of full load operating conditions. */
    // verify next 3 per tower?? <--- issues2.txt memo sent to Bruce 10-92. *****
    *r POWER_NZ ctCapDs		/* Design capacity, Btuh. (replaces Niles' design water inlet temperature.)
				   Default is sum of connected loads / ctN, using largest stage in each coolPlant,
				   design Btu capacity of each HPLOOP heat exchanger. Made negative if entered positive. */
    *f AFLOW_GZ ctVfDs   	// Design air flow volume rate through tower / full speed fan flow??, cfm, RQD.
    *r H2OFLOW_GZ ctGpmDs	// Design water flow rate, gpm. default: sum of connected heat rejection pump capacities / ctN.
    *f TEMP_GZ ctTDbODs 	// Design outdoor drybulb temperature, F, RQD. (only needed to convert ctVfDs from cfm to lb/hr).
    *f TEMP_GZ ctTWbODs   	// Design outdoor wetbulb temperature, F, RQD.
    *f TEMP_GZ ctTwoDs    	// Design leaving water temperature, F, default 85.
/* The following 6 TOWERPLANT members give another one-tower performance point, the "Off-design" point.
   Either give either all that don't have defaults, (and not ctK), or none (ctK may then be given). */
    // verify next 3 per tower?? <--- issues2.txt memo sent to Bruce 10-92. ******
    *r POWER_NZ ctCapOd   	/* Off-design capacity, Btuh. (replaces Niles' design water inlet temperature.)
				   Default is sum of connected loads / ctN, using largest stage in each coolPlant,
				   design Btu capacity of each HPLOOP heat exchanger. Made negative if entered positive. */
    *f AFLOW_GZ ctVfOd   	// Off-design air flow volume rate through one tower, cfm, must != ctVfDs.
    *r H2OFLOW_GZ ctGpmOd	/* Off-design water flow rate, gpm. default: sum of connected heat rejection pump capacities/ ctN.
    				   must differ from ctGpmDs (can't default both). */
    *f TEMP_GZ ctTDbOOd 	// Off-design outdoor drybulb temperature, F. (only needed to convert ctVfOd from cfm to lb/hr).
    *f TEMP_GZ ctTWbOOd   	// Off-design outdoor wetbulb temperature, F.
    *f TEMP_GZ ctTwoOd    	// Off-design leaving water temperature, F, default 85.
// TOWERPLANT inputs...
    *r FRAC_GZ ctK		// exponent in formula  ntuA = const * (mw/ma)^ctK, as alternative to "off design" inputs.
    				// default: derived from "Od" inputs if given, else .4.
    *f FRAC ctStkFlFr   	/* stack effect flow: air flow that occurs thru tower when fan is off, as a fraction of ctVfDs.
    				   Additional flow, when fan runs, is proportional to fan speed. default .18. */
// TOWERPLANT inputs re makeup water
    *f FRAC ctBldn 		// Blowdown rate: frac inflowing water bled down drain, to reduce impurities buildup. default .01.
    *f FRAC ctDrft		// Drift rate: frac inflowing water blown out of tower as droplets, w/o evaporating. default 0.
    *f TEMP_GZ ctTWm   		// Temperature of water in mains, for makeup water. default 60.
  // Auxiliaries desired? assume not 10-92.

// TOWERPLANT setup time members
    *r TI cp1			// subscript of 1st COOLPLANT served by this TOWERPLANT. Next is COOLPLANT.nxCp4tp.
    *r TI hl1			// subscript of 1st HPLOOP with hx served by this TOWERPLANT. Next is HPLOOP.nxHl4tp.
    *r DBL /*POWER*/ oneFanP	// full-speed motor input power for one fan (Btuh): ctShaftPwr / ctMotEff.
    *r DBL /*MFLOW*/ maDs	// design air flow into 1 tower, ctVfDs converted from cfm to lb/hr
    *r DBL /*MFLOW*/ maOd	// off-design air flow into 1 tower, ctVfOd converted from cfm to lb/hr
    *r DBL /*H2OFLOW*/ mwDs	// design water flow into 1 tower, ctGpmDs converted from gpm to lb/hr
    *r DBL /*H2OFLOW*/ mwOd	// off-design water flow into 1 tower, ctGpmOd converted from gpm to lb/hr
    *r DBL maOverMwDs		// maDs/mwDs, precomputed in setup.
    *r DBL ntuADs     		// number of transfer units for air side at design conditions (Niles ntuAd)
    *r DBL ntuAOd     		// .. at off-design conditions, if given. member only as debug aid.

// TOWERPLANT runtime output member
    *s *e DBL /*TEMP*/ tpTs   	// temperature of leaving water, F. For use by chillers and hploop hx's. Niles twoDel.
	            			    // set by tpEstimate and tpCompute. tp- to protect against confusion with AH::ts.

// TOWERPLANT runtime mostly-internal members
    *s *e BOO tpClf		// call-flag: set nz if must call tpCompute so it can test tr, etc to see if computation needed.
    *s *e BOO tpPtf		// compute-flag: set if must call tpCompute and it should unconditionally recompute.
    // tpCompute next inputs, calculated at entry to tpCompute before commitment to new calculation
    *s *e DBL /*TEMP*/  trNx	// return water temp, F
    *s *e DBL /*MFLOW*/ mwAllNx	// return water flow===total water flow entering towers, sum of loads, lb/hr.
    *s *e DBL /*POWER*/ qLoadNx	// heat added to water by loads. Positive. Believe need in record only for debugging/reporting.
    // tpCompute current inputs, as used for current tpTs. -Nx's copied to next 3 after decision to calculate anew.
    *s *e DBL /*TEMP*/  tr	// return water temp
    *s *e DBL /*MFLOW*/ mwAll	// return water flow (sum of loads)===total water flow into all towers, lb/hr.
    *s *e DBL /*POWER*/ qLoad	// heat added to water by loads. Positive. Believe need in record only for debugging/reporting.
    // tpCompute internal
    *s *e DBL /*MFLOW*/ mwi1	// flow into 1 tower (less flows out due to evaporation & drift): mwAll / ctN.
    *s *e DBL /*POWER*/ qNeed	// power needed from tower plant to deliver water at setpoint: (tpTsSp - tr) * mwAll. negative.
    *s *e DBL /*POWER*/ qMax1	// max power of 1 tower under current conditions
    *s *e DBL /*POWER*/ qMin1	// power of 1 tower, fan off (stack effect only) under current conditions
    *s *e TOWLOADCASE towldCase	/* tower load case, tpCompute to endSubhr: facilitates deferring fan power calc
				   tldMIN: fans off; tpTs <= setpoint
				   tldSP:  tpTs is at setpoint, must determine power
				   tldMAX: full power, tpTs >= setpoint */
    *s *e POWER qMaxGuess	// for internal values for towModel initial guess at next call for various towModel calls.
    *s *e POWER qMinGuess	// ..
    *s *e POWER qLoGuess	// ..
    *s *e POWER qVarGuess	// .., used via varSpeedF
    *s *e DBL /*POWER*/ qVarTem	// varSpeedF temporary that should be saved between calls (last q, used re initial f)
    *s *e DBL /*TEMP*/ puteTs	// tpTs from tpCompute, not set by tpEstimate. debug aid.

// TOWERPLANT runtime internal, set at end subhr. Variables believed local, here for probes/results/debugging
    *s *e SI  nCtOp		// number of tower fans operating
    *s *e DBL f			// fraction of full speed (fraction on for one speed fan), for lead tower only if LEAD.
    *s *e POWER fanP		// plant's fan input pwr this subhour (Btuh!)
    *s *e POWER q		// power imparted to water, for change detection/probes/reports 10-19-92

// TOWERPLANT runtime prior values for change detection
    *s *e TEMP  tpTsSpPr  	// for tpEstimate
    *s *e TEMP  tpTsEstPr	// for tpEstimate
    *s *e TEMP  twr_tpTsPr  // leaving water temp at last tpCompute, F (unused?)
    *s *e TEMP twr_tDbOShPr	// outdoor drybulb temp at last tpCompute, F
    *s *e HUMRAT twr_wOShPr	// outdoor humidity ratio at last tpCompute, F
*END		// TOWERPLANT

#if 0		// template
//=============================================================================
RECORD NAME "desc" *RAT
    // in base class: .name, .ownTi, more.
    ...
*END		// NAME
#endif

#if 0		// template
//=============================================================================
RECORD NAME "desc" *RAT
    // in base class: .name, .ownTi, more.
    ...
*END		// NAME
#endif

#if 0		// template
//=============================================================================
RECORD NAME "desc" *RAT
    // in base class: .name, .ownTi, more.
    ...
*END		// NAME
#endif

#if 0		// template
//=============================================================================
RECORD NAME "desc" *RAT
    // in base class: .name, .ownTi, more.
    ...
*END		// NAME
#endif

// for record handle of 0x0050 or over, recompile rcdef with larger MAXRCS, 10-94.

*END		// Marks overall end of cnrecs.def


// IF-OUTS ==========================================================

//=============================================================================
#if 0	//ifdef OLDNV // cndefns.h
o// ZNISUB nat vent user input (will change in CSE). Used: hscomp:hsnvinit()
o    *z AREA nvAHi   	// ahigh    Area of high vent (ft2)
o    *z AREA nvALo    	// alow     Area of low vent (ft2)
o    *z LEN nvHD     	// hdiff    Height difference (ft)
o    *z ANGLE nvAzmI	// azminlet True azimuth of inlet (deg, 0=north) ***
o    *z FRAC nvStEM 	// steffm   Stack effectiveness multiplier
o    *z FRAC nvDdEM 	// ddeffm   Direction-dependent effectiveness mult.
o    *z FRAC nvDiEM 	// dieffm   Direction-independent effectiveness mult.
o    *z TEMPDIFF nvTD 	// tdiff    Min out-zone temp diff to vent. Set:crsimzn.cpp.
o			   Normally 0 to vent only if cooler outdoors.
o			   < 0 lets allows vent even if heats zone: << 0 used for uncontrolled vents eg cr's CVCs.
o			   > 0 would hold zone warmer than out (CAUTION as now coded 1-90 wd also prevent fanvent). */
o    /* note: addl historical nat vent input info that was never used (only _INDOOR strategy implemented),
o     * deleted 1-91 as have no choice type sharable between tk and CSE.
o     * CONTROL control	* Type of controls on vent, dt VENTCON, C_VENTCON_INDOOR, _SEASONAL, _OUTDOOR, _OPEN *
o     * FLOAT topen 	* Open temp for _OUTDOOR *
o     * FLOAT trange	* Throttling range for _OUTDOOR */
#endif
#ifdef OLDFV
o// ZNISUB fan vent user inputs.  used in hscomp:hsfvinit and as noted.
o    *z AFLOW fvCfm	// cfmmax   Max. cfm of fan system (cfm)
o    *z KW fvKW		// kW 	    elec power for fan (kW, internally Btuh)
o    *z FRAC fvFz     	// fQ2Zn    frac .kW to supply air (0 if exhaust fan)
o    *z FRAC fvDECeff	// direct evaporative effectiveness.  hshour.cpp uses.
o    *z FRAC fvIECeff	// indirect evaporative effectivness.  hshour.cpp uses.
o    *z TEMPDIFF fvTD	// tdiff    Min allowed approach (F). hshour.cpp uses.
o    *z TEMP fvWbMax	// wbmax    No vent if wb > this (F).  I think always 1000 to disable, 1-90. hshour.cpp uses.
#endif
#ifdef OLDCF
o// ZNISUB ceiling fan user inputs.  Set in crsimzn.cpp or hstest.cpp.
o    *z KW cfKW		// kW 	    elect power for fan (kW, internally Btuh)
o    *z FRAC cfFz    	// fQ2Zn    frac fan power to zone (always 1?)
#endif
//=============================================================================
#undef OLDAT		// define to restore (some of) old AHU-TUX code, needed for cnold.exe link. Also in h\cnglob.h. 5-92.
#if 0	//ifdef OLDAT
o// ZNR runtime hvac internal, mostly hourly, OLD 3-92
o
o    // OLD loads a's and b's now used only
o    *s *e *hide DBL aqSo  	// set-output hvac part of 'a': sum of set output lh q's and ah cz*Ts's.
o    *s *e *hide DBL bSo   	// ==cSo.  set-output hvac part of 'b': sum of So ah tu cz's (zone flows).
o    *s *e *hide DBL aqStO	// set-temp inactive-zhx part of 'a' for md: pegged lh q's and ah cz*Ts's (xxx mdSeq[md].aqStO).
o    *s *e *hide DBL bStO 	// ==cStO.  set-temp inactive-zhx part of 'b': sum of ia St ah tu cz's (flows) (xx mdSeq[md].bStO).
o
o    //*h SI nxMd			// # of modes currently defined (i.e. # of active entries mdxSeq[])
o    *h *array MAX_ZONEMODES	// (=21, cndefns.h).  (TI mdxSeq[ MAX_ZONEMODES])
o       SI mdxSeq    		// mode sequence table built, drives simulation process.
o    //*h *hide FLOAT sxQCT   	/* total zone gain from set output TUs (Btuh); sum( set output lhQ) + sum( set output c*tsu)
o    //				   set out of cghinit, note 2. */
o    *h *hide *array MAX_ZONEMODES	// (=21, cndefns.h).  set out of cghinit, note 2.
o       FLOAT mdxQCT		// sum zone gain from tstat controlled TUs by mode (Btuh); analogous to sxQCT just above.
o    //*h *hide FLOAT sxC		/* total zone cap rate from set output TUs (Btuh/F); sum( set output c)
o    //				   set out of cghinit, note 2. */
o    *h *hide *array MAX_ZONEMODES	// (=21, cndefns.h)
o       FLOAT mdxC		// sum zone cap rate from tstat controlled TUs by mode (Btuh/F). set out of cghinit, note 2.
o    //*s *e SI mdx 		// mode at end of last substep
#endif	// OLDAT
// ZNR: old setup time
#ifdef OLDNV
o// ZNR nat vent derived values, used in hshour.cpp:
o    // set in hstest/crsimzn/cncult:
o    *r SI natvflg          // TRUE if nat vent avail in zn
o    // setup time info, set by hscomp:hsnvinit():
o    *r FLOAT dieff 	// Direction-independent effectiveness
o    *r SI iazm 		// Inlet azimuth as integer, for hourly use
o    *r FLOAT fwind 	// Factor for calculating wind component
o    *r FLOAT fstack        // Factor for calculating stack component
o    // set by hscomp:hsnv*h*fnit():
o    *h FLOAT chour 	// Hourly coefficient
#endif
#ifdef OLDFV
o// ZNR fan vent derived values, used in hshour.cpp
o    // set in cncult.cpp:
o    *r SI fanvflg  	// fan vent avail flag: 0=none, 1=vent, 2=dir evap, 3=ind evap, 4=ind/dir evap.
o    // set in hscomp:hsfvinit:
o    *r FLOAT tRise 	// supply temp rise due to fan power (derived from cfmmax, kwmax, and fQ2Zn)
o    *r FLOAT havmax 	// Max heat xfer, ie 1.08*cfmmax (Btuh/F)
o    // set/used in hshour.cpp: fan/evap vent supply temps, current hour:
o    *h FLOAT tsfv   	//   lowest dry bulb achievable with all stages
o    			//   supply air state with 1st stage only (meaningful iff fanvflg==4):
o    *h FLOAT tsfv1   	//      dry bulb
o    *h FLOAT wbsfv1  	//      wet bulb
#endif
#ifdef OLDCF	// no CF code
o// ZNR ceiling fan value derived in crsimzn/hstest:
o    *h? *e? FLOAT qZone 	// heat gain to zone (Btuh) used in hshour.cpp.
o    *s? *e? SI ceilFanFlg 	// 0: no ceiling fan, 1: did not run last step, 2: ran last step
#endif
// znr: old runtime: loads
#ifdef OLDNV // cndefns.h
o    *h SI natvposs         /* TRUE if nat vent poss this hr, hshinit to hshour */
#endif
#ifdef OLDFV
o    *h SI fanvposs 	/* TRUE if fan vent poss this hr, ditto (hshour.cpp) */
#endif
#if defined(OLDNV) | defined(OLDFV)
o    *h SI ventposs 	/* TRUE if either fan or nat. is possible, ditto */
#endif
#ifdef OLDNV
o    *h SI natvsetup 	/* TRUE if natv has been set up for this hour */
o    *h FLOAT natvhavsp 	/* Nat. vent. heat xfer available this hour if zone were at vent set point (Btuh/F) */
o    *h FLOAT natvhav 	/* Nat. vent heat xfer available at end of last sub timestep (Btuh/F) */
o    *h FLOAT natvdt 	/* Nat. vent delta-T, set point to DB (F) */
o		/* next 2 are warmer of desired temp, vent supply temp (not user settings). hshinit to hshour (hshour.cpp) */
o    *h FLOAT tnatv 	/* Cur hr nat vent stpt, F; Huge if nat vnt not poss*/
#endif
#ifdef OLDFV
o    *h FLOAT tfanv 	/* Cur hr fan vent stpt, F; Huge if fn vnt not poss */
#endif

//=============================================================================
#if 0	//ifdef OLDAT				// OLD 3-92
o RECORD AHUX "ahu" *RAT	// Air handler: currently dummy source of infinite amount of air at a given temp.  10-11-91.
o #ifndef BCPP
o     *hide DBN bn	// dummy
o     *z ANAME name	// for LIKEing etc
o #endif
o     *h TEMP ahuxTsu		// supply temperature (hourly variability)
o *END			// AHUX
#endif
//=============================================================================
#if 0	//ifdef OLDAT				// OLD 3-92
o RECORD TUX "terminal" *RAT		// OLD TERMINAL 3-92
o 	/* Terminal unit record, used for both input and runtime (may split later?).
o 	   In CSE, a TUs represent all HVAC devices which xfer heat to/from a zone,
o 	   including reheat coils, VAV boxes, and baseboard heaters.  A TU has one
o 	   or more CAPABILITIES; different combinations allow this common TU data
o 	   structure to represent the many physically different terminal devices.
o
o        Capability       Description
o        --------------   ---------------------------
o        Local heating    Local heating (coil, baseboard)
o        Air heating	Air heating (air from air handler)
o        Air cooling      Air cooling (air from air handler) */
o
o #ifndef BCPP
o     *hide DBN bn	// dummy
o     *z ANAME name	// for LIKEing etc
o     TI ownTi		// was zi		// ZNI/R rcd subscript of owner zone
o #else
o     			// ownTi (base class) is ZNI/R rcd subscript of owner zone
o #endif
o     TI tuxNxTu		// chain: 0 or ss of next TU in current zone chain
o     TI tuxZhxx1		// chain head: ss of 1st ZHXX belonging to this TU
o
o     		// local heating (baseboard, coil, ...)
o     *h TEMP tuxTLH   	// local heating set point
o     *h POWER_GEZ tuxMxLH	// current capacity, as limited by plant capacity or zone conditions (Btuh)
o     *h POWER_GEZ tuxMnLH	// current minimum output (Btuh)
o     *s POWER_GEZ tuxQLh 	// actual output, current step (Btuh)
o
o     		// air heating/cooling (air from air handler)
o     *i TI tuxAhi		// 0 or AHU ss for air handler serving this terminal
o     *h TEMP tuxTH    	// air heating set point (F)
o     *h TEMP tuxTC    	// air cooling set point (F)
o     *h FLOAT_GEZ tuxCMn	// min cap flow rate (Btuh/F)
o     *h FLOAT_GEZ tuxCMxH	// max cap flow rate, heating (Btuh/F)
o     *h FLOAT_GEZ tuxCMxC	// max cap flow rate, cooling (Btuh/F)
o     *s FLOAT_GEZ tuxC    	// actual cap flow rate, current step (Btu/F)
o
o *END		// TUX
#endif
//=============================================================================
#if 0	//ifdef OLDAT				// OLD 3-92, deleted 5-92
o RECORD ZHXX "zhx" *RAT		// old version 3-92
o 	// Basic info about zone heating, cooling, and venting transfers
o 	// via direct addition of heat or addition of warm/cool air.
o 	// ZHXXs are created at "RUN" command for each:
o 	//    1.  each TU capability (local heating, air heating, ...)
o 	//    2.  zone natural vent (if present)
o 	//    3.  (future others?)
o 	// No input-only ZHX rat exists.
o 		// mbrs set at "RUN" (out of cncult:topCkf); some can vary during simulation
o #ifndef BCPP
o     *r TI ownTi		// was owni	// ss of owner -- ZNR/ZNI ss (ty=ZHX_NATVENT) or TU ss (other tys)
o #else
o 			// name is ...  unused?
o 			// ownTi is TU ss (other tys) or (future) ZNR/ZNI ss (ty=ZHX_NATVENT) (or use sep mbr???)
o #endif
o     *r TI nxZhxx		// chain: 0 or ss of next ZHX for this TU.  0 if ty=ZHX_NATVENT.
o     *r SI tyZhxx		// ZHX type: consts in cndefns.h
o     			//   ZHX_NATVENT  zone natural ventilation
o 			//   ZHX_TULHS	  terminal local heating set output
o 			//   ZHX_TULHC	  terminal local heating tstat ctrl
o 			//   ZHX_TUAHS	  terminal air heating set output
o 			//   ZHX_TUAHC	  terminal air heating tstat ctrl
o 			//   ZHX_TUACS	  terminal air cooling set output
o 			//   ZHX_TUACC	  terminal air cooling tstat ctrl
o 			// Note: local heating is coil or baseboard in zone; air heating/cooling uses air handler air.
o     *h TEMP zhxxSp    	// tstat set point if heat xfer is controlled, else unused (hourly variability)
o     *r SI zhxxSpPri   	// tstat set point priority; used determine order in which HVAC xfers are activated
o     			//  in event of same .sp.  Allows, for example, air heating to ALWAYS
o 			//  be pegged before coil is activated, even at same sp.  see cnhour:znMdSeq().
o
o 		// mbrs used internally during simulation
o     *h SI zhxxMdi	// ZNR mdxSeq[] ss for mode corresponding to this ZHX set in cnhour:znMdSeq()
o *END		// ZHXX
#endif

// end of cnrecs.def
