// Copyright (c) 1997-2019 The CSE Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file.

// ancrec.cpp: base class functions for records and record anchors, for CSE, 2-92.

/* A "record anchor" (class anc<rec name>) is a small, usually static, object that
     points to and holds info about a block of static or heap memory that contains an array of records.
   The records in the array are of a class derived from class 'record'.
   Record and anchor definitions are generated by rcdef.exe. */


// conversion notes
//  review each use of RATFRONT and RATFRONTSZ
//  cnglob: remove all rat stuff at least for now; remove ifndef GLOBs here.

// pending
//  be sure rcdef generates eSz via sizeof

// record changes
//  ALL records named & ownable; edit dbns, names, ownTi's out of cnrecs.def.
//   ZNISUB name must move to ZNI/ZNR.
//   ownTi name in code must be changed to "ownTi", or special rcdef feature.

// ideas
//  do statSetup() setup from constructor: would fit uses; rcdef changes needed?
//		above comment is pre-multi-run (1993), less clear with multi-run and DLL use.

#include "cnglob.h"
#include "ancrec.h"
#include "cse.h"
#include "msghans.h"
#include "exman.h"
#include "cvpak.h"
#include "srd.h"		// SFIR


//***************************************************************************************************************************
//  class record: base class for application records.
//		destructor: inline, ancrec.h.
//***************************************************************************************************************************
record::record(BP _b, TI i, SI noZ/*=0*/)  	// construct record i of basAnc b, zero all members unless noZ
{
	/* possible conditional statSetup elimination:
	   if (i==0  (and at least b->rt matches if no validate()) and  b->p==0 and b->n < b->mn,
					set b->p=this, mn/n/nAl 1 record, RFSTAT.   BE SURE to override mn: 1-->0.
	   if (i > 0 and b RFSTAT and b->p consistent and b->n==i-1,
					b->n++ : additional record in static array.
	   CAUTION can be called from statSetup (til eliminated). */

	basAnc::ba_ValidateSafe(_b, "record::record");	// abort if base bad -- we depend on it for size

	if (!noZ)							// can be suppressed for data-init (static) records
		memset((char *)this + SZVFTP, 0, _b->eSz - SZVFTP);	/* zero all members of DERIVED CLASS record
								   except virtFcnTblPtr in 1st 2 or 4 bytes (ancrec.h define) */
	b = _b;
	rt = _b->rt;
	ss = i;  			// set base class members, for appl and anchor class use
	r_status = 1; 		// say space in use and record good
}			// record::record
//---------------------------------------------------------------------------------------------------------------------------
void record::RRFldCopy(		// record-to-record field copy
	const record* rSrc,	// source record (same type as this)
	int fn)				// field #
// handles NaNs re expressions
{
#if defined( _DEBUG)
	if (b->rt != rSrc->b->rt)
		err( PWRN, "%s:%s RRFldCopy: RT mismatch", b->what, Name());
#endif
	int dt = DType( fn);
	int sz = GetDttab( dt).size;
	memcpy( field( fn), rSrc->field( fn), sz);
	fStat( fn) = rSrc->fStat( fn);
}	// record::RRFldCopy
//-----------------------------------------------------------------------------
void record::FldCopy(		// field-to-field copy (within record)
	int fnS,		// source field #
	int fnD)		// destination field #
// handles NaNs re expressions
{
	int dtS = DType( fnS);
#if defined( _DEBUG)
	int dtD = DType( fnD);
	if (dtD != dtS)
		err( PWRN, "%s:%s FldCopy: DT mismatch", b->what, Name());
	if (IsAusz( fnS))
		err( PWRN, "%s:%s FldCopy: source is AUTOSIZEd",
			b->what, Name());
#endif
	int sz = GetDttab( dtS).size;
	memcpy( field( fnD), field( fnS), sz);
	fStat( fnD) = fStat( fnS);
}	// record::FldCopy
//-----------------------------------------------------------------------------
int record::DType( int fn) const
{	int fdTy = b->fir[ fn].fi_fdTy;	// get field type (sFdtab subscript) from rat's "Fields In Record" table
	int dt = sFdtab[ fdTy].dtype;	// get data type from small Fields info Table
	return dt;
}		// record::DType
//-----------------------------------------------------------------------------
float record::FldValFloat(int fn) const
{
	int dt = DType(fn);
	const void* pV = field(fn);
	float v = 0.f;
	if (dt == DTFLOAT)
		v = *(FLOAT*)pV;
	else if (dt == DTDBL)
		v = float(*(DBL*)pV);
	else
		err(PWRN, "record::FldValFloat -- unsupported dt=%d", dt);
	return v;
}		// record::FldValFloat
//-----------------------------------------------------------------------------
int record::FldValInt(int fn) const
{
	int dt = DType(fn);
	const void* pV = field(fn);
	int v = 0;
	if (dt == DTSI)
		v = *(SI*)pV;
	else if (dt == DTTI)
		v = *(TI*)pV;
	else if (dt == DTINT)
		v = *(INT*)pV;
	else
		err(PWRN, "record::FldValInt -- unsupported dt=%d", dt);
	return v;
}		// record::FldValInt
//-----------------------------------------------------------------------------
int record::IsNameMatch( const char* _name) const
{
	return _stricmp(_name, Name()) == 0;
}		// record::IsNameMatch
//-----------------------------------------------------------------------------
/*virtual*/ void record::Copy(	// copy user and ul data and r_status from another record of same type
	const record* pSrc,		// source record
	int options/*=0*/)		// rcoLEAVENAME: do NOT copy name
{
	// records must already be constructed (can't construct here without knowning b, ss).
	if (!b || !pSrc)					// (or gud? wd error here if init then destroyed)
		err( PABT, MH_X0051);  			// err msg "record::Copy(): unconstructed destination or !pSrc"
#if defined( _DEBUG)
	basAnc::ba_ValidateSafe(b, "Copy() dest");				// abort if records not well anchored
	basAnc::ba_ValidateSafe(pSrc->b, "Copy() src");
#endif

	// bitwise copy members preceding name (not including internal members)
	int offBeg = offsetof(record, r_status);
	int offEnd = offsetof(record, name);
	memcpy((char*)this + offBeg, (const char*)pSrc + offBeg, offEnd - offBeg);

	// conditionally copy name
	if (!(options & rcoLEAVENAME))
		name = pSrc->name;

	// bitwisecopy remainder (ownTi, record data, and status array)
	offBeg = offsetof(record, ownTi);
	if (b->rt == pSrc->b->rt)
	{	// same type: single memcpy()
		memcpy((char*)this + offBeg, (const char*)pSrc + offBeg, b->eSz - offBeg);
	}
	else
	{	// partial copy (e.g. ZNI->ZNR)
		if (pSrc->b->sOff > b->sOff)
			err(PABT, MH_X0052);
		else
		{	memcpy((char*)this + offBeg, (const char*)pSrc + offBeg, pSrc->b->sOff - offBeg);
			memcpy((char*)this + b->sOff, (const char*)pSrc + pSrc->b->sOff, pSrc->b->nFlds);
		}
	}

	FixUp();		// virtual: record can e.g. fix ptrs

#if defined( _DEBUG)
	Validate();		// virtual
#endif
}			// record::Copy
//-----------------------------------------------------------------------------
const char* record::getChoiTx(
	int fn,				// field #
	int options /*=0*/,	// option bits
						//  1: no error messages for out of range chan
						//     (return displayable text indicating error)
	SI chan /*=-1*/,	// current choice (default = from record)
	BOOL* pIsHid /*=NULL*/) const	// optional return: TRUE iff choice is hidden
									//   text returned w/o "*"
// returned: choice text
{
	if (chan < 0)
	{	SI* pCh = (SI *)field( fn);
		if (pCh)
			chan = *pCh;
	}
	const char* text = b->getChoiTx( fn, options, chan, pIsHid);

	return text;

}		// record::getChoiTx
//-----------------------------------------------------------------------------
record* record::getOwner() const
// return ptr to owner record
//  NULL if linkage bad
{
	BP bOf = b->ownB;
	record* r = bOf ? bOf->GetAtSafe(ownTi) : NULL;
	if (!r)
		oer("getOwner() fail for %s", objIdTx());
	return r;
}	// record::getOwner
//-----------------------------------------------------------------------------
const char* record::whatIn() const 	// return basAnc record owner text
// e.g.  "zone 'Z1'"  or  "sgdist 'foo' of glazing 'gl1' of zone 'Z1'"
{
	BP bOf = b->ownB;   			// item's owner's basAnc
	if (bOf==0)
		return "<whatIn: null b->ownB>";
	if (ownTi > bOf->n)
		return "<whatIn: ownTi > b.n>";
	return bOf->rec( ownTi).objIdTx( 	// string of class, name, its owner, etc. next.
					1 );				// say show [file(file)] in 1st object if unnamed
}	// record::whatIn
//-----------------------------------------------------------------------------
int record::IsSetCount(			// count # of set fns in list
	int fn, ...) const	// 0 terminated fn list (don't forget the 0!)
// returns # of IsSet() fields
{	va_list ap;
	va_start( ap, fn);
	int nSet = 0;
	while (1)
	{	if (fn == 0)
			return nSet;
		nSet += IsSet( fn);
		fn = va_arg( ap, int);
	}
}		// record::IsSetAny
//-----------------------------------------------------------------------------
int record::IsValAll(		// check for resolved (non-expression) values
	int fn, ...) const	// 0 terminated fn list (don't forget the 0!)
// return 1 iff all fields have values
{	va_list ap;
	va_start( ap, fn);
	while (1)
	{	if (fn == 0)
			return 1;		// at end, all have values
		if ((fStat( fn) & (FsSET|FsVAL)) == FsSET)
			return 0;		// no value, stop
		// else set with non-expression or default
		fn = va_arg( ap, int);
	}
}		// record::IsValAll
//-----------------------------------------------------------------------------
const char* record::objIdTx(

	/* ret Tmpstr string identifying object, conditionally showing owner(s), eg:
		zone "sleep"
		3rd layer of construction "wallCon3"
		sgdist of window [file(99)] of surface [file(97)] of zone "sleep" */

	int op/*=0*/) const	// option: 1: if object unnamed, use "[<file>(<line>)]":
    			    //   use 0 if shown elsewhere in msg.
                    //   (  internally determined for "of ..."'s)
{
	const char* s="";
	const char* tween="";
	int nameShown=0;

	const record* r = this;
	for ( ; ; )
	{
		// verify basAnc record ptr
		if (r->b->rt != r->rt/*  || r->ss <= 0*/)	// part commented out 1-21-92 rejects Top.
			err( PWRN, MH_S0273);			// display internal error msg
													// "*** objIdTx(); probable non-RAT record ptr ***"
		s = scWrapIf( s, 						// concat string so far (s) w
					  strtcat( tween, r->classObjTx( op), NULL),	// class and object name text,
					  "\n    ", getCpl());   			// inserting __ if line wd be too long
		tween = " of ";
		if (!r->name.IsBlank())					// if name is not ""
			nameShown++;
		if ( r->b->ownB==0 || r->ownTi <= 0		// or basAnc has no owning basAnc, or record has owning record,
				||  r->ownTi > ((BP)r->b->ownB)->n 		// or owner subscr out of range (catches erroneous Top ownership)
				||  nameShown >= 2 )				// or have shown enuf names
			break;
		r = &r->b->ownB->rec(r->ownTi);			// point owning record
		op = nameShown ? 0 : 1;				/* show unnamed obj [file(line)] if no name yet shown,
       							   after 1st iteration (1st per caller). */
	}
	return s;
}	// record::objIdTx
//-----------------------------------------------------------------------------
const char* record::classObjTx(		// get class name - object name text
	int op/*=0*/) const	// option: 1: if no name, use "[<file>(<line>)]"

// examples: zone "main"		surface "foo"
//   3rd layer			sgdist [bldg(231)] */

// caution: return value is in Tmpstr: transitory!
{

// verify basAnc record arg (C compiler doesn't as void used for varying types)
	if (b->rt != rt)
		err( PWRN, MH_S0274); 	// display internal error msg
	// "*** classObjTx(); probable non-RAT record arg ***"

	const char* what = b->what;  		// class name from basAnc

// if it has a name ...
	if (!name.IsBlank())			// if this record has nonblank name
		return strtprintf("%s '%s'", what, Name());

#if 0		// .bn gone, have not replaced this mechanism (only use yet found: layer, cncult2.cpp.)
o// else if it has object-number-for-owner in bn member, show that
o    if (R->bn)					// e.g. layer # for construction (cncult.cpp)
o       return strtprintf( "%s %s",
o                          ordinal(R->bn),	// form "1st", "2nd", etc
o                          what );
#endif

// else if it has file and line, optionally show them
	if (op)
		if (fileIx)
			return strtprintf("%s [%s(%d)]", what, getFileName( fileIx), inputLineNo);

// else just class name
	return what;
}		// record::classObjTx
//-----------------------------------------------------------------------------
RC record::CkSet( 	// verify that required member has been set
	int fn)	const // field number

// call only for RQD fields -- issues inappropriate msg for others

// if not set, returns non-RCOK.  issues message only if errCount is 0 -- else assumes previously messaged.
{
// return ok if has-been-set-by-user-input bit on in field's field status byte
	if (IsSet( fn))
		return RCOK;

// not set.  Msg should have been issued at end of object; avoid repeating.
	if (errCount()) 		// if there have been any messages at all (rmkerr.cpp fcn)
		return RCBAD;		// return bad, no msg here

	// unset field but no messages at all have been issued this run.
	// Unexpected, but issue msg here to prevent mysterious messageless non-runs.
	// Devel aid.  Might occur, for example, if RQD flag removed on member and
	// code that calls here not updated to match (defaults do not set FsSET).
	return oer( MH_S0493,	// "Required member '%s' has not been set,\n"
							// "    and apparently no message about it appeared above"
				b->fir[fn].fi_GetMName() );		// accesses fi_mName
}	// record::CkSet
//-----------------------------------------------------------------------------
/*virtual*/ int record::ReportBalErrorsIf(
	int balErrCount,			// error count
	const char* ivlTxt) const	// interval text (plural), e.g. "subhours"
// report energy balance error
// returns # of balance error count
{
	if (balErrCount > 0)
	{	const char* what = objIdTx();
		warn("%s: Energy balance errors occurred in %d %s.",
			what, balErrCount, ivlTxt);
	}
	return balErrCount;
}		// record::ReportBalErrorsIf


///////////////////////////////////////////////////////////////////////////////
// record data checking member functions
///////////////////////////////////////////////////////////////////////////////
RC record::limitCheck(		// range check, issue warning or error msg
	int fn,				// field
	double vMin,		// min allowed value
	double vMax,		// max allowed value
	double vMinWarn /*=-DBL_MAX*/,	// min for warning
	double vMaxWarn /*=DBL_MAX*/) const	// max for warning
// return RCOK if field not set or value is in range or warning msg
//        else RCxx if value out of range (msg issued)
{
	RC rc = RCOK;
	if (IsVal(fn))
	{	// value is user-provided and known
		//   not CULT default
		//   not unevaluated expression
		double v = FldValFloat(fn);
		if (v < vMin || v > vMax)
			rc = oer("%s (%g) must be in range %g - %g",
				mbrIdTx(fn), v, vMin, vMax);
		else if (v < vMinWarn || v > vMaxWarn)
		{	// warning (do not return RCBAD)
			// use vMin / vMax instead of default DBL_MAX (avoid showing 10e+308)
			//    if here, at most one can be DBL_MAX
			if (vMinWarn == -DBL_MAX)
				vMinWarn = vMin;
			else if (vMaxWarn == DBL_MAX)
				vMaxWarn = vMax;
			oWarn("dubious %s (%g) typically should be in range %g - %g",
				mbrIdTx(fn), v, vMinWarn, vMaxWarn);
		}
	}
	return rc;
}		// record::limitCheck
//-----------------------------------------------------------------------------
RC record::limitCheckFix(	// range check, msg, set to min/max
	int fn,			// field
	float vMin,		// min allowed value
	float vMax,		// max allowed value
	int erOp /*=ERR*/)		// WRN/ERR/IGN etc
							// note IGNX bit: limit only (don't msg)
// return RCOK if field not set or value is in range or warning msg
//        else RCxx if value out of range (msg issued)
{
	RC rc = RCOK;
	void* p = field(fn);
	if (!ISNANDLEP(p))
	{
		FLOAT* pV = (FLOAT*)p;
		FLOAT v = *pV;
		if (v < vMin || v > vMax)
		{
			rc = orMsg(erOp, "%s (%g) must be in range %g - %g",
				mbrIdTx(fn), v, vMin, vMax);
			*pV = bracket(vMin, v, vMax);
		}
	}
	return rc;
}		// record::limitCheckFix
//-----------------------------------------------------------------------------
RC record::limitCheckRatio(		// check the ratio of two fields
	int fn1,	// field 1
	int fn2,	// field 2
	double vMin,	// min allowed val for f1/f2
	double vMax) const	// max allowed val for f1/f2
// NOTE: No field status checks
//       Caller must ensure values set (not unevaluated expressions)
// returns RCOK iff ratio is within (vMin, vMax)
{
	RC rc = RCOK;

	double v1 = FldValFloat(fn1);
	double v2 = FldValFloat(fn2);

	double vRat = v2 != 0. ? v1 / v2 : 0.;

	if (v2 == 0. || vRat < vMin || vRat > vMax)
		rc = oer("The ratio %s (%g) / %s (%g) is %g; it must be in range %g - %g",
			mbrIdTx(fn1), v1, mbrIdTx(fn2), v2, vRat, vMin, vMax);
	return rc;
}	// record::limitCheckRatio
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
//   'record' MEMBER FUNCTIONS TO REQUIRE/DISALLOW FIELDS (class declaration: ancrec.h)
///////////////////////////////////////////////////////////////////////////////
RC record::ValidateFN(int fn, const char* caller) const
{
	RC rc = RCOK;
	if (fn < 0 || fn > 1024)
		rc |= oer( MH_S0495,	// "%s Internal error: field # %nd: unterminated arg list?"
				   caller, fn);
	return rc;
}	// record::ValidateFN
//-----------------------------------------------------------------------------
RC record::checkN(			// general purpose check multiple fields
	MSGORHANDLE when,		// message insert.  message handle ok (see messages.cpp).
	RC(record::* checkFcn)(MSGORHANDLE when, int fn),	// check function called for each field
	va_list ap)				// int field numbers, 0 ends list  REMEMBER THE 0!
{
	RC rc = RCOK;

	for (; ; )
	{
		int fn = va_arg(ap, int);
		if (!fn)
			break;
		rc |= (this->*checkFcn)(when, fn);
	}
	return rc;
}		// record::checkN
//-----------------------------------------------------------------------------
RC record::checkN(			// general purpose check multiple fields
	MSGORHANDLE when,		// message insert.  message handle ok (see messages.cpp).
	RC(record::* checkFcn)(MSGORHANDLE when, int fn),	// check function called for each field
	const int16_t* fnList)		// array of field numbers, 0 ends list  REMEMBER THE 0!
{
	RC rc = RCOK;

	int fn = 0;
	for (int iFn = 0; (fn = fnList[iFn]); iFn++)
		rc |= (this->*checkFcn)(when, fn);
	return rc;
}		// record::checkN
//-----------------------------------------------------------------------------
RC record::disallowN( 			// issue "not allowed" message for each given field in 0-terminated list of field numbers
	MSGORHANDLE when,	// message insert.  message handle ok (see messages.cpp).
	...)				// int field numbers, 0 ends list  REMEMBER THE 0!
{
	va_list ap;
	va_start(ap, when);
	RC rc = checkN(when, &record::disallow, ap);
	return rc;
}		// record::disallowN
//-----------------------------------------------------------------------------
RC record::disallow( 		// issue "not allowed" message for each given field in an array of field numbers
	MSGORHANDLE when,	// message insert.  message handle ok (see messages.cpp).
	const int16_t* fnList)	// array of field numbers, 0 ends list  REMEMBER THE 0
{
	RC rc = checkN(when, &record::disallow, fnList);
	return rc;
}		// record::disallow
//-----------------------------------------------------------------------------
RC record::disallow(     			// issue "not allowed" message if field is given
	MSGORHANDLE when,	// message insert, worded for work context "Can't give <f> <when>", handle ok
	int fn)
{
	RC rc = ValidateFN(fn, "disallow");
	if (!rc && fn && IsSet(fn))		// if value for field given in user input (test field status byte)
		rc = cantGiveEr(fn, when);
	return rc;
}			// record::disallow
//-----------------------------------------------------------------------------
RC record::requireN( 			// issue "missing" message for each omitted field in 0-terminated list of field numbers
	MSGORHANDLE when,	// message insert (message handle ok)
	...)				// int field numbers, 0 ends list  REMEMBER THE 0!
{
	va_list ap;
	va_start(ap, when);
	RC rc = checkN(when, &record::require, ap);
	return rc;
}		// record::requireN
//-----------------------------------------------------------------------------
RC record::require( 		// issue "missing" message for each given field in an array of field numbers
	MSGORHANDLE when,		// message insert.  message handle ok (see messages.cpp).
	const int16_t* fnList)	// array of field numbers, 0 ends list  REMEMBER THE 0
{
	RC rc = checkN(when, &record::disallow, fnList);
	return rc;
}		// record::require
//-----------------------------------------------------------------------------
RC record::require(    			// issue message if field is not given
	MSGORHANDLE when,	// message insert (msghan ok)
	int fn)				// field number
{
	RC rc = ValidateFN(fn, "require");
	if (!rc && fn && !IsSet(fn)) 		// if value for field not given in user input
		rc = notGivenEr(fn, when);
	return rc;
}			// record::require
//-------------------------------------------------------------------------------
RC record::ignoreN( 		// issue "ignored" message for each given field in 0-terminated list of field numbers
	MSGORHANDLE when,	// message insert.  message handle ok (see messages.cpp).
	...)				// int field numbers, 0 ends list  REMEMBER THE 0!
{
	va_list ap;
	va_start(ap, when);
	RC rc = checkN(when, &record::ignore, ap);
	return rc;
}		// record::ignoreN
//-----------------------------------------------------------------------------
RC record::ignore( 		// issue "ignored" message for each given in an array of field numbers
	MSGORHANDLE when,	// message insert.  message handle ok (see messages.cpp).
	const int16_t* fnList)	// array of field numbers, 0 ends list  REMEMBER THE 0
{
	RC rc = checkN(when, &record::ignore, fnList);
	return rc;
}		// record::ignore
//-----------------------------------------------------------------------------
RC record::ignore(     			// issue "ignored" message if field is given
	MSGORHANDLE when,	// message insert, worded for work context
	int fn)
{
	RC rc = ValidateFN(fn, "ignore");
	if (!rc && fn && IsSet(fn))			// if value for field given in user input
		rc = ignoreInfo(fn, when);
	return rc;
}			// record::ignore
//============================================================================

/****************************************************************************************************************************
*   'record' MEMBER FUNCTIONS TO MAKE CHANGE FLAG ENTRIES IN RUNTIME TABLES (class declaration: ancrec.h)
****************************************************************************************************************************/
void CDEC record::chafSelf( 		// say increment change flag IN SAME RECORD on change in list of fields of record
	int chafFn, 		// field NUMBER of change flag: an SI field in same record
	...)			// 0-terminated list of field numbers in record to monitor for change if contain expressions
{
	va_list ap;
	va_start(ap, chafFn);
	chafNV(this->b, ss, b->fir[chafFn].fi_off, ap);
}							// record::chafSelf
//============================================================================================================================
void CDEC record::chafN( 		// say increment specified flag during run on change in list of fields in curr record

	BP _b, TI i, int off,	// location of SI change flag: anchor, record subscript, offset in record
	...)					// 0-terminated list of field numbers

/* for each given field which contains an expression handle, make expression manager runtime table entry
  to increment flag at b-i-off when value of that expression changes. */
{
	va_list ap;
	va_start(ap, off);
	chafNV(_b, i, off, ap);
}								// record::chafN
//===========================================================================
void record::chafNV( 		// say increment specified flag during run on change in var list of fields in curr record

	BP _b, TI i, int off,  	// location of SI change flag: anchor, record subscript, offset in record
	va_list ap)				// pointer to 0-terminated list of field numbers

// var arg list level for flexibility
{
	for (; ; )
	{
		int fn = va_arg(ap, int);
		if (!fn)
			break;
		if (fn > 1024)
			oer( MH_S0495,    	// "cncult2.cpp:%s Internal error: field # %d: probable unterminated arg list"
				 "chavNV", fn);
		addChafIf((NANDAT*)field(fn), _b->ancN, i, off);  	/* test pointed to field contents, add increment-on-change
									   table entry if is expr handle.  exman.cpp. */
	}
}					// record::chafNV
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
// FUNCTIONS TO ISSUE SPECIFIC ERROR MESSAGES
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
RC record::cantGiveEr(   				// issue message (using ooer) for disallowed field that user gave
	int fn,
	MSGORHANDLE when)	// message insert, worded for work context "Can't give <f> <when>"
{
	return ooer(fn, 			// message for record & field if 1st error for field, & flag bad.
				 MH_S0496, 				// "Can't give '%s' %s"
				 mbrIdTx(fn),			// input name (id)
				 when.mh_IsSet() ? strtprintf(when) : "");	// user's explanatory insert, eg "when no local heat".
												//   use strtprintf to retrieve text (to Tmpstr) if handle given.
}	// cantGiveEr
//-----------------------------------------------------------------------------
RC record::notGivenEr( 				// issue message (using ooer) for disallowed field that user gave
	int fn,
	MSGORHANDLE when)	// message insert, worded for work context "<f> missing: required <when>"
{
	if (when.mh_IsSet())
		return ooer(fn,  				// message if 1st error for record & field, & flag field bad
					 MH_S0497,			// handle of message "'%s' missing: required %s"
					 mbrIdTx(fn), 		// input name (id)
					 strtprintf(when));	// user's explanatory insert, eg "when tuTLh given"
	return ooer(fn, MH_S0498, 		// "'%s' missing"
				 mbrIdTx(fn));
}			// record::notGivenEr
//-----------------------------------------------------------------------------
RC record::ignoreInfo( 	// issue info message for ignored field
	int fn,
	MSGORHANDLE when)	// message insert
						// worded for context "<f> is ignored <when>"
{
	const char* msg = strtprintf(
			when.mh_IsSet() ? "'%s' is ignored %s" : "ignoring '%s'",
			mbrIdTx(fn),
			strtprintf(when));			// when might be handle
	return oerI(1, 1, 2, msg, NULL);	// do msg using vbl arg list flavor of oer
}		// record::ignoreInfo
//-----------------------------------------------------------------------------
RC record::notGzEr(int fn)		// issue error message for field not greater than 0.  finds user name in CULTs.
{
	return ooer(fn, MH_S0499, mbrIdTx(fn));  	// "'%s' must be > 0"
}
//-----------------------------------------------------------------------------
RC record::AtMost(		// check for interacting input
	int setMax,		// max # of fields that can be set in this group
	int fn, ...)	// list of field #, 0 terminated, REMEMBER THE 0

// returns RCOK iff # set args with group <= setMax
//    else RCBAD (msg issued)
{
	RC rc = RCOK;

	std::vector< const char*> fnIdList;

	va_list ap;
	va_start(ap, fn);
	int setCount = 0;	// # of IsSet() fields
	while (fn)
	{
		if (IsSet(fn))
			++setCount;
		fnIdList.push_back(mbrIdTx(fn));
		fn = va_arg(ap, int);
	}

	if (setCount > setMax)
	{	// too many: assemble readable list of names and embed in msg
		const char* sList = strMakeTextList( fnIdList, "and");
		rc = oer("At most %d of %s may be given", setMax, sList);
	}
	return rc;

}	// record::AtMost
//-----------------------------------------------------------------------------
int record::mbrArrayDim(int fn) const
{
	int arrayDim = b->culMbrArrayDim(fn);
	if (arrayDim <= 1)
		oer("mbrArrayDim program error: invalid fn = %d", fn);
	return arrayDim;
}	// record::mbrArrayDim
//-----------------------------------------------------------------------------
RC record::ArrayCheck(		// check array input for expected count
	int fn,						// field #
	int count /*=-1*/,			// # of elements to check
								//  if <=0, use arrayDim - 1
	int nSetExpectedMin /*=-1*/,// min or exact # of elements expected
								//  if <0, same as count
	int nSetExpectedMax /*=-1*/) const
	// max # of elements expected
	//   if <0 = same as nSetExpectedMin
// returns RCOK iff all OK
{
	RC rc = RCOK;
	int nSet = 0;
	int nVal = 0;
	if (count <= 0)
		count = mbrArrayDim( fn) - 1;	// msgs errors
	if (count > 1)
	{
		rc = ArrayStatus(&(fStat()[fn]), count, nSet, nVal);
		if (rc)
			oer("ArrayCheck: Internal error checking array '%s'", mbrIdTx(fn));
		else
		{
			if (nSetExpectedMin < 0)
				nSetExpectedMin = count;
			const char* msg = nullptr;
			if (nSetExpectedMax < 0)
			{	// expected exact #
				if (nSet != nSetExpectedMin)
					msg = strtprintf("%d", nSetExpectedMin);
			}
			else
			{	// expected range
				if (nSet < nSetExpectedMin || nSet > nSetExpectedMax)
					msg = strtprintf("%d to %d", nSetExpectedMin, nSetExpectedMax);
			}
			if (msg)
				rc |= oer("%d value%s found for array '%s' (expected %s)",
					nSet, nSet==1 ? "" : "s", mbrIdTx(fn), msg);
		}
	}
	return rc;
}		// record::ArrayCheck
//-----------------------------------------------------------------------------
RC record::ArrayStatusCounts(		// count IsSet() and IsVal() array elements
	int fn,		// field #
	int& nSet,	// returned: count of IsSet()s
	int& nVal,	// returned: count of IsVal()s
	int count /*=-1*/) const	// # of elements to check
								//  default = array dim - 1
// note: nVal < nSet is possible due to unevaluated expression NANDLEs
// returns RCOK iff success (nSet and nVal set)
//         else program error (fn not array etc.) (msg issued)
{
	RC rc = RCOK;
	
	if (count <= 0)
		count = mbrArrayDim(fn) - 1;
	if (count > 0)
		rc = ArrayStatus(&(fStat()[fn]), count, nSet, nVal);
	if (count <= 0 || rc)
	{	rc = oer("ArrayStatusCounts: invalid fn = %d (rc = %d)", fn, rc);
		nSet = nVal = 0;
	}
	return rc;
}		// record::ArrayStatusCounts
//-----------------------------------------------------------------------------
/*virtual*/ void record::ReceiveMessage(		// receive callback message
	MSGTY msgTy,		// message type: msgtyERROR etc
	const char* msg)	// message text
// logs/displays message with record type and name
// if msgTy == msgtyERROR, does not return
{
	switch (msgTy)
	{
	case MSGTY::msgtyERROR:
		oer(msg);
		err(PABT|NOPREF, "Cannot recover from error above.");
		break;
	case MSGTY::msgtyWARNING:
		oWarn(msg);
		break;
	default:
		oInfo(msg);
		break;
	}
}		// record::ReceiveMessage

//=============================================================================

///////////////////////////////////////////////////////////////////////////////
// public helper functions
///////////////////////////////////////////////////////////////////////////////
RC ArrayStatus(		// count/check status of ARRAY elements
	const UCH* _sstat0,		// status array
	int count,	// # of values to check (dimension of array)
	int& nSet,	// returned: # of array elements set (FsSet)
	int& nVal)	// returned: # of array elements with value (FsVAL)
// re checking of ARRAY input
// returns RCOK on success
//        RCBAD iff malformed (impossible unless bug?)
{	
	RC rc = RCOK;
	int n0 = 0;		// # of 0 status
	nSet = nVal = 0;
	for (int fn=0; fn < count; fn++)
	{	int stat = _sstat0[ fn];
		if (stat == 0)
			n0++;
		else
		{	if (n0)
				rc = RCBAD;		// 0 followed by non-0
			if (stat & FsSET)
				nSet++;
			if (stat & FsVAL)
				nVal++;
		}
	}
	return rc;
}		// ::ArrayStatus
//=============================================================================

//*****************************************************************************
//  class basAnc: base class for application record anchors.
//*****************************************************************************

//--- variables re "anchor numbers".  ancBase.ancN contains #.
const int MAXANCS = 200;	// Maximum number of basAncs supported
							//   actual required = ~65 12-20-2012
static BP ancs[ MAXANCS];	// table of pointers to contructed basAncs
							//   persists for entire session re multiple DLL cse() calls
							//   "big enuf" static array simplifies persistence
static int Nanc = -1;		// # of entries in anc[] (-1 = unintialized) (see regis())
//---------------------------------------------------------------------------------------
basAnc::basAnc()		// default c'tor (for derived copy c'tor
{
	memset( (char *)this+SZVFTP, 0, sizeof(*this)-SZVFTP); // SZVFTP: virtFcnTblPtr: cnglob.h.
}			// basAnc::basAnc
//---------------------------------------------------------------------------------------------------------------------------
basAnc::basAnc( int flags, SFIR * _fir, USI _nFlds, const char * _what, USI _eSz, RCT _rt, USI _sOff, const CULT* pCULT, bool dontRegister/*=false*/ )
{
	memset( (char *)this+SZVFTP, 0, sizeof(basAnc)-SZVFTP);		// zero all basAnc members but virtFcnTblPtr at front
	ba_flags = flags;
	fir = _fir;
	nFlds =_nFlds;
	what = _what;  	// store non-0 member values
	eSz = _eSz;
	rt = _rt;
	sOff = _sOff;		// ..
	mn = 1;				// min record subscript 1 (overwritten with 0 if static)
	// ptr() = 0;		// is done in derived class constructor (deriv vf not avail here; ptr is pure!)
	ba_pCULT = pCULT;	// pointer to associated input CULT table, nullptr = unknown
	// ba_probeModernizeTable = nullptr;	// done by memset
	if (!dontRegister)
		regis();					// conditionally include anchor for nextAnc() iteration
}					// basAnc::basAnc
//--------------------------------------------------------------------------------------------------------------
/*virtual*/ basAnc::~basAnc()		// d'tor
{
	if (ba_flags & RFTYS)
		dmfree( DMPP( what));
}		// basAnc::~basAnc
//-----------------------------------------------------------------------------
int basAnc::GetCount() const	// return # of records
{
	int count = 0;
	for (int i = mn; i <= n; i++)
		count += rec(i).r_status > 0;
	return count;

}	// basAnc::GetCount
//-----------------------------------------------------------------------------
int basAnc::MakeRecordList(
	char* list,
	size_t listDim,
	const char* brk,
	const char* (*proc)(const record* pR) /*=nullptr*/) const

{
	int count = 0;
	*list = '\0';
	for (int i = mn; i <= n; i++)
	{
		const record* pR = &rec(i);
		if (pR->r_status > 0)
		{
			const char* s1 = proc != nullptr
				? (*proc)(pR) : pR->Name();
			if (s1 != nullptr)
			{
				strCatIf(list, listDim, brk, s1);
				++count;
			}
		}
	}

	return count;

}	// MakeRecordList
//---------------------------------------------------------------------------------------------------------------------------
void FC basAnc::regis()				// "register" anchor for nextAnc() iteration.  Constructor helper.
{
	int an;
	if (Nanc < 0)		// if not initialized
	{	VZero( ancs, MAXANCS);
		Nanc = 0;
	}
	for (an = 1;  an < MAXANCS && ancs[an] && ancs[an] != this;  an++)		// find free pointer
		;							// (or one already set for this anc: reconstr insurance)
	if (an >= MAXANCS)
		err( PABT, "Insufficient anc[] space");
	ancs[an] = this;   			// set pointer in static array
	Nanc = max( Nanc, an);
	ancN = an;							// set index in anchor
}		// basAnc::regis
//---------------------------------------------------------------------------------------------------------------------------
void basAnc::desRecs(		// delete records
	TI _mn /*=0*/,  // 1st record to delete
	TI _n /*=TI_MAX*/)	// last record to delete
{
	//if (mn <= n)					// if any records allocated: protection for ptr vf call if nec??
	if (ptr())						// if record memory is allocated
		for (TI i = max(mn,_mn);  i <= min(n,_n);  i++) 	// loop allocated record spaces in range given by caller
			desRec(i);						// conditionally destroy record in space
}				// basAnc::desRecs
//---------------------------------------------------------------------------------------------------------------------------
void FC cleanBasAncs(	// destroy/free all basAnc records, and delete subsidiary "types" basAncs (.tyB)
		[[maybe_unused]] CLEANCASE cs)		// what is being cleaned
{
	for (USI i = 1;  i < Nanc;  i++)		// loop over basAnc ptrs in ancs
	{
		BP b = ancs[i];			// fetch ptr
		if (!b)
			continue;			// skip (unexpected) NULL pointer
		b->free();				// destroy b's records, free record memory unless static, clear flags
		delete b->tyB;
		b->tyB = NULL;
	}

//  if (cs == DONE || cs == CRASH)
//	{	// nothing to do
//	}
//  else
//		ancs[] is built by c'tor, thus must persist from entry to entry (all non-tyB ancRecs believed static).

	clearFileIxs();		// clear file names referenced by record.fileIx members
}	// cleanBasAncs
//---------------------------------------------------------------------------------------------------------------------------
void * FC basAnc::recFld( TI i, SI fn) 			// point record i member by FIELD #

/* note: this is not in ancrec.h to avoid needing to include srd.h first for sFIRstr;
   it is not virtual to avoid multiple copies.  delete later (3-92) if not used. */
{
	return (void *)((char *)&rec(i) + fir[fn].fi_off); 	// get field offset from basAnc's fields-in-record table
}
//---------------------------------------------------------------------------------------------------------------------------
RC FC basAnc::al(       // destroy any existing records and allocate space for n (0=default) records
    TI _n,
    int erOp/*=ABT*/,
    BP _ownB /*NULL*/)      // optional: ptr to anchor whose objects own this anchor's objects

// use explicitly to alloc n spaces at once when n known, for speed & non-fragmentation.
{
    if (_ownB)
		ownB = _ownB;
	desRecs();					// destroy any existing records in place (without freeing storage block)
	return reAl( _n, erOp);			// (re)allocate to size _n, using existing block if possible.
} 				// basAnc::al
//---------------------------------------------------------------------------------------------------------------------------
RC FC basAnc::reAl( TI _n, int erOp/*=ABT*/)		// allocate space for n (0=default; does not count 0th) records

// preserves existing records.
// called automatically from basAnc::add if needed.
// could use explicitly to expand to n spaces at once when n known, for speed & non-fragmentation.

{
#ifdef DEBUG2
	if (basAnc::ba_ValidateSafe( this, "basAnc::reAl", erOp) != RCOK)
		return RCBAD;	// check anchor
#endif
	if (_n < 1)
		_n = max( 5, 1024/eSz);		// if # records not specified, use 1k's worth (at least 5)
	TI _nAl = _n+1;					// space [0] not used (all 0's for grounding) --> max subscr+1 is n+1
	size_t sz = _nAl * eSz;			// size that must be allocated
	desRecs(_nAl); 					// insurance: destroy any excess existing records if making block smaller
	record* ptrWas = ptr();			// NULL if this is initial allocation
	RC rc = dmral( pptr(), sz, erOp|DMZERO);	// (re)alloc memory, zero new space, dmpak.cpp
	if (rc)								// if failed
		;								// leave variables unchanged
	else								// ok
	{
		nAl = _nAl;   					// save max alloc'd subscript+1.
		n = min(n, nAl - 1);			// make sure n is with allocated space		
		mn = 1;  						// insurance: mn is already 1.
		ba_flags |= RFHEAP;				// say block is in heap, should be free'd
		// the n record spaces are subscripted 1 to n.  The spaces are not "records" till constructed by add().
		// allocated but unused space[0] "grounds" unset references and allows using 0 subscript as "unset" indicator.
		// set front members in block's space[0] now, as req'd by validate's check when ptr nz.
		if (!ptrWas)				// do 1st time only to avoid compensating for bugs
		{
			ptr()->rt = rt;  			//   ... (rec(0) is not add'd, and anyway validate error would foil add.)
			ptr()->b = (BP)this;		// .ss is already 0.  .gud is left 0.
		}

		// loop all pre-reAl gud records
		for (int i=mn; i<=n ; i++)
			if (rec( i).r_status > 0)
				rec( i).FixUp();		// virtual, allow record to fix e.g. link ptrs
	}
	return rc;
} 		// basAnc::reAl
//---------------------------------------------------------------------------------------------------------------------------
RC FC basAnc::free()				// free (non-static) record memory block for anchor
{
	desRecs();  			// destroy any records: calls record-derived class virtual d'tor
	n = nAl = 0;
	mn = 1;					// minimum subscript 1 to be > n; also 1 expected by reAl/add.
	if (ba_flags & RFHEAP)	// do not free non-heap (static) block
		dmfree( pptr());	//   free memory block and set ptr() null
	ba_flags &= ~RFHEAP;	// clear all flags but non-heap flag
	return RCOK;
}					// basAnc::free
//---------------------------------------------------------------------------------------------------------------------------
RC basAnc::add(		// construct record i (0 = next). Allocs if nec.
	record **_r,	// returned: ptr to add record
	int erOp,		// error handling
	TI i/*=0*/,		// where to add
	const char* _name /*=NULL*/)	// optional name for added record
{
#ifdef DEBUG2
	if (ba_ValidateSafe( this, "basAnc::add", erOp) != RCOK)	// check anchor
		return RCBAD;
#endif
	if (!i)						// if we are to choose record number
	{	i = mn;						// 1: record # 0 is not used
		if (ptr())
		{
			while (i <= n && rec(i).r_status) i++;    // find record space with gud==0 else 1 more than last used.
		}
	}
	else if (i <= n  &&  rec(i).r_status)  	// else if have (unexpected) request to "add" existing in-use record
		desRec(i);					// destroy that record's current contents (eg free deriv class heap ptrs)
	if ( i >= nAl  					// if (more) record spaces must be allocated (nAl is +1; i,n are not)
	 ||  !ptr() )   				// insurance
	{
		TI _n = max(i, nAl + max(5, 1024/eSz));	// new count: add 5 or 1K's worth (at least callers req'd rec #)
		if (reAl(_n, erOp))
			return RCBAD; 		// (re)alloc rec spaces 1.._n, init nAl, ptr(), space[0], etc. above.
	}
	conRec(i);				// construct record i: mark in use, zero, init std base members, do specific record init.
	*_r = &rec(i);			// return pointer to the added record
	if (_name)
		(*_r)->SetName(_name);
	if (i > n)
		n = i;				// increase max in-use subscript (loop limit) to that just allocated
	return RCOK;			// error returns above
}			// basAnc::add
//---------------------------------------------------------------------------------------------------------------------------
RC FC basAnc::del( TI i, int erOp/*=ABT*/)			// delete (squeeze out) ith record
{
	if (ba_ValidateSafe( this, "basAnc::del", erOp) != RCOK)	// check anchor ('this') vs its record block
		return RCBAD;
	desRec(i);							// conditionally destroy the record being deleted
	for (  ;  i < n;  i++)  			// loop over following records except last
	{
		record& dest = rec(i);
		record& src = rec(i+1);
		if (src.r_status)				// if next record good
		{
			if (!dest.r_status)
				conRec(i);		// construct destination if nec to insure vftp, rt, b, ss set.
			dest.Copy( &src);	// copy record i+1 to i without dup'ing heap ptrs
			// tentatively no destroy: does nothing in base class, and deriv class might delete heap ptrs we did not dup.
#if defined( _DEBUG)
			dest.Validate();
#endif
		}
		else					// (not currently expected 2-92)
			dest.r_status = 0;	// nothing to copy from next slot, say this slot is free
	}
	rec(i).r_status = 0;  	// say vacated slot at end is free
	// if possible leftover undup'd ptrs in vacated slots with r_status=0 are a problem,
	//    CONSTRUCT the slots (conRec(i)) to zero data.
	n--;					// max subscript is one less
	return RCOK;			// error return above.
}			// basAnc::del
//---------------------------------------------------------------------------------------------------------------------------
void basAnc::statSetup( 		// init anchor with given non-expandable static record memory

	record &r, 		// caller-supplied storage, size _n * sizeof(the record)
	TI _n, 			// number of records, to be subscripted 0 to _n-1. Typically 1.
	SI noZ /*=0*/, 	// non-0 to NOT zero caller's record storage: use if data-init
	SI inHeap /*=0*/)  	// non-0 if in heap: dmfree in destructor 5-31-92

// statSetup() vs al()/reAl():
// 1. statSetup allows direct access to record members in static storage when record subscript known,
//    as for 1-entry tables, while still allowing use of general record functions.
// 2. does not reserve all-0 entry [0] -- saves space for fixed size or single-entry tables.
// 3. statSetup does not allow expanding later.
// 4. statSetup inits all 0..n-1 entries now: no need to call add() for each entry as used.
{
	// initialize run-time anc members.  eSz and rt are init by constructor.
	setPtr( &r);
	if (inHeap)
		ba_flags |= RFHEAP;
	else
		ba_flags &= ~RFHEAP;	// inHeap arg to flags bit
	ba_flags |= RFSTAT;			// disable realloc and var data
	mn = 0;  					// minimum subscript is 0 for static (to save space: 1 large record is typical)
	nAl = _n;
	n = _n - 1;
	for (TI i = mn; i <= n; i++)
		conRec( i, noZ);		// construct all records now.  0 members unless noZ.
}		// basAnc::statSetup
//---------------------------------------------------------------------------------------------------------------------------
BP FC basAnc::anc4n( USI an, int erOp/*=ABT*/)		// access anc for anchor number
{
	if (an < 1 || an > Nanc || ancs[an]==0)
	{
		err( erOp, MH_X0053, an);  		// "anc4n: bad or unassigned record anchor number %d"
		return 0;
	}
	return ancs[an];
}			// basAnc::anc4n
//-----------------------------------------------------------------------------
record* basAnc::Get1stForOwner(int ss)
{
	record* r = nullptr;
	RLUPTHIS(r)
	{
		if (r->ownTi == ss)
			break;
	}
	return r;
}		// basAnc::Get1stForOwner
//---------------------------------------------------------------------------------------------------------------------------
RC FC basAnc::findAnchorByNm( char *_what, BP * _b)	// find anchor by name (.what) or return RCBAD (no msg here)
{
	BP b;
	size_t an = 0;
	while (ancNext( an, &b))			// iterate anchors
		if (!_stricmp( _what, b->what))		// if name matches
		{
			if (_b)  *_b = b;
			return RCOK;		// NULL _b may be given to just test for validity of anchor name
		}
	return RCBAD;
}			// basAnc::findAnchorByNm
//---------------------------------------------------------------------------------------------------------------------------
int FC basAnc::ancNext( size_t &an, BP * _b)		// (registered) record anchor iterator

// init an to 0.  each call returns FALSE if done or returns an and *_b set to next anchor
// example:  for (USI an = 0; ancNext( an, &b); )  { ... }
{
	while (static_cast<int>(++an) < Nanc)
		if (ancs[an])
		{
			*_b = ancs[an];     // skip (unexpected) NULL ptr
			return 1;
		}
	return 0;
}			// basAnc::ancNext
//---------------------------------------------------------------------------------------------------------------------------
/*static*/ RC basAnc::ba_ValidateSafe(
	const basAnc* _this,
	const char* fcnName,	// calling fcn name, for err msgs.
	int erOp /*=ABT*/,		// reporting control. ABT-->PABT, WRN-->PWRN here.
	bool noStat /*=false*/) // false: caller's action OK on static-storage anchor. true: not ok.
{
	return _this == nullptr
		? err(erOp, MH_X0054, fcnName) // "%s() called for NULL object pointer 'this'".
		: _this->ba_Validate(fcnName, erOp|PROGERR, noStat);	

}	// basAnc::ba_ValidateSafe
//---------------------------------------------------------------------------------------------------------------------------
RC basAnc::ba_Validate(	// validate an anchor: check self-consistency of anchor and its entry 0

	const char* fcnName,	// calling fcn name, for err msgs.
	int erOp /*=ABT*/,		// reporting control. ABT-->PABT, WRN-->PWRN here.
	bool noStat /*=false*/ ) const // false: caller's action OK on static-storage anchor. true: not ok.

// if error, issues message, returns non-RCOK if not ABT
{
	const record *p = ptr();			// fetch NULL or dm block ptr from derived class anchor
	erOp |= PROGERR;					// any errors here are internal errors (cnglob.h)

	if ((p && (p->rt != rt			// check self-consistency: if bk alloc'd & rt does not match
				|| p->b != this))	//     or bk 0 doesn't point back at base
	  || !(rt & RTBRAT) )			//   or base rt not a RAT rt
		return err( erOp, MH_X0055, fcnName);	// errMsg "%s() argument not a valid anchor" & abort or return per erOp. rmkerr.cpp.

	if (noStat && (ba_flags & RFSTAT) )			// check staticness
		return err( erOp, MH_X0056, fcnName);  	// "%s(): illegal use of static-storage anchor"

	return RCOK;							// if here, all OK
}			// basAnc::ba_Validate
//---------------------------------------------------------------------------------------------------------------------------
/*static*/ RC basAnc::FindRecByName( 		// find record by name (and owner) match
	const basAnc* _b,		// basAnc in which to search (nullptr OK, returns RCBAD)
	const char* _name, 		// record name to look for
	int ownerTIOpt /*=0*/,	// low bits = TI of owner (0=don't care)
							// hi bits:
							//   frn1STMATCH: accept 1st match
							//   frnUNIQUE: check for uniqueness (search all entries)
							//   frnACCEPTNONOWNER: accept non-owner match when unambiguous name match
	record **pr1 /*=nullpr*/,   // nullptr or receives entry ptr if found
	TI* pTi /*=nullptr*/,		// nullptr or receives TI (subscript) of record found
	record **pr2 /*=nullptr*/)	// nullptr or receives 2nd entry found

// IMPORTANT: FindRecByName() is static to support _b == nullptr (happens when b->tyB == nullptr).
//   Cannot be a member function because clang objects to this==nullptr.

// returns:   found: RCOK,   *pr1 set.
//         no match: RCBAD,  *pr1 nullptr
//  ambiguous match: RCBAD2, *pr1 and *pr2 point to 1st 2 matching entries
{
	RC rc = RCBAD;

	record* r1{ nullptr };	// return values
	record* r2{ nullptr };
	TI ti1{ 0 };

	// Treat _b==nullptr as "not found" (RCBAD)
	//   WHY: occurs re DEFTYPE and _b->tyB==nullptr
	//        (there may be additional cases)
	if (_b)		// if no basAnc, return RCBAD
	{
		// bool b1stMatch = ownerTIOpt & frn1STMATCH implied by !(frnUNIQUE || frnACCEPTNONOWNER)
		TI ownerTi = ownerTIOpt & frnTIMASK;
		bool bUnique = ownerTIOpt & frnUNIQUE;
		bool bAcceptNonOwner = ownerTIOpt & frnACCEPTNONOWNER;
		record* r;
		int nHits = 0;
		bool ownerSeen = false;
		RLUPGEN(*_b, r)					// loop over records, setting r to point to each good one
		{
			if (!bAcceptNonOwner
			 || (!ownerSeen || (ownerTi != 0 && ownerTi == r->ownTi)))		// if no owned match yet or correct owner
			{
				if (!r->IsNameMatch(_name))
					continue;	// no name match
				if (ownerTi != 0)
				{	if (r->ownTi == ownerTi)
					{	// owner matches
						if (!ownerSeen && bAcceptNonOwner)
							nHits = 0;		// forget any name matches with wrong owner
						ownerSeen = true;
					}
					else if (!bAcceptNonOwner)
						continue;
				}

				if (++nHits == 1)		// if 1st match
				{
					r1 = r;		// first found
					ti1 = r->ss;
					rc = RCOK;
					if (!(bUnique || bAcceptNonOwner))
						break;
					// else continue
				}
				else if (nHits == 2)	// if 2nd match
				{	// 2nd found
					r2 = r;
					rc = RCBAD2;		// bad (ambigous) return
					break;
				}
			}
		}
	}

	// return results
	if (pr1)
		*pr1 = r1;
	if (pTi)
		*pTi = ti1;
	if (pr2)
		*pr2 = r2;
	return rc;
}			// basAnc::FindRecByName
//-----------------------------------------------------------------------------
const char* basAnc::getChoiTx( 	// return text of given value for a choice data type, for error messages
	int fn, 	// field number. rccn.h define, eg AHU_TSU.  Field must have a "choicb" data type.
	int options /*=0*/,				// option bits
									//  1: no error messages for out of range chan
									//     (return displayable text indicating error)
	SI chan,	// value in field, or CHN(value) if a CHOICN type.
				// Possible internal values are C_xxxxxCH_yy defines in dtypes.h;
				// each internal value has a string that this fcn retreives
	BOOL* pIsHid /*=NULL*/) const	// optional return TRUE iff choice is hidden
										//   text returned w/o "*"

// if option&1 and chan out of range (but b and fn valid), displays no errMsg, so can be called b4 checking chan.
//  Recommend that caller not display returned text b4 checking for valid chan value. */

// returns string representing value; displayable even if error.
{

	// add more checks to this code if errors tend to happen...

	USI fdTy = fir[fn].fi_fdTy;				// get field type (sFdtab subscript) from rat's "Fields In Record" table
	USI dt = sFdtab[fdTy].dtype;			// get data type from small Fields info Table

	chan &= ~NCNAN;					// clear special bits in nchoice value to make checks work
	if (options & 1)
	{	// added 3-1-94 as insurance -- no choicn calls at present.
		if (chan==0)  					// if unset
			return "<0>";				// bypass getChoiTx's error messages
		if (chan <= 0 || chan > GetDttab(dt).nchoices)	// if call good but field contents garbage (GetDttab: srd.h)
			return "<out of range>";				// issue no console error message here (caller already generating errmsg).
	}

	int pTyX;
	const char* chtx = ::getChoiTxI( dt, chan, &pTyX);	// get text for value 'chan' for data type dt.
    													// Errors issue messages but also return displayable value.
	if (pIsHid)
		*pIsHid = pTyX == chtyHIDDEN;
	return chtx;
}				// basAnc::getChoiTx
//=============================================================================

//*****************************************************************************
//  stuff for storing fileNames for record.fileIx member, used from cuTok.cpp etc etc 2-94
//	There is no provision for deleting a file name: indeces remain valid till end session.
//*****************************************************************************
const int FNCACHESZ = 50 + 1;				// max # file names to save, + 1 for unused 0 slot.
LOCAL char* fnCache[ FNCACHESZ] = { 0 };	// file names seen. [0] not used.
static bool tmfemFlag = false;				// issue error message only once
//---------------------------------------------------------------------------
void clearFileIxs()
{
	for (USI i = 0; i < FNCACHESZ; i++)
		dmfree( DMPP( fnCache[i]));		// free heap block if ptr not NULL, set ptr NULL.

	tmfemFlag = false;				// issue error message only once
}
//---------------------------------------------------------------------------
int getFileIx( 		// get file name index (fileIx) for file name

	const char* name, 				// name, not necessarily null-terminated
	int len /*=-1*/,				// length, or -1 if null-terminated
	char * * pFName4Ix /*=NULL*/ )	// NULL or receives pointer to null-terminated name in heap.
									// can receive NULL if table full.
{
	if (len < 0)
		len = strlenInt(name);

// search saved names, return existing index if found
	int i;
	for (i = 1;  i < FNCACHESZ && fnCache[i];  i++)
		if ( int( strlen(fnCache[i])) == len
		 && _strnicmp( name, fnCache[i], len)==0 )
			break;  						// found. i is index to return.

// i is index of found name, free slot, or off end table if full
	char *p = NULL;						// string ptr to optionally return
	if (i >= FNCACHESZ)
	{
		if (!tmfemFlag)					// issue too many files error message only once
		{
			tmfemFlag = true;
			err(WRN, "More than %d input files\n"
				 "    (enlarge \"fnCache[]\" in ancrec.cpp)",
				 FNCACHESZ);
		}
		// fall thru to return FNCACHESZ for files in excess of max
	}

// add to table
	else							// did not run off end of table
	{	if (!fnCache[i])						// if found free slot (not match)
			if (!dmal( DMPP( fnCache[i]), len+1, WRN|DMZERO))	// allocate space for name and null, dmpak.cpp.
				memcpy( fnCache[i], name, len);			// if ok, store name text
		p = fnCache[i];						// pointer to name text for optional return
	}

// optionally return heap text pointer
	if (pFName4Ix)
	{	dmfree( DMPP( *pFName4Ix));	// decrement ref count of prior value we are about to overwrite
		dmIncRef( DMPP( p));		// NOP if NULL
		*pFName4Ix = p;
	}
	return i;
}		// getFileIx
//---------------------------------------------------------------------------
const char* getFileName( int fileIx)		// get text for file name index
{
	if (fileIx > 0  &&  fileIx < FNCACHESZ  &&  fnCache[fileIx])
	{	const char* p = fnCache[fileIx];	// NOT INCREF'd: only for transitory use in error messages, etc.
		if (TestOptions & 1)
			// hide dirpaths, set from command line -t
			//   allows location-independent reference report files
			p = strpathparts( p, STRPPFNAME+STRPPEXT);
		return p;
	}

	if (fileIx > FNCACHESZ)
		return "(too many files)";

	return "(bug)";				// (or memory was full at name save)
}			// getFileName
//-----------------------------------------------------------------------------

// end of ancrec.cpp
