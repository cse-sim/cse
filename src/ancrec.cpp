// Copyright (c) 1997-2019 The CSE Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file.

// ancrec.cpp: base class functions for records and record anchors, for CSE, 2-92.

/* A "record anchor" (class anc<rec name>) is a small, usually static, object that
     points to and holds info about a block of static or heap memory that contains an array of records.
   The records in the array are of a class derived from class 'record'.
   Record and anchor definitions are generated by rcdef.exe. */


// conversion notes
//  review each use of RATFRONT and RATFRONTSZ
//  cnglob: remove all rat stuff at least for now; remove ifndef GLOBs here.

// pending
//  be sure rcdef generates eSz via sizeof

// record changes
//  ALL records named & ownable; edit dbns, names, ownTi's out of cnrecs.def.
//   ZNISUB name must move to ZNI/ZNR.
//   ownTi name in code must be changed to "ownTi", or special rcdef feature.

// ideas
//  do statSetup() setup from constructor: would fit uses; rcdef changes needed?
//		above comment is pre-multi-run (1993), less clear with multi-run and DLL use.

#include "cnglob.h"
#include "ancrec.h"
#include "cse.h"
#include "msghans.h"	// MH_X0050
#include "messages.h"	// msgIsHan
#include "exman.h"
#include "cvpak.h"
#include "srd.h"		// SFIR


//***************************************************************************************************************************
//  class record: base class for application records.
//		destructor: inline, ancrec.h.
//***************************************************************************************************************************
record::record(BP _b, TI i, SI noZ/*=0*/)  	// construct record i of basAnc b, zero all members unless noZ
{
	/* possible conditional statSetup elimination:
	   if (i==0  (and at least b->rt matches if no validate()) and  b->p==0 and b->n < b->mn,
					set b->p=this, mn/n/nAl 1 record, RFSTAT.   BE SURE to override mn: 1-->0.
	   if (i > 0 and b RFSTAT and b->p consistent and b->n==i-1,
					b->n++ : additional record in static array.
	   CAUTION can be called from statSetup (til eliminated). */

	_b->validate("record::record");		// abort if base bad -- we depend on it for size
	if (!noZ)							// can be suppressed for data-init (static) records
		memset((char *)this + SZVFTP, 0, _b->eSz - SZVFTP);	/* zero all members of DERIVED CLASS record
								   except virtFcnTblPtr in 1st 2 or 4 bytes (ancrec.h define) */
	b = _b;
	rt = _b->rt;
	ss = i;  			// set base class members, for appl and anchor class use
	gud = 1; 						// say space in use and record good
}			// record::record
//---------------------------------------------------------------------------------------------------------------------------
void* record::field( int fn) 				// point to member in record by FIELD #
{	return (void *)((char *)this + b->fir[fn].off);  }
//-----------------------------------------------------------------------------
const void* record::field( int fn) const
{	return (const void *)((const char *)this + b->fir[fn].off);  }
//-----------------------------------------------------------------------------
void record::RRFldCopy(		// record-to-record field copy
	const record* r,	// source record (same type as this)
	int fn)				// field #
// handles NaNs re expressions
{
#if defined( _DEBUG)
	if (b->rt != r->b->rt)
		err( PWRN, "%s:%s RRFldCopy: RT mismatch",		// message, wait for keypress
			b->what, name);
#endif
	int dt = DType( fn);
	int sz = GetDttab( dt).size;
	memcpy( field( fn), r->field( fn), sz);
	fStat( fn) = r->fStat( fn);
}	// record::RRFldCopy
//-----------------------------------------------------------------------------
void record::FldCopy(		// field-to-field copy (within record)
	int fnS,		// source field #
	int fnD)		// destination field #
// handles NaNs re expressions
{
	int dtS = DType( fnS);
#if defined( _DEBUG)
	int dtD = DType( fnD);
	if (dtD != dtS)
		err( PWRN, "%s:%s FldCopy: DT mismatch",		// message, wait for keypress
			b->what, name);
	if (IsAusz( fnS))
		err( PWRN, "%s:%s FldCopy: source is AUTOSIZEd",
			b->what, name);
#endif
	int sz = GetDttab( dtS).size;
	memcpy( field( fnD), field( fnS), sz);
	fStat( fnD) = fStat( fnS);
}	// record::FldCopy
//-----------------------------------------------------------------------------
int record::DType( int fn) const
{	int fdTy = b->fir[ fn].fdTy;	// get field type (sFdtab subscript) from rat's "Fields In Record" table
	int dt = sFdtab[ fdTy].dtype;	// get data type from small Fields info Table
	return dt;
}		// record::DType
//-----------------------------------------------------------------------------
float record::FldValFloat(int fn) const
{
	int dt = DType(fn);
	const void* pV = field(fn);
	float v = 0.f;
	if (dt == DTFLOAT)
		v = *(FLOAT*)pV;
	else if (dt == DTDBL)
		v = float(*(DBL*)pV);
	else
		err(PWRN, "record::FldValFloat -- unsupported dt=%d", dt);
	return v;
}		// record::FldValFloat
//-----------------------------------------------------------------------------
int record::IsNameMatch( const char* _name) const
{
	// Note: prior (1994) version disregarded unexpected excess chars
	return !_strnicmp( _name, name, sizeof(ANAME)-1);
}		// record::IsNameMatch
//-----------------------------------------------------------------------------
/*virtual*/ record& record::CopyFrom(
	const record* src,
	int copyName/*=1*/,
	[[maybe_unused]] int dupPtrs/*=0*/)

// copy user and ul data from another record or init data to already-constructed record

// copies user language overhead, and ownTi, and, unless suppressed, name.
// Does not copy ancrec internal overhead except 'gud'

/* "dupPtrs" is for poss future use duplicating heap pointers in derived classes
   (in present uses (input to run rat copies) ptrs are not currenly being dup'd 2-92)
   (7-92: converting to dup'd ptrs with explicit derived class CopyFrom's and destructors.
   "dupPtrs" would shorten code; table bit or different field ty needed to say which ptrs to dup (some CHP's don't get dup'd). */
{
// error if not init (can't constr here: need b, ss). (if needed, do a "copyTo" or a "copy(b,i1,i2)" that constructs dest.)
	if (!b)								// (or gud? wd error here if init then destroyed)
		err( PABT, (char *)MH_X0050);	// error msg "record::CopyFrom: unconstructed destination (b is 0)" and abort program.
#ifdef DEBUG2							// message not occuring (1-95) so omit from release version.
	b->validate("record::CopyFrom");	// abort if record 'this' not associated with valid anchor
	((record *)src)->Validate();
#endif

// use shorter record length
	int eSz = b->eSz;				// get dest derived class rec length from anchor
	if ( src->b  &&  src->b->rt==src->rt   	// if source has anchor (could be just init data)
			&&  eSz != src->b->eSz )			// and source record length is different
		eSz = min( b->sOff, src->b->sOff);	// use the shorter length and do not copy status bytes (3-12-92).
	//  calls exist (ZNI->ZNR) where source is start of dest record (ug!)
	//  add logic to copy status bytes to correct place if need found

// copy data after front (bitwise)
#if 1	// fix re packing, 11-14-2018
	// copy start offset: do not copy base class except ownTi and optionally name
	int offBeg = copyName ? offsetof(record, name) : offsetof(record, ownTi);
	memcpy( (char *)this + offBeg,  (char *)src + offBeg,  eSz - offBeg );
#else
0	int rfSz = sizeof(record) - sizeof(TI);	// do not copy base class except ownTi
0	if (copyName)
0		rfSz -= sizeof(ANAME);				// copy name on option (defaults ON)
0	memcpy((char *)this + rfSz, (char *)src + rfSz, eSz - rfSz);
#endif

// copy user language front members. another arg option?
	li = src->li;			// if nz, is subscript of entry it is LIKE
	ty = src->ty;			// if nz, may be TYPE subscript (future)
	fileIx = src->fileIx;   		// if nz, is index of object input fileName
	line = src->line;   		// if nz, is object input file line

// copy internal good-record flag with possible future user bits
	gud = src->gud;			// 0 = free, > 0 = in use, sign bit = bad (poss future use).

	FixUp();		// virtual: record can e.g. fix ptrs
#if defined( _DEBUG)
	Validate();		// virtual
#endif
	return *this;
}			// record::CopyFrom
//---------------------------------------------------------------------------------------------------------------------------
/*virtual*/ void record::Copy(	// copy user and ul data and 'gud' from another record of same type
	const record* pSrc,
	int options/*=0*/)
{
	options;

	// this implementation requires records already constructed (can't construct here without knowning b, ss).
	if (!b)						// (or gud? wd error here if init then destroyed)
		err( PABT, (char *)MH_X0051);  	// err msg "record::operator=(): unconstructed destination (b is 0)" and abort program
	if (b->rt != pSrc->b->rt)  				// check for same rt (same derived class)
		err( PABT, (char *)MH_X0052);			// err msg "record::operator=(): records not same type" and abort program
	b->validate("left arg to record::operator=");	// abort if records not well anchored
#ifdef DEBUG2
	pSrc->b->validate("right arg to record::operator=");
#endif
#if 1	// fix re packing, 11-14-2018
	// copy start offset: don't copy internal members
	int offBeg = offsetof(record, gud);
	memcpy((char *)this + offBeg, (char *)pSrc + offBeg, b->eSz - offBeg);
#else
0	const USI rfSz = offsetof(record,rt)   				// don't copy: anything C++ put in front of 1st member,
0					 + sizeof(RCT) + sizeof(TI)			// internal overhead members, at front: rt, ss,
0					 + sizeof(BP) /* + sizeof(SI)*/;   	// ... b;  do copy 'gud' (semi-user member).
0	memcpy( (char *)this + rfSz, (char *)pSrc + rfSz, b->eSz - rfSz);	// copy everthing after that stuff.
#endif
	FixUp();		// virtual: record can e.g. fix ptrs
#if defined( _DEBUG)
	Validate();		// virtual
#endif
}			// record::Copy
//-----------------------------------------------------------------------------
const char* record::getChoiTx(
	int fn,				// field #
	int options /*=0*/,	// option bits
						//  1: no error messages for out of range chan
						//     (return displayable text indicating error)
	SI chan /*=-1*/,	// current choice (default = from record)
	BOOL* pIsHid /*=NULL*/) const	// optional return: TRUE iff choice is hidden
									//   text returned w/o "*"
// returned: choice text
{
	if (chan < 0)
	{	SI* pCh = (SI *)field( fn);
		if (pCh)
			chan = *pCh;
	}
	const char* text = b->getChoiTx( fn, options, chan, pIsHid);

	return text;

}		// record::getChoiTx
//-----------------------------------------------------------------------------
record* record::getOwner() const
// return ptr to owner record
//  NULL if linkage bad
{
	BP bOf = b->ownB;
	record* r = bOf ? bOf->GetAtSafe(ownTi) : NULL;
	if (!r)
		oer("getOwner() fail for %s", objIdTx());
	return r;
}	// record::getOwner
//-----------------------------------------------------------------------------
const char* record::whatIn() const 	// return basAnc record owner text
// e.g.  "zone 'Z1'"  or  "sgdist 'foo' of glazing 'gl1' of zone 'Z1'"
{
	BP bOf = b->ownB;   			// item's owner's basAnc
	if (bOf==0)
		return "<whatIn: null b->ownB>";
	if (ownTi > bOf->n)
		return "<whatIn: ownTi > b.n>";
	return bOf->rec( ownTi).objIdTx( 	// string of class, name, its owner, etc. next.
					1 );				// say show [file(file)] in 1st object if unnamed
}	// record::whatIn
//-----------------------------------------------------------------------------
int record::IsSetCount(			// count # of set fns in list
	int fn, ...) const	// 0 terminated fn list (don't forget the 0!)
// returns # of IsSet() fields
{	va_list ap;
	va_start( ap, fn);
	int nSet = 0;
	while (1)
	{	if (fn == 0)
			return nSet;
		nSet += IsSet( fn);
		fn = va_arg( ap, int);
	}
}		// record::IsSetAny
//-----------------------------------------------------------------------------
int record::IsValAll(		// check for resolved (non-expression) values
	int fn, ...) const	// 0 terminated fn list (don't forget the 0!)
// return 1 iff all fields have values
{	va_list ap;
	va_start( ap, fn);
	while (1)
	{	if (fn == 0)
			return 1;		// at end, all have values
		if ((fStat( fn) & (FsSET|FsVAL)) == FsSET)
			return 0;		// no value, stop
		// else set with non-expression or default
		fn = va_arg( ap, int);
	}
}		// record::IsValAll
//-----------------------------------------------------------------------------
const char* record::objIdTx(

	/* ret Tmpstr string identifying object, conditionally showing owner(s), eg:
		zone "sleep"
		3rd layer of construction "wallCon3"
		sgdist of window [file(99)] of surface [file(97)] of zone "sleep" */

	int op/*=0*/) const	// option: 1: if object unnamed, use "[<file>(<line>)]":
    			    //   use 0 if shown elsewhere in msg.
                    //   (  internally determined for "of ..."'s)
{
	const char* s="";
	const char* tween="";
	int nameShown=0;

	const record* r = this;
	for ( ; ; )
	{
		// verify basAnc record ptr
		if (r->b->rt != r->rt/*  || r->ss <= 0*/)	// part commented out 1-21-92 rejects Top.
			err( PWRN, (char *)MH_S0273);			// display internal error msg, wait for key, rmkerr.cpp.
													// "*** objIdTx(); probable non-RAT record ptr ***"
		s = scWrapIf( s, 						// concat string so far (s) w
					  strtcat( tween, r->classObjTx( op), NULL),		// class and object name text,
					  "\n    ");   					// inserting __ if line wd be too long
		tween = " of ";
		if (r->name[0])					// if name is not ""
			nameShown++;
		if ( r->b->ownB==0 || r->ownTi <= 0		// or basAnc has no owning basAnc, or record has owning record,
				||  r->ownTi > ((BP)r->b->ownB)->n 		// or owner subscr out of range (catches erroneous Top ownership)
				||  nameShown >= 2 )				// or have shown enuf names
			break;
		r = &r->b->ownB->rec(r->ownTi);			// point owning record
		op = nameShown ? 0 : 1;				/* show unnamed obj [file(line)] if no name yet shown,
       							   after 1st iteration (1st per caller). */
	}
	return s;
}	// record::objIdTx
//-----------------------------------------------------------------------------
const char* record::classObjTx(		// get class name - object name text
	int op/*=0*/) const	// option: 1: if no name, use "[<file>(<line>)]"

// examples: zone "main"		surface "foo"
//   3rd layer			sgdist [bldg(231)] */

// caution: return value is in Tmpstr: transitory!
{

// verify basAnc record arg (C compiler doesn't as void used for varying types)
	if (b->rt != rt)
		err( PWRN, (char *)MH_S0274); 	// display internal error msg, wait for key, rmkerr.cpp
	// "*** classObjTx(); probable non-RAT record arg ***"

	const char* what = (char *)b->what;  		// class name from basAnc

// if it has a name ...
	if (name[0])			// if this record has nonblank name
		return strtprintf("%s '%s'", what, name);

#if 0		// .bn gone, have not replaced this mechanism (only use yet found: layer, cncult2.cpp.)
o// else if it has object-number-for-owner in bn member, show that
o    if (R->bn)					// e.g. layer # for construction (cncult.cpp)
o       return strtprintf( "%s %s",
o                          ordinal(R->bn),	// form "1st", "2nd", etc
o                          what );
#endif

// else if it has file and line, optionally show them
	if (op)
		if (fileIx)
			return strtprintf("%s [%s(%d)]", what, getFileName( fileIx), line);

// else just class name
	return what;
}		// record::classObjTx
//-----------------------------------------------------------------------------
RC record::CkSet( 	// verify that required member has been set
	int fn)	const // field number

// call only for RQD fields -- issues inappropriate msg for others

// if not set, returns non-RCOK.  issues message only if errCount is 0 -- else assumes previously messaged.
{
// return ok if has-been-set-by-user-input bit on in field's field status byte
	if (IsSet( fn))
		return RCOK;

// not set.  Msg should have been issued at end of object; avoid repeating.
	if (errCount()) 		// if there have been any messages at all (rmkerr.cpp fcn)
		return RCBAD;		// return bad, no msg here

	// unset field but no messages at all have been issued this run.
	// Unexpected, but issue msg here to prevent mysterious messageless non-runs.
	// Devel aid.  Might occur, for example, if RQD flag removed on member and
	// code that calls here not updated to match (defaults do not set FsSET).
	return oer( (char *)MH_S0493,	// "Required member '%s' has not been set,\n"
										// "    and apparently no message about it appeared above"
				MNAME(b->fir + fn) );		// macro (srd.h) accesses mName, possibly in special segment
}	// record::CkSet
//-----------------------------------------------------------------------------
/*virtual*/ int record::ReportBalErrorsIf(
	int balErrCount,			// error count
	const char* ivlTxt) const	// interval text (plural), e.g. "subhours"
// report energy balance error
// returns # of balance error count
{
	if (balErrCount > 0)
	{	const char* what = objIdTx();
		warn("%s: Energy balance errors occurred in %d %s.",
			what, balErrCount, ivlTxt);
	}
	return balErrCount;
}		// record::ReportBalErrorsIf


///////////////////////////////////////////////////////////////////////////////
// record data checking member functions
///////////////////////////////////////////////////////////////////////////////
RC record::limitCheck(		// range check, issue warning or error msg
	int fn,				// field
	double vMin,		// min allowed value
	double vMax,		// max allowed value
	double vMinWarn /*=-DBL_MAX*/,	// min for warning
	double vMaxWarn /*=DBL_MAX*/)	// max for warning
// return RCOK if field not set or value is in range or warning msg
//        else RCxx if value out of range (msg issued)
{
	RC rc = RCOK;
	if (IsVal(fn))
	{	// value is user-provided and known
		//   not CULT default
		//   not unevaluated expression
		double v = FldValFloat(fn);
		if (v < vMin || v > vMax)
			rc = oer("%s (%g) must be in range %g - %g",
				mbrIdTx(fn), v, vMin, vMax);
		else if (v < vMinWarn || v > vMaxWarn)
		{	// warning (do not return RCBAD)
			// use vMin / vMax instead of default DBL_MAX (avoid showing 10e+308)
			//    if here, at most one can be DBL_MAX
			if (vMinWarn == -DBL_MAX)
				vMinWarn = vMin;
			else if (vMaxWarn == DBL_MAX)
				vMaxWarn = vMax;
			oWarn("dubious %s (%g) typically should be in range %g - %g",
				mbrIdTx(fn), v, vMinWarn, vMaxWarn);
		}
	}
	return rc;
}		// record::limitCheck
//-----------------------------------------------------------------------------
RC record::limitCheckFix(	// range check, msg, set to min/max
	int fn,			// field
	float vMin,		// min allowed value
	float vMax,		// max allowed value
	int erOp /*=ERR*/)		// WRN/ERR/IGN etc
							// note IGNX bit: limit only (don't msg)
// return RCOK if field not set or value is in range or warning msg
//        else RCxx if value out of range (msg issued)
{
	RC rc = RCOK;
	void* p = field(fn);
	if (!ISNANDLEP(p))
	{
		float* pV = (float*)p;
		float v = *pV;
		if (v < vMin || v > vMax)
		{
			rc = orMsg(erOp, "%s (%g) must be in range %g - %g",
				mbrIdTx(fn), v, vMin, vMax);
			*pV = bracket(vMin, v, vMax);
		}
	}
	return rc;
}		// record::limitCheckFix
//-----------------------------------------------------------------------------
RC record::limitCheckRatio(		// check the ratio of two fields
	int fn1,	// field 1
	int fn2,	// field 2
	double vMin,	// min allowed val for f1/f2
	double vMax)	// max allowed val for f1/f2
// NOTE: No field status checks
//       Caller must ensure values set (not unevaluated expressions)
// returns RCOK iff ratio is within (vMin, vMax)
{
	RC rc = RCOK;

	double v1 = FldValFloat(fn1);
	double v2 = FldValFloat(fn2);

	double vRat = v2 != 0. ? v1 / v2 : 0.;

	if (v2 == 0. || vRat < vMin || vRat > vMax)
		rc = oer("The ratio %s (%g) / %s (%g) is %g; it must be in range %g - %g",
			mbrIdTx(fn1), v1, mbrIdTx(fn2), v2, vRat, vMin, vMax);
	return rc;
}	// record::limitCheckRatio
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
//   'record' MEMBER FUNCTIONS TO REQUIRE/DISALLOW FIELDS (class declaration: ancrec.h)
///////////////////////////////////////////////////////////////////////////////
static void WhenSave(const char*& when, char* whenBuf, size_t whenBufSize)
// optionally make stack copy of possible Tmpstr
{
	if (!msgIsHan(when))					// not if handle given
		if (when)   						// copy arg to local buffer in case in Tmpstr[], ...
			when = strncpy0(whenBuf, when, whenBufSize);	// so any (possible future) strtprintf's in following loop
															// won't overwrite it
}	// WhenSave
//-----------------------------------------------------------------------------
RC record::ValidateFN(int fn, const char* caller) const
{
	RC rc = RCOK;
	if (fn < 0 || fn > 1024)
		rc |= oer((char*)MH_S0495,	// "%s Internal error: field # %nd: unterminated arg list?"
				   caller, fn);
	return rc;
}	// record::ValidateFN
//-----------------------------------------------------------------------------
RC record::checkN(			// general purpose check multiple fields
	const char* when,		// message insert.  message handle ok (see messages.cpp).
	RC(record::* checkFcn)(const char* when, int fn),	// check function called for each field
	va_list ap)				// int field numbers, 0 ends list  REMEMBER THE 0!
{
	RC rc = RCOK;

	char whenBuf[1000];
	WhenSave(when, whenBuf, sizeof( whenBuf));

	for (; ; )
	{
		int fn = va_arg(ap, int);
		if (!fn)
			break;
		rc |= (this->*checkFcn)(when, fn);
	}
	return rc;
}		// record::checkN
//-----------------------------------------------------------------------------
RC record::checkN(			// general purpose check multiple fields
	const char* when,		// message insert.  message handle ok (see messages.cpp).
	RC(record::* checkFcn)(const char* when, int fn),	// check function called for each field
	const int16_t* fnList)		// array of field numbers, 0 ends list  REMEMBER THE 0!
{
	RC rc = RCOK;

	char whenBuf[1000];
	WhenSave(when, whenBuf, sizeof(whenBuf));

	int fn = 0;
	for (int iFn = 0; fn = fnList[iFn]; iFn++)
		rc |= (this->*checkFcn)(when, fn);
	return rc;
}		// record::checkN
//-----------------------------------------------------------------------------
RC record::disallowN( 			// issue "not allowed" message for each given field in 0-terminated list of field numbers
	const char* when,	// NULL or message insert.  message handle ok (see messages.cpp).
	...)				// int field numbers, 0 ends list  REMEMBER THE 0!
{
	va_list ap;
	va_start(ap, when);
	RC rc = checkN(when, &record::disallow, ap);
	return rc;
}		// record::disallowN
//-----------------------------------------------------------------------------
RC record::disallow( 		// issue "not allowed" message for each given field in an array of field numbers
	const char* when,	// NULL or message insert.  message handle ok (see messages.cpp).
	const int16_t* fnList)	// array of field numbers, 0 ends list  REMEMBER THE 0
{
	RC rc = checkN(when, &record::disallow, fnList);
	return rc;
}		// record::disallow
//-----------------------------------------------------------------------------
RC record::disallow(     			// issue "not allowed" message if field is given
	const char* when,	// NULL or message insert, worded for work context "Can't give <f> <when>", handle ok
	int fn)
{
	RC rc = ValidateFN(fn, "disallow");
	if (!rc && fn && IsSet(fn))		// if value for field given in user input (test field status byte)
		rc = cantGiveEr(fn, when);
	return rc;
}			// record::disallow
//-----------------------------------------------------------------------------
RC record::requireN( 			// issue "missing" message for each omitted field in 0-terminated list of field numbers
	const char* when,	// NULL or message insert (message handle ok)
	...)				// int field numbers, 0 ends list  REMEMBER THE 0!
{
	va_list ap;
	va_start(ap, when);
	RC rc = checkN(when, &record::require, ap);
	return rc;
}		// record::requireN
//-----------------------------------------------------------------------------
RC record::require( 		// issue "missing" message for each given field in an array of field numbers
	const char* when,		// NULL or message insert.  message handle ok (see messages.cpp).
	const int16_t* fnList)	// array of field numbers, 0 ends list  REMEMBER THE 0
{
	RC rc = checkN(when, &record::disallow, fnList);
	return rc;
}		// record::require
//-----------------------------------------------------------------------------
RC record::require(    			// issue message if field is not given
	const char* when,	// NULL or message insert (msghan ok)
	int fn)				// field number
{
	RC rc = ValidateFN(fn, "require");
	if (!rc && fn && !IsSet(fn)) 		// if value for field not given in user input
		rc = notGivenEr(fn, when);
	return rc;
}			// record::require
//-------------------------------------------------------------------------------
RC record::ignoreN( 		// issue "ignored" message for each given field in 0-terminated list of field numbers
	const char* when,	// NULL or message insert.  message handle ok (see messages.cpp).
	...)				// int field numbers, 0 ends list  REMEMBER THE 0!
{
	va_list ap;
	va_start(ap, when);
	RC rc = checkN(when, &record::ignore, ap);
	return rc;
}		// record::ignoreN
//-----------------------------------------------------------------------------
RC record::ignore( 		// issue "ignored" message for each given in an array of field numbers
	const char* when,	// NULL or message insert.  message handle ok (see messages.cpp).
	const int16_t* fnList)	// array of field numbers, 0 ends list  REMEMBER THE 0
{
	RC rc = checkN(when, &record::ignore, fnList);
	return rc;
}		// record::ignore
//-----------------------------------------------------------------------------
RC record::ignore(     			// issue "ignored" message if field is given
	const char* when,	// NULL or message insert, worded for work context
	int fn)
{
	RC rc = ValidateFN(fn, "ignore");
	if (!rc && fn && IsSet(fn))			// if value for field given in user input
		rc = ignoreInfo(fn, when);
	return rc;
}			// record::ignore
//============================================================================

/****************************************************************************************************************************
*   'record' MEMBER FUNCTIONS TO MAKE CHANGE FLAG ENTRIES IN RUNTIME TABLES (class declaration: ancrec.h)
****************************************************************************************************************************/
void CDEC record::chafSelf( 		// say increment change flag IN SAME RECORD on change in list of fields of record
	SI chafFn, 		// field NUMBER of change flag: an SI field in same record
	...)			// 0-terminated list of field numbers in record to monitor for change if contain expressions
{
	va_list ap;
	va_start(ap, chafFn);
	chafNV(this->b, ss, b->fir[chafFn].off, ap);
}							// record::chafSelf
//============================================================================================================================
void CDEC record::chafN( 		// say increment specified flag during run on change in list of fields in curr record

	BP _b, TI i, USI off,   	// location of SI change flag: anchor, record subscript, offset in record
	...)			// 0-terminated list of field numbers

/* for each given field which contains an expression handle, make expression manager runtime table entry
  to increment flag at b-i-off when value of that expression changes. */
{
	va_list ap;
	va_start(ap, off);
	chafNV(_b, i, off, ap);
}								// record::chafN
//===========================================================================
void record::chafNV( 		// say increment specified flag during run on change in var list of fields in curr record

	BP _b, TI i, USI off,  	// location of SI change flag: anchor, record subscript, offset in record
	va_list ap)		// pointer to 0-terminated list of field numbers

// var arg list level for flexibility
{
	for (; ; )
	{
		int fn = va_arg(ap, int);
		if (!fn)
			break;
		if (fn > 1024)
			oer((char*)MH_S0495,    	// "cncult2.cpp:%s Internal error: field # %d: probable unterminated arg list"
				 "chavNV", fn);
		addChafIf((NANDAT*)field(fn), _b->ancN, i, off);  	/* test pointed to field contents, add increment-on-change
									   table entry if is expr handle.  exman.cpp. */
	}
}					// record::chafNV
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
// FUNCTIONS TO ISSUE SPECIFIC ERROR MESSAGES
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
RC record::cantGiveEr(   				// issue message (using ooer) for disallowed field that user gave
	int fn,
	const char* when /*=NULL*/)	// NULL or message insert, worded for work context "Can't give <f> <when>"
{
	return ooer(fn, 			// message for record & field if 1st error for field, & flag bad.
				 (char*)MH_S0496, 		// "Can't give '%s' %s"
				 mbrIdTx(fn),			// input name (id)
				 when ? strtprintf(when) : "");	// user's explanatory insert, eg "when no local heat".
												//   use strtprintf to retrieve text (to Tmpstr) if handle given.
}	// cantGiveEr
//-----------------------------------------------------------------------------
RC record::notGivenEr( 				// issue message (using ooer) for disallowed field that user gave
	int fn,
	const char* when /*=NULL*/)	// NULL or message insert, worded for work context "<f> missing: required <when>"
{
	if (when)
		return ooer(fn,  				// message if 1st error for record & field, & flag field bad
					 (char*)MH_S0497,	// handle of message "'%s' missing: required %s"
					 mbrIdTx(fn), 		// input name (id)
					 strtprintf(when));	// user's explanatory insert, eg "when tuTLh given"
											//   use strtprintf to retrieve text (to Tmpstr) if handle given.
	return ooer(fn, (char*)MH_S0498, 		// "'%s' missing"
				 mbrIdTx(fn));
}			// record::notGivenEr
//-----------------------------------------------------------------------------
RC record::ignoreInfo( 	// issue info message for ignored field
	int fn,
	const char* when /*=NULL*/)	// NULL or message insert
									// worded for context "<f> is ignored <when>"
{
	const char* msg = strtprintf(
			when ? "'%s' is ignored %s" : "ignoring '%s'",
			mbrIdTx(fn),
			strtprintf(when));			// when might be handle
	return oerI(1, 1, 2, msg, NULL);	// do msg using vbl arg list flavor of oer
}		// record::ignoreInfo
//-----------------------------------------------------------------------------
RC record::notGzEr(int fn)		// issue error message for field not greater than 0.  finds user name in CULTs.
{
	return ooer(fn, (char*)MH_S0499, mbrIdTx(fn));  	// "'%s' must be > 0"
}
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
// public helper functions
///////////////////////////////////////////////////////////////////////////////
RC ArrayStatus(		// count/check status of ARRAY elements
	const UCH* _sstat0,		// status array
	int count,	// # of values to check (dimension of array
	int& nSet,	// returned: # of array elements set (FsSet)
	int& nVal)	// returned: # of array elements with value (FsVAL)
// re checking of ARRAY input
// returns RCOK on success
//        RCBAD iff malformed (impossible unless bug?)
{	
	RC rc = RCOK;
	int n0 = 0;		// # of 0 status
	nSet = nVal = 0;
	for (int fn=0; fn < count; fn++)
	{	int stat = _sstat0[ fn];
		if (stat == 0)
			n0++;
		else
		{	if (n0)
				rc = RCBAD;		// 0 followed by non-0
			if (stat & FsSET)
				nSet++;
			if (stat & FsVAL)
				nVal++;
		}
	}
	return rc;
}		// ::ArrayStatus
//=============================================================================

//*****************************************************************************
//  class basAnc: base class for application record anchors.
//*****************************************************************************

//--- variables re "anchor numbers".  ancBase.ancN contains #.
const int MAXANCS = 200;	// Maximum number of basAncs supported
							//   actual required = ~65 12-20-2012
static BP ancs[ MAXANCS];	// table of pointers to contructed basAncs
							//   persists for entire session re multiple DLL cse() calls
							//   "big enuf" static array simplifies persistence
static int Nanc = -1;		// # of entries in anc[] (-1 = unintialized) (see regis())
//---------------------------------------------------------------------------------------
basAnc::basAnc()		// default c'tor (for derived copy c'tor
{
	memset( (char *)this+SZVFTP, 0, sizeof(*this)-SZVFTP); // SZVFTP: virtFcnTblPtr: cnglob.h.
}			// basAnc::basAnc
//---------------------------------------------------------------------------------------------------------------------------
basAnc::basAnc( int flags, SFIR * _fir, USI _nFlds, char * _what, USI _eSz, RCT _rt, USI _sOff, const CULT* pCULT, int dontRegister/*=0*/ )
{
	memset( (char *)this+SZVFTP, 0, sizeof(basAnc)-SZVFTP);		// zero all basAnc members but virtFcnTblPtr at front
	ba_flags = flags;
	fir = _fir;
	nFlds =_nFlds;
	what = _what;  	// store non-0 member values
	eSz = _eSz;
	rt = _rt;
	sOff = _sOff;		// ..
	mn = 1;				// min record subscript 1 (overwritten with 0 if static)
	// ptr() = 0;		// is done in derived class constructor (deriv vf not avail here; ptr is pure!)
	an_pCULT = pCULT;	// pointer to associated input CULT table, nullptr = unknown
	if (!dontRegister)
		regis();					// conditionally include anchor for nextAnc() iteration
}					// basAnc::basAnc
//--------------------------------------------------------------------------------------------------------------
/*virtual*/ basAnc::~basAnc()		// d'tor
{
	if (ba_flags & RFTYS)
		dmfree( DMPP( what));
}		// basAnc::~basAnc
//---------------------------------------------------------------------------------------------------------------------------
void FC basAnc::regis()				// "register" anchor for nextAnc() iteration.  Constructor helper.
{
	int an;
	if (Nanc < 0)		// if not initialized
	{	VZero( ancs, MAXANCS);
		Nanc = 0;
	}
	for (an = 1;  an < MAXANCS && ancs[an] && ancs[an] != this;  an++)		// find free pointer
		;							// (or one already set for this anc: reconstr insurance)
	if (an >= MAXANCS)
		err( PABT, "Insufficient anc[] space");
	ancs[an] = this;   			// set pointer in static array
	Nanc = max( Nanc, an);
	ancN = an;							// set index in anchor
}		// basAnc::regis
//---------------------------------------------------------------------------------------------------------------------------
void basAnc::desRecs( SI _mn, SI _n)
{
	//if (mn <= n)						// if any records allocated: protection for ptr vf call if nec??
	if (ptr())						// if record memory is allocated
		for (TI i = max(mn,_mn);  i <= min(n,_n);  i++) 	// loop allocated record spaces in range given by caller
			desRec(i);						// conditionally destroy record in space
}				// basAnc::desRecs
//---------------------------------------------------------------------------------------------------------------------------
void FC cleanBasAncs(	// destroy/free all basAnc records, and delete subsidiary "types" basAncs (.tyB)
		[[maybe_unused]] CLEANCASE cs)		// what is being cleaned
{
	if (ancs)					// skip if heap array not allocated
		for (USI i = 1;  i < Nanc;  i++)		// loop over basAnc ptrs in ancs
		{
			BP b = ancs[i];			// fetch ptr
			if (!b)
				continue;			// skip (unexpected) NULL pointer
			b->free();				// destroy b's records, free record memory unless static, clear flags
			delete b->tyB;
			b->tyB = NULL;
		}

//  if (cs == DONE || cs == CRASH)
//	{	// nothing to do
//	}
//  else
//		ancs[] is built by c'tor, thus must persist from entry to entry (all non-tyB ancRecs believed static).

	clearFileIxs();		// clear file names referenced by record.fileIx members
}	// cleanBasAncs
//---------------------------------------------------------------------------------------------------------------------------
void * FC basAnc::recFld( TI i, SI fn) 			// point record i member by FIELD #

/* note: this is not in ancrec.h to avoid needing to include srd.h first for sFIRstr;
   it is not virtual to avoid multiple copies.  delete later (3-92) if not used. */
{
	return (void *)((char *)&rec(i) + fir[fn].off); 	// get field offset from basAnc's fields-in-record table
}
//---------------------------------------------------------------------------------------------------------------------------
RC FC basAnc::al(       // destroy any existing records and allocate space for n (0=default) records
    TI _n,
    int erOp/*=ABT*/,
    BP _ownB /*NULL*/)      // optional: ptr to anchor whose objects own this anchor's objects

// use explicitly to alloc n spaces at once when n known, for speed & non-fragmentation.
{
    if (_ownB)
        ownB = _ownB;
	desRecs();					// destroy any existing records in place (without freeing storage block)
	return reAl( _n, erOp);			// (re)allocate to size _n, using existing block if possible.
} 				// basAnc::al
//---------------------------------------------------------------------------------------------------------------------------
RC FC basAnc::reAl( TI _n, int erOp/*=ABT*/)		// allocate space for n (0=default; does not count 0th) records

// preserves existing records.
// called automatically from basAnc::add if needed.
// could use explicitly to expand to n spaces at once when n known, for speed & non-fragmentation.

/* #if 1: note: b4 2-95, This was named al() and called externally with intent of clearing! and allocating,
                as well as from add() to expand. If any external calls intended to keep records, change to reAl().*/
{
#ifdef DEBUG2
	if (validate("basAnc::reAl", erOp))
		return RCBAD;	// check anchor
#endif
	if (_n < 1)
		_n = 1 + 1024/eSz;			// if # records not specified, use 1k's worth plus 1
	TI _nAl = _n+1;					// space [0] not used (all 0's for grounding) --> max subscr+1 is n+1
	size_t sz = (ULI)(USI)_nAl * eSz;	// size that must be allocated
#if 0	// remove 64k limit, 9-10
x	if (sz >= 0xFFF0)					// leave a few bytes for overhead.
x		return err( erOp, "Attempt to allocate more than 64K worth of '%s' records",
x					(char /*far!*/ *)what );					// returns RCBAD
#endif
	desRecs(_nAl, 32767); 				// insurance: destroy any excess existing records if making block smaller
	record* ptrWas = ptr();				// NULL if this is initial allocation
	RC rc = dmral( pptr(), sz, erOp|DMZERO);	// (re)alloc memory, zero new space, dmpak.cpp
	if (rc)								// if failed
		;								// leave variables unchanged
	else								// ok
	{
		nAl = _nAl;   					// save max alloc'd subscript+1.
		n = min(n, nAl - 1);			// make sure n is with allocated space		
		mn = 1;  						// insurance: mn is already 1.
		ba_flags |= RFHEAP;				// say block is in heap, should be free'd
		// the n record spaces are subscripted 1 to n.  The spaces are not "records" till constructed by add().
		// allocated but unused space[0] "grounds" unset references and allows using 0 subscript as "unset" indicator.
		// set front members in block's space[0] now, as req'd by validate's check when ptr nz.
		if (!ptrWas)				// do 1st time only to avoid compensating for bugs
		{
			ptr()->rt = rt;  			//   ... (rec(0) is not add'd, and anyway validate error would foil add.)
			ptr()->b = (BP)this;		// .ss is already 0.  .gud is left 0.
		}

		// loop all pre-reAl gud records
		for (int i=mn; i<=n ; i++)
			if (rec( i).gud)
				rec( i).FixUp();		// virtual, allow record to fix e.g. link ptrs
	}
	return rc;
} 		// basAnc::reAl
//---------------------------------------------------------------------------------------------------------------------------
RC FC basAnc::free()				// free (non-static) record memory block for anchor
{
	desRecs();  			// destroy any records: calls record-derived class virtual d'tor
	n = nAl = 0;
	mn = 1;					// minimum subscript 1 to be > n; also 1 expected by reAl/add.
	if (ba_flags & RFHEAP)	// do not free non-heap (static) block
		dmfree( pptr());	//   free memory block and set ptr() null
	ba_flags &= ~RFHEAP;	// clear all flags but non-heap flag
	return RCOK;
}					// basAnc::free
//---------------------------------------------------------------------------------------------------------------------------
RC basAnc::add(		// construct record i (0 = next). Allocs if nec.
	record **_r,	// returned: ptr to add record
	int erOp,		// error handling
	TI i/*=0*/,		// where to add
	const char* _name /*=NULL*/)	// optional name for added record
{
#ifdef DEBUG2
	if (validate("basAnc::add", erOp))	// check anchor
		return RCBAD;
#endif
	if (!i)						// if we are to choose record number
	{	i = mn;						// 1: record # 0 is not used
		if (ptr())
		{
			while (i <= n && rec(i).gud) i++;    // find record space with gud==0 else 1 more than last used.
		}
	}
	else if (i <= n  &&  rec(i).gud)  			// else if have (unexpected) request to "add" existing in-use record
		desRec(i);					// destroy that record's current contents (eg free deriv class heap ptrs)
	if ( i >= nAl  					// if (more) record spaces must be allocated (nAl is +1; i,n are not)
	 ||  !ptr() )   				// insurance
	{
		ULI sz = (ULI)nAl*eSz + 1024;			// new size in bytes to add 1 + 1K's worth of record spaces (nAl is +1)
		TI _n = max( (USI)(sz/eSz), (USI)i);	// add 1 + 1K's worth of spaces, or to req'd rec # if more.
		if (reAl(_n, erOp))
			return RCBAD; 		// (re)alloc rec spaces 1.._n, init nAl, ptr(), space[0], etc. above.
	}
	conRec(i);				// construct record i: mark in use, zero, init std base members, do specific record init.
	*_r = &rec(i);			// return pointer to the added record
	if (_name)
		(*_r)->SetName(_name);
	if (i > n)
		n = i;				// increase max in-use subscript (loop limit) to that just allocated
	return RCOK;			// error returns above
}			// basAnc::add
//---------------------------------------------------------------------------------------------------------------------------
RC FC basAnc::del( TI i, int erOp/*=ABT*/)			// delete (squeeze out) ith record
{
	if (validate("basAnc::del", erOp))	// check anchor ('this') vs its record block
		return RCBAD;
	desRec(i);							// conditionally destroy the record being deleted
	for (  ;  i < n;  i++)  			// loop over following records except last
	{
		record& dest = rec(i);
		record& src = rec(i+1);
		if (src.gud)				// if next record good
		{
			if (!dest.gud)
				conRec(i);		// construct destination if nec to insure vftp, rt, b, ss set.
			dest.CopyFrom(&src);	// copy record i+1 to i without dup'ing heap ptrs
			// tentatively no destroy: does nothing in base class, and deriv class might delete heap ptrs we did not dup.
#if defined( _DEBUG)
			dest.Validate();
#endif
		}
		else					// (not currently expected 2-92)
			dest.gud = 0;				// nothing to copy from next slot, say this slot is free
	}
	rec(i).gud = 0;    				// say vacated slot at end is free
	// if possible leftover undup'd ptrs in vacated slots with gud=0 are a problem, CONSTRUCT the slots (conRec(i)) to zero data.
	n--;					// max subscript is one less
	return RCOK;				// error return above.
}			// basAnc::del
//---------------------------------------------------------------------------------------------------------------------------
void basAnc::statSetup( 		// init anchor with given non-expandable static record memory

	record &r, 		// caller-supplied storage, size _n * sizeof(the record)
	TI _n, 			// number of records, to be subscripted 0 to _n-1. Typically 1.
	SI noZ /*=0*/, 	// non-0 to NOT zero caller's record storage: use if data-init
	SI inHeap /*=0*/)  	// non-0 if in heap: dmfree in destructor 5-31-92

// statSetup() vs al()/reAl():
// 1. statSetup allows direct access to record members in static storage when record subscript known,
//    as for 1-entry tables, while still allowing use of general record functions.
// 2. does not reserve all-0 entry [0] -- saves space for fixed size or single-entry tables.
// 3. statSetup does not allow expanding later.
// 4. statSetup inits all 0..n-1 entries now: no need to call add() for each entry as used.
{
	// initialize run-time anc members.  eSz and rt are init by constructor.
	setPtr( &r);
	if (inHeap)
		ba_flags |= RFHEAP;
	else
		ba_flags &= ~RFHEAP;	// inHeap arg to flags bit
	ba_flags |= RFSTAT;			// disable realloc and var data
	mn = 0;  					// minimum subscript is 0 for static (to save space: 1 large record is typical)
	nAl = _n;
	n = _n - 1;
	for (TI i = mn; i <= n; i++)
		conRec( i, noZ);		// construct all records now.  0 members unless noZ.
}		// basAnc::statSetup
//---------------------------------------------------------------------------------------------------------------------------
BP FC basAnc::anc4n( USI an, int erOp/*=ABT*/)		// access anc for anchor number
{
	if (an < 1 || an > Nanc || !ancs || ancs[an]==0)
	{
		err( erOp, (char *)MH_X0053, (INT)an);  		// "anc4n: bad or unassigned record anchor number %d"
		return 0;
	}
	return ancs[an];
}			// basAnc::anc4n
//---------------------------------------------------------------------------------------------------------------------------
RC FC basAnc::findAnchorByNm( char *_what, BP * _b)	// find anchor by name (.what) or return RCBAD (no msg here)
{
	BP b;
	USI an = 0;
	while (ancNext( an, &b))			// iterate anchors
		if (!_stricmp( _what, (char *)b->what))		// if name matches
		{
			if (_b)  *_b = b;
			return RCOK;		// NULL _b may be given to just test for validity of anchor name
		}
	return RCBAD;
}			// basAnc::findAnchorByNm
//---------------------------------------------------------------------------------------------------------------------------
SI FC basAnc::ancNext( USI &an, BP * _b)		// (registered) record anchor iterator

// init an to 0.  each call returns FALSE if done or returns an and *_b set to next anchor
// example:  for (USI an = 0; ancNext( an, &b); )  { ... }
{
	while (++an < Nanc)
		if (ancs[an])
		{
			*_b = ancs[an];     // skip (unexpected) NULL ptr
			return 1;
		}
	return 0;
}			// basAnc::ancNext
//---------------------------------------------------------------------------------------------------------------------------
RC basAnc::validate(	// validate an anchor: check self-consistency of anchor and its entry 0

	const char* fcnName,	// calling fcn name, for err msgs.
	int erOp /*=ABT*/,		// reporting control. ABT-->PABT, WRN-->PWRN here.
	SI noStat /*=0*/ )		// 0: caller's action OK on static-storage anchor. nz: not ok.

// if error, issues message, returns non-RCOK if not ABT
{
	record *p = ptr();					// fetch NULL or dm block ptr from derived class anchor
	erOp |= PROGERR;					// any errors here are internal errors (cnglob.h)

	if (!this)						// test for NULL this
		return err( erOp, (char *)MH_X0054, fcnName);	// "%s() called for NULL object pointer 'this'".

	if (p && (p->rt != rt				// check self-consistency: if bk alloc'd & rt does not match
	|| p->b != this)				//     or bk 0 doesn't point back at base
	||  !(rt & RTBRAT) )				//   or base rt not a RAT rt
		return err( erOp, (char *)MH_X0055, fcnName);	// errMsg "%s() argument not a valid anchor" & abort or return per erOp. rmkerr.cpp.

	if (noStat && (ba_flags & RFSTAT) )			// check staticness
		return err( erOp, (char *)MH_X0056, fcnName);  	// "%s(): illegal use of static-storage anchor"

	return RCOK;							// if here, all OK
}			// basAnc::validate
//---------------------------------------------------------------------------------------------------------------------------
RC basAnc::findRecByNm1(		// find record by 1st match on name, RCOK if found, no msg here.
	// can and should all uses be changed to findRecByNmU ?? <<<<
	const char* _name, 	// record name to look for
	TI *_i,       	// NULL or receives subscript of entry if found
	record **_r )   	// NULL or receives entry ptr if found
{
	if (!this)					// test for 0 'this' pointer
		return RCBAD;				// return NOT FOUND if called for NULL anc pointer (ocurs re types if .tyB 0)
	record *r;
	RLUPTHIS(r)						// loop over records, setting r to point to each good one
	if (r->IsNameMatch( _name))		// if matches (disregarding unexpected excess chars 11-94)
	{
		if (_i)  *_i = r->ss;  			// found. return info
		if (_r)  *_r = r;				// ..
		return RCOK;					// good return
	}
	return RCBAD;					// not found return
}			// basAnc::findRecByNm1
//---------------------------------------------------------------------------------------------------------------------------
RC basAnc::findRecByNmU( 		// find record by unique name match.  RCBAD not found, RCBAD2 ambiguous, no msgs here.
	const char* _name, 	// record name to look for
	TI *_i,      		// NULL or receives subscript of entry if found
	record **_r )   	// NULL or receives entry ptr if found
{
	if (!this)
		return RCBAD;   		// return NOT FOUND if called for NULL anc pointer (ocurs re types if .tyB 0)
	record *r, *r1 = nullptr;
	int nHits = 0;
	RLUPTHIS(r)						// loop over records, setting r to point to each good one
	{	if (r->IsNameMatch( _name))	// if matches
			if (nHits++)
				return RCBAD2;		// if seen before, bad (ambigous) return
			else
				r1 = r;				// else save record addr, continue search to be sure unique
	}

	if (!nHits)
		return RCBAD;				// no matches, give bad (not found) return
	if (_i)							// exactly 1 match if here.  return info.
		*_i = r1->ss;
	if (_r)
		*_r = r1;					// ..
	return RCOK;						// good return
}			// basAnc::findRecByNmU
//---------------------------------------------------------------------------------------------------------------------------
RC basAnc::findRecByNmO( 		// find record by name and owner subscript (first match).  No msg here.
	// see also findRecByNmDefO().
	const char* _name, 	// name to look for
	TI ownTi,		 	// required owner subscript (should be non-0)
	TI *_i,       		// NULL or receives subscript of entry if found
	record **_r )   	// NULL or receives entry ptr if found
{
	if (!this)
		return RCBAD;   		// return NOT FOUND if called for NULL anc pointer (occurs re types if .tyB 0)

	// add isOwnable check if it is possible for anchor to be non-ownAble, 2-92.
	record *r;
	RLUPTHIS(r)						// loop over records, setting r to point to each good one
	{	if (r->ownTi==ownTi			// if owning object subscript matches
		 && r->IsNameMatch(_name))	// if name matches
		{	if (_i)  *_i = r->ss;   		// found. return info
			if (_r)  *_r = r;				// ..
			return RCOK;					// good return
		}
	}
	return RCBAD;					// not found return
}			// basAnc::findRecByNmO
//---------------------------------------------------------------------------------------------------------------------------
RC basAnc::findRecByNmDefO( 			// find record by name, and owner if ambiguous

	// Accepts unambiguous match with another owner; returns info for caller to do detailed err msg if ambiguous; no msg here.
	// DOUBLE CAUTION: following recoded 3-92 without specific test:
	//// CAUTION: currently 1-92 does not check for multiple entries with same owner TI.

	const char* _name,	// name to look for
	TI ownTi,		 	// default owner subscript
	record **_r1,  		// NULL or rcvs entry ptr if any found; rcvs NULL if no match
	record **_r2 )  	// NULL or receives duplicate entry ptr if ambiguous

/* returns   found: RCOK,   *_r1 set.
          no match: RCBAD,  *_r1 NULL.
   ambiguous match: RCBAD2, *_r1 and *_r2 point to 1st 2 matching entries */
{
	// add isOwnable check if it is possible for anchor to be non-ownAble, 2-92.
	if (_r1)  *_r1 = NULL;			// init to "not found" as opposed to "ambiguous"
	if (!this)  return RCBAD;   		// return NOT FOUND if called for NULL anc pointer (ocurs re types if .tyB 0)
	SI oSeen=0, nHits=0;			// no name matches found yet
	record *r, *r1=NULL, *r2=NULL;
	RLUPTHIS(r)					// loop over records, setting r to point to each good one
	{	if (!oSeen || ownTi==r->ownTi)		// if no owned match yet or correct owner:
		// do not test any more wrong-owner records after one ownTi+name match.
			if (r->IsNameMatch( _name))	// if name matches
			{
				if (ownTi==r->ownTi && !oSeen++)	// if first record with correct owner
					nHits = 0;			// forget any name matches with wrong owner
				if (++nHits==1)     r1 = r;	// first match.  Will be returned as uniquely found record if no more matches.
				else if (nHits==2)  r2 = r;	// second match: save record pointer for "ambiguous" return
			}
	}
	if (nHits==0)  return RCBAD;		// not found.  Another NOT FOUND return above for NULL 'this'.
	if (_r1)  *_r1 = r1;			// first found record address
	if (nHits==1)  return RCOK;			// unique match: found
	if (_r2)  *_r2 = r2;			// second found record address
	return RCBAD2;				// nHits > 1: ambiguous
}			// basAnc::findRecByNmDefO
//-----------------------------------------------------------------------------
const char* basAnc::getChoiTx( 	// return text of given value for a choice data type, for error messages
	int fn, 	// field number. rccn.h define, eg AHU_TSU.  Field must have a "choicb" data type.
	int options /*=0*/,				// option bits
									//  1: no error messages for out of range chan
									//     (return displayable text indicating error)
	SI chan,	// value in field, or CHN(value) if a CHOICN type.
				// Possible internal values are C_xxxxxCH_yy defines in dtypes.h;
				// each internal value has a string that this fcn retreives
	BOOL* pIsHid /*=NULL*/) const	// optional return TRUE iff choice is hidden
										//   text returned w/o "*"

// if option&1 and chan out of range (but b and fn valid), displays no errMsg, so can be called b4 checking chan.
//  Recommend that caller not display returned text b4 checking for valid chan value. */

// returns string representing value; displayable even if error.
{

	// add more checks to this code if errors tend to happen...

	USI fdTy = fir[fn].fdTy;				// get field type (sFdtab subscript) from rat's "Fields In Record" table
	USI dt = sFdtab[fdTy].dtype;			// get data type from small Fields info Table

	chan &= ~NCNAN;					// clear special bits in nchoice value to make checks work
	if (options & 1)
	{	// added 3-1-94 as insurance -- no choicn calls at present.
		if (chan==0)  					// if unset
			return "<0>";				// bypass getChoiTx's error messages
		if (chan <= 0 || chan > GetDttab(dt).nchoices)	// if call good but field contents garbage (GetDttab: srd.h)
			return "<out of range>";				// issue no console error message here (caller already generating errmsg).
	}

	int pTyX;
	const char* chtx = ::getChoiTxI( dt, chan, &pTyX);	// get text for value 'chan' for data type dt.
    													// Errors issue messages but also return displayable value.
	if (pIsHid)
		*pIsHid = pTyX == chtyHIDDEN;
	return chtx;
}				// basAnc::getChoiTx
//=============================================================================

//*****************************************************************************
//  stuff for storing fileNames for record.fileIx member, used from cuTok.cpp etc etc 2-94
//	There is no provision for deleting a file name: indeces remain valid till end session.
//*****************************************************************************
const int FNCACHESZ = 50 + 1;				// max # file names to save, + 1 for unused 0 slot.
LOCAL char* fnCache[ FNCACHESZ] = { 0 };	// file names seen. [0] not used.
BOO NEAR tmfemFlag = FALSE;					// issue error message only once
//---------------------------------------------------------------------------
void clearFileIxs()
{
	for (USI i = 0; i < FNCACHESZ; i++)
		dmfree( DMPP( fnCache[i]));		// free heap block if ptr not NULL, set ptr NULL.

	tmfemFlag = FALSE;				// issue error message only once
}
//---------------------------------------------------------------------------
int getFileIx( 		// get file name index (fileIx) for file name

	const char* name, 				// name, not necessarily null-terminated
	int len /*=-1*/,				// length, or -1 if null-terminated
	char * * pFName4Ix /*=NULL*/ )	// NULL or receives pointer to null-terminated name in heap.
									// can receive NULL if table full.
{
	if (len < 0)
		len = strlen(name);

// search saved names, return existing index if found
	int i;
	for (i = 1;  i < FNCACHESZ && fnCache[i];  i++)
		if ( int( strlen(fnCache[i])) == len
		 &&  memicmp( name, (void *)fnCache[i], len)==0 )
			break;  						// found. i is index to return.

// i is index of found name, free slot, or off end table if full
	char *p = NULL;						// string ptr to optionally return
	if (i >= FNCACHESZ)
	{
		if (!tmfemFlag++)					// issue too many files error message only once
			err( WRN, "More than %d input files\n"
				 "    (enlarge \"fnCache[]\" in ancrec.cpp)",
				 FNCACHESZ );
		// fall thru to return FNCACHESZ for files in excess of max
	}

// add to table
	else							// did not run off end of table
	{	if (!fnCache[i])						// if found free slot (not match)
			if (!dmal( DMPP( fnCache[i]), len+1, WRN|DMZERO))	// allocate space for name and null, dmpak.cpp.
				memcpy( fnCache[i], name, len);			// if ok, store name text
		p = fnCache[i];						// pointer to name text for optional return
	}

// optionally return heap text pointer
	if (pFName4Ix)
	{	dmfree( DMPP( *pFName4Ix));	// decrement ref count of prior value we are about to overwrite
		dmIncRef( DMPP( p));		// NOP if NULL
		*pFName4Ix = p;
	}
	return i;
}		// getFileIx
//---------------------------------------------------------------------------
const char* getFileName( int fileIx)		// get text for file name index
{
	if (fileIx > 0  &&  fileIx < FNCACHESZ  &&  fnCache[fileIx])
	{	const char* p = fnCache[fileIx];	// NOT INCREF'd: only for transitory use in error messages, etc.
		if (TestOptions & 1)
			// hide dirpaths, set from command line -t
			//   allows location-independent reference report files
			p = strpathparts( p, STRPPFNAME+STRPPEXT);
		return p;
	}

	if (fileIx > FNCACHESZ)
		return "(too many files)";

	return "(bug)";				// (or memory was full at name save)
}			// getFileName

//*************************************************** IF-OUTS *************************************************************

// end of ancrec.cpp
